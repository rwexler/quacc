var __index = {"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"quacc \u2014 the Quantum Accelerator","text":"<p>Quacc (pronounced \"quack\") is a flexible and extensible platform for high-throughput computational materials science and quantum chemistry.</p> <p>The three main goals of quacc are to:</p> <ol> <li> <p>Reduce the barrier for running complex, mixed-code workflows for molecules and materials across distributed compute environments.</p> </li> <li> <p>Promote rapid workflow development and testing via modern workflow management solutions.</p> </li> <li> <p>Enable a seamless interface between the Atomic Simulation Environment and the software infrastructure powering the Materials Project.</p> </li> </ol> <p></p>"},{"location":"about/changelog.html","title":"Changelog","text":"CHANGELOG.md<pre><code># Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/), and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n### Added\n\n- Added a custom Q-Chem calculator based on Pymatgen and Custodian.\n- Added Q-chem core recipes.\n- Added the ability to pass option `run_kwargs` to the `.run()` method of the ASE optimizers.\n\n### Changed\n\n- Renamed `quacc.util` to `quacc.utils`\n\n## [0.2.2]\n\n### Changed\n\n- Changed package handling in `pyproject.toml` to better handle pip installs.\n\n## [0.2.1]\n\n### Added\n\n- Added NewtonNet recipes and better sella support (@kumaranu)\n\n### Changed\n\n- Standardized `relax_cell` to be `False` by default for all recipes.\n- Update the default `SIGMA` and `ISMEAR` in `MPScanSet` to match the new values to be used in Atomate2.\n\n### Fixed\n\n- Fixed a bug on Windows where the trajectory file would not be closed after a relaxation, causing permission errors.\n\n### Removed\n\n- Removed atomate2 as a dependency.\n- Removed experimental Prefect support.\n\n## [0.2.0]\n\n### Added\n\n- Added a quacc global setting, `WORKFLOW_ENGINE`, to set the workflow manager.\n- Added support for the new `covalent-hpc-plugin` in `pyproject.toml`.\n\n### Changed\n\n- Quacc recipes are now decorated with generic `#!Python @job`, `#!Python @subflow`, or `#!Python @flow` decorators to be workflow engine-agnostic.\n- Covalent is now an optional dependency to allow the base `quacc` package to be dependency-light.\n- Default VASP pseudopotentials changed to `setups_pbe54.yaml`.\n- Changed `quacc.recipes.emt.jobflow` and `quacc.recipes.emt.prefect` to `quacc.recipes.emt._jobflow` and `quacc.recipes.emt._prefect`\n\n### Fixed\n\n- Set `LMAXMIX` based on the `Z` value, not the s/p/d/f-block type.\n- Do not set automatically `LMAXTAU` to 8 for f-containing elements in `Vasp` calculator.\n\n### Removed\n\n- Removed `quacc.recipes.emt.parsl` since it is now obsolete.\n- Removed `quacc config` command-line option.\n\n## [0.1.3]\n\n### Added\n\n- Added a `PRIMARY_STORE` quacc setting that, when specified, will automatically store all results in the specified Maggma store.\n\n### Changed\n\n- The trajectory is now stored in `quacc.schemas.cclib.summarize_run`.\n- By default, results are now stored in a fixed `RESULTS_DIR`, which defaults to the current working directory.\n\n### Fixed\n\n- Fix path-related issues when running in local multi-threaded mode.\n- Psi4 recipes now use `uks` for unrestricted calculations instead of `uhf`.\n\n## [0.1.2]\n\n### Added\n\n- Added support for Prefect.\n- Added `quacc.utils.wflows` module.\n\n### Changed\n\n- Made slab-related kwargs more consistent, such as by changing `slab_relax_electron`/`slab_relax_app` to just `slab_relax` regardless of workflow manager.\n\n## [0.1.1]\n\n### Added\n\n- Added this `CHANGELOG.md` file.\n- Added the `quacc.recipes.emt.parsl` module.\n- Added a CLI for `quacc` along with a `quacc config` option to configure Covalent appropriately upon install.\n- Added generic type hints for schemas.\n- Added a `CREATE_UNIQUE_WORKDIR` global setting to have quacc automatically make a unique working directory for each calculation.\n- Added `CHECK_CONVERGENCE` to global settings.\n\n### Changed\n\n- The `quacc` directory is now found in a `src` basefolder.\n- All recipes now support the `Atoms` object being passed in as an `AtomsSchema`.\n- The `slab_relax_job` kwarg in `recipes.emt.slabs` and `recipes.vasp.slabs` workflows can no longer be set to `None`, as there are few situations where this would be desired.\n- Class-based recipes have been converted to functions since they don't save state or have inheritance.\n\n### Docs\n\n- Switched the docs from Furo to Material for MkDocs.\n- Expanded upon Parsl documentation.\n- Modified tutorials and added example configs for Slurm.\n\n### Fixed\n\n- Temporary directories are cleaned up after the run is completed.\n\n### Removed\n\n- Removed `quacc.recipes.vasp.jobflow` module to prioritize Covalent and Parsl.\n\n## [0.1.0]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.1.0 for more details.\n\n## [0.0.6]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.6 for more details.\n\n## [0.0.5]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.5 for more details.\n\n## [0.0.4]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.4 for more details.\n\n## [0.0.3]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.3 for more details.\n\n## [0.0.2]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.2 for more details.\n\n## [0.0.1]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.1 for more details.\n</code></pre>"},{"location":"about/conduct.html","title":"Code of Conduct","text":""},{"location":"about/conduct.html#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"about/conduct.html#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"about/conduct.html#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"about/conduct.html#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"about/conduct.html#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"about/conduct.html#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"about/conduct.html#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"about/conduct.html#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"about/conduct.html#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"about/conduct.html#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"about/conduct.html#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"about/contributors.html","title":"People","text":""},{"location":"about/contributors.html#developers","title":"Developers","text":"<p>Quacc was designed and developed by:</p> <ul> <li>Andrew S. Rosen, GitHub: arosen93, ORCID: 0000-0002-0141-7006.</li> </ul>"},{"location":"about/contributors.html#contributors","title":"Contributors","text":"<p>Additional contributions were made by the individuals listed here.</p>"},{"location":"about/contributors.html#inspiration","title":"Inspiration","text":"<p>Quacc was originally inspired by Atomate2, developed by Alex Ganose.</p>"},{"location":"about/faq.html","title":"FAQ","text":"<p>Q: Which workflow management system should I use?</p> <p>A: Good question! Check out the Workflow Engines Overview Guide for a comparison of several common options to see which might be best for you.</p> <p>Q: Why is quacc better than <code>InsertMyFavoriteCode</code>?</p> <p>A: Better is all in the eye of the beholder. If you are happy with the tools you are using, my goal is not to convince you to switch. That said, if you find that writing high-throughput computational workflows has a huge learning curve or simply takes too much time away from your science, then quacc may be for you.</p> <p>Q: Do you have any tips for writing new workflows?</p> <p>A: When developing new workflows, I strongly recommend writing an initial draft based on a low-cost ASE calculator like <code>EMT</code> or <code>LJ</code>, which will allow you to test on your local machine with fast turnaround. Also try to keep things modular. Trying to do too much in one function can make it difficult to debug.</p> <p>Q: How is quacc different than just using the Atomic Simulation Environment (ASE)</p> <p>A: quacc is designed to supercharge ASE for the efficient design of high-throughput workflows. Quacc makes it possible to easily design complex ASE workflows that can be run on heterogeneous compute environments with modern workflow managers, such as Covalent and Jobflow. Quacc also makes it possible to combine ASE with the powerful Materials Project software stack, such as Custodian for on-the-fly error handling. For the database enthusiasts, quacc is interoperable with Maggma to store calculation results in a readily queryable format like MongoDB.</p> <p>Q: How is quacc different than Atomate2?</p> <p>A: Atomate2 is a fantastic code that can be used to run libraries of computational materials science workflows. Quacc was originally inspired by Atomate2 and can be thought of as a \"sister code\" to it. That said, there are several important differences.</p> <ul> <li> <p>In Atomate2, workflows are built around the Materials Project software stack and can be cumbersome to interface with the Atomic Simulation Environment (ASE). In contrast, quacc was built around ASE from the ground up while still making it possible to leverage much of the software underlying the Materials Project. Since quacc is built around ASE, it is also trivial to add new recipes based on any code that has an existing ASE Calculator even if it is not in quacc yet.</p> </li> <li> <p>Atomate2 is built around Jobflow. Quacc is largely workflow engine-agnostic and has out-of-the-box support for numerous workflow codes, including but not limited to Jobflow.</p> </li> <li> <p>Atomate2 is often used as a database-first approach to materials science workflows. Quacc is fully compatible with the use of databases but only emphasizes their use for experts, with the goal of reducing the barrier to getting started.</p> </li> <li> <p>Atomate2 is developed and supported by the Materials Project team at Lawrence Berkeley National Laboratory. Quacc is developed and maintained by the Rosen Research Group at Princeton University.</p> </li> </ul> <p>Despite these differences, quacc and Atomate2 are largely interoperable! Feel free to stitch together workflows from both codes as you see fit using Jobflow!</p> <p>Q: I want to contribute a new recipe to quacc, but it will require additional dependencies. Is that a problem?</p> <p>A: Absolutely not a problem! Simply make your dependencies optional in the <code>pyproject.toml</code> file and use a <code>monty.dev.requires</code> decorator to ensure your recipes and tests only run if your necessary dependencies are installed. Refer to <code>quacc.recipes.tblite.core</code> and the <code>[tblite]</code> extras in the <code>pyproject.toml</code> file for an example.</p>"},{"location":"about/license.html","title":"License","text":"LICENSE.md<pre><code>BSD 3-Clause License\n\nCopyright (c) 2023, Andrew S. Rosen.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n- Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n- Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n- Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n</code></pre>"},{"location":"dev/contributing.html","title":"Contributing","text":"<p>We welcome all contributions, big or small (provided they come with unit tests!). Here are some general guidelines and tips. Note that it is never too early to open a PR if you're looking for input or feedback!</p>"},{"location":"dev/contributing.html#general-tips","title":"General Tips","text":"<p>When developing new recipes, it is often helpful to start from an existing example. In general, we recommend referring to <code>quacc.recipes.emt</code> or <code>quacc.recipes.tblite</code>. Some advanced use cases can also be found in the VASP recipes.</p>"},{"location":"dev/contributing.html#steps-to-contribute","title":"Steps to Contribute","text":"<p>To contribute to quacc, we recommend doing the following:</p> <ul> <li> <p>Fork the repository to your personal GitHub account.</p> </li> <li> <p>Clone this forked repository to your local machine, e.g. via <code>git clone &lt;repo url&gt;.git</code>.</p> </li> <li> <p>In the newly downloaded <code>quacc</code> base directory, run <code>pip install -e .[dev]</code> to install quacc in editable mode and with the development dependencies.</p> </li> <li> <p>Commit your changes and push them to your personal forked repository in a new branch.</p> </li> <li> <p>Create a pull request (PR) to merge your changes into the main quacc repository.</p> </li> </ul> <p>For reproducibility purposes, we strongly recommend installing quacc in a fresh virtual environment.</p>"},{"location":"dev/contributing.html#guidelines","title":"Guidelines","text":"<p>Please abide by the following guidelines when contributing code to quacc:</p> <ul> <li> <p>All changes should have associated unit tests that pass. Code coverage should be maintained.</p> </li> <li> <p>All code should include type hints and have internally consistent documentation for the inputs and outputs.</p> </li> <li> <p>Only define multi-step workflows if they go beyond simply stitching together existing functions or if they are widely used in other recipes. Otherwise, just define the individual functions.</p> </li> <li> <p>Ensure that the code remains flexible for the user whenever possible.</p> </li> <li> <p>Where appropriate, you should use the \"internal\" geometry optimizers for a given code rather than the ASE optimizers.</p> </li> <li> <p>Use absolute paths where possible and avoid using <code>os.chdir</code>. This helps ensure that quacc can be run in a multi-threading mode.</p> </li> <li> <p><code>gzip</code> large test files to save space.</p> </li> <li> <p>Update the <code>CHANGELOG.md</code> file.</p> </li> </ul>"},{"location":"dev/contributing.html#changelog","title":"Changelog","text":"<p>We keep a <code>CHANGELOG.md</code> file in the base directory of the quacc code. Before submitting your PR, be sure to update the <code>CHANGELOG.md</code> file under the \"Unreleased\" section with a brief description of your changes. The <code>CHANGELOG.md</code> file follows the Keep a Changelog format.</p>"},{"location":"dev/contributing.html#style-guidelines","title":"Style Guidelines","text":"<p>In general, please try to keep the code style consistent when possible. There are two main things to consider:</p> <ol> <li> <p>All Python code should be formatted with isort and then black, although this will be corrected automatically when merged.</p> </li> <li> <p>Use NumPy-style Docstrings.</p> </li> <li> <p>Address any relevant style issues raised by the \"Deepsource: Python\" and \"Sourcery\" GitHub actions, if present.</p> </li> <li> <p>Functions should be lowercase and with underscores. Classes should be in PascalCase and constructed using a <code>@dataclass</code> decorator where possible.</p> </li> </ol>"},{"location":"dev/contributing.html#unit-tests","title":"Unit Tests","text":"<p>All changes you make to quacc should be accompanied by unit tests and should not break existing tests. To run the full test suite, run <code>pytest .</code> from the the <code>quacc/tests</code> directory. Each PR will report the coverage once your tests pass, but if you'd like to generate a coverage report locally, you can use pytest-cov, such as by doing <code>pytest --cov=quacc .</code> in the <code>tests</code> directory.</p> <p>If you are adding recipes based on a code that can be readily installed via <code>pip</code> or <code>conda</code> (e.g. tblite, DFTB+, Psi4), then you can run these codes directly in the test suite. Preferably, you should use a small molecule or solid and cheap method so the unit tests run quickly. If the recipes you're adding are proprietary or not available via <code>pip</code> or <code>conda</code> (e.g. Gaussian, GULP), then you will need to monkeypatch certain functions to change their behavior during testing. For instance, we do not want to run VASP directly during unit tests and have mocked the <code>atoms.get_potential_energy()</code> function to always return a dummy value of -1.0 during unit tests. Any mocked functions can be found in the <code>conftest.py</code> files of the testing directory.</p>"},{"location":"dev/docs.html","title":"Documentation","text":"<p>To install the dependencies to build the documentation, install the <code>[docs]</code> extras listed in <code>pyproject.toml</code>.</p> <p>The quacc documentation is built using Material for MkDocs. To build the documentation locally (e.g. to evaluate changes), run <code>mkdocs serve</code> in the base directory and open the URL shown in the terminal.</p>"},{"location":"install/codes.html","title":"Calculator Setup","text":"<p>Tip</p> <p>Just getting started? Try using the EMT or LJ recipes before worrying about setting up one of the calculators below.</p> <p>Here, we outline how to ensure that quacc can run the quantum chemistry package of your choosing. You only need to follow the instructions for the code(s) you intend to use.</p>"},{"location":"install/codes.html#dftb","title":"DFTB+","text":"<p>Note</p> <p>DFTB+ is especially useful for periodic GFN-xTB calculations and the DFTB+ method based on Slater-Koster parameters.</p> <p>If you plan to use DFTB+ with quacc, you will need to install the code as follows:</p> <pre><code>conda install -c conda-forge dftbplus\n</code></pre>"},{"location":"install/codes.html#emt","title":"EMT","text":"<p>Note</p> <p>Effective medium theory (EMT) is a semi-empirical method for modeling solids that is predominantly used for prototyping workflows. Because it is solely for demonstration purposes, it only supports the following metals: Al, Ni, Cu, Pd, Ag, Pt, and Au.</p> <p>No setup needed!</p>"},{"location":"install/codes.html#gaussian","title":"Gaussian","text":"<p>Note</p> <p>Gaussian is an extremely popular molecular DFT code that is quite robust and easy to use.</p> <p>As noted in the ASE documentation, you will need to define an environment variable named <code>ASE_GAUSSIAN_COMMAND</code>. It should be formatted as follows:</p> <pre><code>ASE_GAUSSIAN_COMMAND=\"/path/to/my/gaussian_executable Gaussian.com &gt; Gaussian.log\"\n</code></pre>"},{"location":"install/codes.html#gulp","title":"GULP","text":"<p>Note</p> <p>GULP is especially useful for periodic GFN-FF calculations and force field methods. GULP can be downloaded and installed here.</p> <p>As noted in the ASE documentation, you must set the environment variables <code>GULP_LIB</code> and <code>ASE_GULP_COMMAND</code> as follows:</p> <pre><code>GULP_LIB=\"/path/to/my/gulp-#.#.#/Libraries\" ASE_GULP_COMMAND=\"/path/to/my/gulp-#.#.#/Src/gulp &lt; gulp.gin &gt; gulp.got\"\n</code></pre>"},{"location":"install/codes.html#lennard-jones","title":"Lennard Jones","text":"<p>Note</p> <p>Lennard Jones (LJ) is an empirical potential that is predominantly used for prototyping workflows for molecules.</p> <p>No setup needed!</p>"},{"location":"install/codes.html#newtonnet","title":"NewtonNet","text":"<p>Note</p> <p>NewtonNet is a message passing networking for deep learning of interatomic potentials and forces, as described here.</p> <p>If you plan to use NewtonNet with Quacc, you will need to install it prior to use. This can be done as follows:</p> <pre><code>pip install quacc[newtonnet]\n</code></pre>"},{"location":"install/codes.html#orca","title":"ORCA","text":"<p>Note</p> <p>ORCA is a free code that is especially useful for molecular DFT calculations with recently developed methods. ORCA can be downloaded and installed here.</p> <p>To use quacc with ORCA, you will need to define the <code>ORCA_CMD</code> setting to be the full, absolute path to your ORCA executable. This can be done as described in the section on \"Modifying Quacc Settings\", such as by defining the following environment variable:</p> <pre><code>QUACC_ORCA_CMD=/path/to/my/orca/orca\n</code></pre>"},{"location":"install/codes.html#psi4","title":"Psi4","text":"<p>Note</p> <p>Psi4 is an open-source quantum chemistry electronic structure package.</p> <p>If you plan to use Psi4 with quacc, you will need to install it prior to use. This can be done as described in the Psi4 installation guide.</p>"},{"location":"install/codes.html#q-chem","title":"Q-Chem","text":"<p>Note</p> <p>Q-Chem is a powerful, general-purpose molecular DFT code with a variety of features.</p> <p>If you plan to use Q-Chem with Quacc, you will need to install <code>openbabel</code> and <code>sella</code> (recommended) prior to use. This can be done as follows:</p> <pre><code>conda install -c conda-forge openbabel\npip install quacc[optimizers]\n</code></pre>"},{"location":"install/codes.html#tblite","title":"tblite","text":"<p>Note</p> <p>tblite is a code that interfaces with the xtb package for running GFN-xTB calculations.</p> <p>If you plan to use tblite with quacc, you will need to install the tblite interface with ASE support.</p> <p>If you are using a Linux mmachine, run the following:</p> <pre><code>pip install quacc[tblite]\n</code></pre> <p>If you are using a Mac, run the following:</p> <pre><code>conda install -c conda-forge tblite-python\n</code></pre>"},{"location":"install/codes.html#vasp","title":"VASP","text":"<p>Note</p> <p>VASP is a very widely used code for plane-wave, periodic DFT calculations. Quacc has built-in support for automatically fixing failed VASP jobs via Custodian.</p> <p>To use VASP with quacc, you will need to do the following, as described in greater detail in the ASE documentation:</p> <ul> <li>Define the <code>VASP_PP_PATH</code> environment variable that points to your pseudopotential library. We recommend including this in your <code>~/.bashrc</code> file since this rarely changes.</li> <li>If you wish to use vdW functionals, define the <code>ASE_VASP_VDW</code> environment variable to point to the <code>vdw_kernel.bindat</code> file distributed with VASP. We recommend including this in your <code>~/.bashrc</code> file since this rarely changes.</li> </ul> <p>To run VASP with Custodian, you will also need to modify the relevant quacc configuration settings, most notably:</p> <ul> <li>Define the <code>VASP_PARALLEL_CMD</code> quacc setting that tells Custodian how to parallelize VASP, such as by defining an environment variable <code>QUACC_VASP_PARALLEL_CMD=\"srun -N 2 --ntasks-per-node 24\"</code>. Note, the VASP executables are not included in this environment variable.</li> </ul>"},{"location":"install/install.html","title":"Installation","text":""},{"location":"install/install.html#pre-requisites","title":"Pre-Requisites","text":"<p>Note</p> <p>If you are on a Windows machine, we recommend using the Windows Subsystem for Linux (WSL) to benefit from all the features of quacc.</p> <ol> <li>Install Python, preferably in conjunction with an environment manager. For instance, download and run the Miniconda installer</li> <li>When asked to add Miniconda to your <code>PATH</code>, select yes</li> <li>Create a fresh Python environment by running <code>conda create -n quacc python=3.10</code></li> <li>Activate this environment via <code>conda activate quacc</code></li> </ol>"},{"location":"install/install.html#installing-quacc","title":"Installing quacc","text":"<p>In your newly activated conda environment, run the following commands to install quacc. Note that you will need to install quacc on all machines where you plan to run calculations.</p> <p>For the latest PyPI release:</p> <pre><code># Install development version of ASE\npip install --upgrade https://gitlab.com/ase/ase/-/archive/master/ase-master.zip\n\n# Install quacc\npip install quacc\n</code></pre> <p>For the development version:</p> <pre><code># Install development version of ASE\npip install --upgrade https://gitlab.com/ase/ase/-/archive/master/ase-master.zip\n\n# Install development version of quacc\npip install git+https://github.com/quantum-accelerators/quacc.git\n</code></pre> <p>Tip</p> <p>Everything beyond this point in the installation guide is to add on useful features to quacc. So, if you are just getting started, check out the User Guide page. Then come back to installing additional features as you need them.</p>"},{"location":"install/install.html#optional-dependencies","title":"Optional Dependencies","text":"<p>Quacc can be installed with several \"extras,\" as outlined in the <code>pyproject.toml</code> file. To install the extras, you can run</p> <pre><code>pip install quacc[extra]\n</code></pre> <p>where <code>extra</code> is one of the following:</p>"},{"location":"install/install.html#calculators","title":"Calculators","text":"<ul> <li><code>quacc[newtonnet]</code>: Installs dependencies to enable the use NewtonNet recipes.</li> <li><code>quacc[tblite]</code>: Installs dependencies to enable the use of tblite (on Linux).</li> </ul>"},{"location":"install/install.html#workflow-managers","title":"Workflow Managers","text":"<ul> <li><code>quacc[covalent]</code>: Installs dependencies to enable the use of Covalent.</li> <li><code>quacc[jobflow]</code>: Installs dependencies to enable the use of Jobflow with FireWorks.</li> <li><code>quacc[parsl]</code>: Installs dependencies to enable the use of Parsl.</li> </ul>"},{"location":"install/install.html#miscellaneous","title":"Miscellaneous","text":"<ul> <li><code>quacc[defects]</code>: Installs dependencies to enable the use of defect workflows.</li> <li><code>quacc[optimizers]</code>: Installs dependencies to enable the use of the Sella optimizer.</li> </ul>"},{"location":"install/install.html#development","title":"Development","text":"<ul> <li><code>quacc[dev]</code>: Installs dependencies to enable local development of quacc.</li> <li><code>quacc[docs]</code>: Installs dependencies to build the documentation.</li> <li><code>quacc[strict]</code>: Installs dependencies that match the test suite on GitHub.</li> </ul>"},{"location":"install/wflow_engines.html","title":"Workflow Engine Setup","text":"<p>Using a workflow engine is a crucial component for scaling up quacc calculations in a high-throughput setting. We describe the necessary installation steps here for the workflow manager of your choosing.</p> <p>Tip</p> <p>If you are just getting started with workflow engines, we recommend trying Covalent. For a comparison of the different compatible workflow engines, refer to the Workflow Engines Overview section.</p> CovalentParslJobflow <p>Installation</p> <p>To install Covalent, run</p> <pre><code>pip install quacc[covalent]\n</code></pre> <p>Starting the Server</p> <p>Covalent uses a server to dispatch and store calculation details and results. To start the server, simply run <code>covalent start</code> in your terminal. It will return a URL (usually http://localhost:48008) that you can use to access the Covalent dashboard, which is shown below.</p> <p></p> <p>Tip</p> <p>Once you start scaling up your calculations, we recommend hosting the Covalent server on a dedicated machine or using Covalent Cloud. Refer to the Covalent Deployment Guide for details.</p> <p>In your activated Python environment, install Parsl as follows:</p> <pre><code>pip install quacc[parsl]\n</code></pre> <p>Parsl has many configuration options, which we will cover later in the documentation.</p> <p>Installation</p> <p>To install Jobflow with support for FireWorks, run the following:</p> <pre><code>pip install quacc[jobflow]\n</code></pre> <p>MongoDB Setup</p> <p>Jobflow and FireWorks both require the use of a database (most commonly a MongoDB instance) to store calculation results.</p> <p>Note</p> <p>If it is not possible to use MongoDB, you can use a variety of other data store options available within the maggma package, including a <code>MontyStore</code> that solely relies on the local filesystem.</p> <p>Jobflow DB Setup</p> <p>If you plan to use Jobflow to write your workflows, you will need to make a <code>jobflow.yaml</code> file. This file will generally be formatted like the example below. Fill in the fields with the appropriate values for your MongoDB cluster, which is where all your calculation inputs and outputs will be stored.</p> jobflow.yaml<pre><code>JOB_STORE:\ndocs_store:\ntype: MongoStore\nhost: &lt;host name&gt;\nport: 27017\nusername: &lt;username&gt;\npassword: &lt;password&gt;\ndatabase: &lt;database name&gt;\ncollection_name: &lt;collection name&gt;\n</code></pre> <p>Note</p> <p>If you are using a URI (as is common with MongoDB Atlas), then you will instead have a <code>jobflow.yaml</code> file that looks like the example below. Here, you will put the full URI in the <code>host</code> field. The <code>username</code> and <code>password</code> are part of the URI and so should not be included elsewhere in the YAML file.</p> jobflow.yaml<pre><code>JOB_STORE:\ndocs_store:\ntype: MongoStore\nhost: &lt;URI&gt;\nport: 27017\ndatabase: &lt;database name&gt;\ncollection_name: &lt;collection name&gt;\n</code></pre> <p>You will then need to define a <code>JOBFLOW_CONFIG_FILE</code> environment variable pointing to the file you made. For instance, in your <code>~/.bashrc</code> file, add the following line:</p> <pre><code>export JOBFLOW_CONFIG_FILE=\"/path/to/my/jobflow.yaml\"\n</code></pre> <p>FireWorks DB Setup</p> <p>If you plan to use FireWorks to dispatch your Jobflow workflows, you will also need to make a few configuration files: <code>FW_config.yaml</code>, <code>my_fworker.yaml</code>, <code>my_launchpad.yaml</code>, and <code>my_qadapter.yaml</code>. To begin, make a directory called <code>fw_config</code> where you will store the four files described in greater detail below. The directory structure will look like the following:</p> <pre><code>fw_config\n\u251c\u2500\u2500 FW_config.yaml\n\u251c\u2500\u2500 my_fworker.yaml\n\u251c\u2500\u2500 my_launchpad.yaml\n\u2514\u2500\u2500 my_qadapter.yaml\n</code></pre> <p>FW Config File</p> <p>For the <code>FW_config.yaml</code>, you can use the following template. Make sure to update the path to the <code>fw_config</code> folder where the file resides.</p> FW_config.yaml<pre><code>CONFIG_FILE_DIR: &lt;/path/to/fw_config&gt;\nQUEUE_UPDATE_INTERVAL: 2\n</code></pre> <p>You will also need to define a <code>FW_CONFIG_FILE</code> environment variable pointing to the <code>FW_config.yaml</code> file you made. For instance, in your <code>~/.bashrc</code> file, add the following line:</p> <pre><code>export FW_CONFIG_FILE=\"/path/to/config/fw_config/FW_config.yaml\"\n</code></pre> <p>FWorker</p> <p>For the <code>my_fworker.yaml</code>, you can use the following template. You do not need to make any modifications.</p> my_fworker.yaml<pre><code>name: quacc_fworker\ncategory: \"\"\nquery: \"{}\"\n</code></pre> <p>Launchpad</p> <p>For the <code>my_launchpad.yaml</code>, you can use the following template. Replace the entries in <code>&lt;&gt;</code> with the appropriate values for your Mongo database.</p> my_launchpad.yaml<pre><code>host: &lt;host name&gt;\nport: 27017\nname: &lt;database name&gt;\nusername: &lt;username&gt;\npassword: &lt;password&gt;\nlogdir: null\nIstrm_lvl: DEBUG\nuser_indices: []\nwf_user_indices: []\n</code></pre> <p>Note</p> <p>If you are accessing your MongoDB via a URI (e.g. as with MongoDB Atlas), then you will use the following <code>my_launchpad.yaml</code> template instead.</p> my_launchpad.yaml<pre><code>host: &lt;URI&gt;\nport: 27017\nname: &lt;database name&gt;\nuri_store: true\nlogdir: null\nIstrm_lvl: DEBUG\nuser_indices: []\nwf_user_indices: []\n</code></pre> <p>QAdapter</p> <p>Assuming you plan to use a queuing system for your compute jobs, you will need to make a <code>my_qadapter.yaml</code> file. For this, you will need to follow the instructions in the FireWorks documentation for your specific job scheduling system. An example <code>my_qadapter.yaml</code> file is shown below for Slurm.</p> my_qadapter.yaml<pre><code>_fw_name: CommonAdapter\n_fw_q_type: SLURM\nrocket_launch: rlaunch -w /path/to/fw_config/my_fworker.yaml singleshot\nnodes: 2\nwalltime: 00:30:00\naccount: &lt;account&gt;\njob_name: quacc_firework\nqos: regular\npre_rocket: |\nmodule load vasp\nexport QUACC_VASP_PARALLEL_CMD=\"srun -N 2 --ntasks-per-node=24 --cpu_bind=cores\"\n</code></pre> <p>In the above example, you would need to change the path in the <code>rocket_launch</code> field to the correct path to your <code>my_fworker.yaml</code>. The nodes, walltime, account, and qos are the corresponding parameters for your queuing system. Finally, anything in the <code>pre_rocket</code> field will be executed before the job begins running. It is a good place to load modules and set environment variables. A representative example has been provided above.</p> <p>Database Initialization</p> <p>Warning</p> <p>Running <code>lpad reset</code> will clear your FireWorks launchpad, so only use this command if you are a new user.</p> <p>To check that FireWorks can connect to your database, run <code>lpad reset</code> if this is your first time using FireWorks.</p>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>quacc<ul> <li>calculators<ul> <li>qchem</li> <li>vasp</li> </ul> </li> <li>custodian<ul> <li>qchem</li> <li>vasp</li> </ul> </li> <li>recipes<ul> <li>dftb<ul> <li>core</li> </ul> </li> <li>emt<ul> <li>_jobflow<ul> <li>slabs</li> </ul> </li> <li>core</li> <li>defects</li> <li>slabs</li> </ul> </li> <li>gaussian<ul> <li>core</li> </ul> </li> <li>gulp<ul> <li>core</li> </ul> </li> <li>lj<ul> <li>core</li> </ul> </li> <li>newtonnet<ul> <li>core</li> <li>ts</li> </ul> </li> <li>orca<ul> <li>core</li> </ul> </li> <li>psi4<ul> <li>core</li> </ul> </li> <li>qchem<ul> <li>core</li> <li>ts</li> </ul> </li> <li>tblite<ul> <li>core</li> </ul> </li> <li>vasp<ul> <li>core</li> <li>mp</li> <li>qmof</li> <li>slabs</li> </ul> </li> </ul> </li> <li>schemas<ul> <li>ase</li> <li>atoms</li> <li>cclib</li> <li>vasp</li> </ul> </li> <li>settings</li> <li>utils<ul> <li>atoms</li> <li>calc</li> <li>db</li> <li>defects</li> <li>dicts</li> <li>files</li> <li>slabs</li> <li>thermo</li> <li>wflows</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/quacc/settings.html","title":"settings","text":"<p>Settings for quacc</p>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings","title":"QuaccSettings","text":"<p>             Bases: <code>BaseSettings</code></p> <p>Settings for quacc.</p> <p>The default way to modify these is to make a ~/.quacc.yaml file. Alternatively, the environment variable QUACC_CONFIG_FILE can be set to point to a yaml file with quacc settings.</p> <p>The variables can also be modified individually though environment variables by using the \"QUACC\" prefix. e.g. QUACC_SCRATCH_DIR=/path/to/scratch.</p>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.Config","title":"Config","text":"<p>Pydantic config settings.</p>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.load_default_settings","title":"load_default_settings","text":"<pre><code>load_default_settings(values)\n</code></pre> <p>Loads settings from a root file if available and uses that as defaults in place of built in defaults.</p> <p>Parameters:</p> <ul> <li> values             (<code>dict</code>)         \u2013          <p>Settings to load.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Loaded settings.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/settings.py</code> <pre><code>@root_validator(pre=True)\ndef load_default_settings(cls, values: dict) -&gt; dict:\n\"\"\"\n    Loads settings from a root file if available and uses that as defaults in\n    place of built in defaults.\n    Parameters\n    ----------\n    values\n        Settings to load.\n    Returns\n    -------\n    dict\n        Loaded settings.\n    \"\"\"\nfrom monty.serialization import loadfn\nconfig_file_path = values.get(\"CONFIG_FILE\", _DEFAULT_CONFIG_FILE_PATH)\nnew_values = {}\nif os.path.exists(os.path.expanduser(config_file_path)):\nnew_values |= loadfn(os.path.expanduser(config_file_path))\nnew_values.update(values)\nreturn new_values\n</code></pre>"},{"location":"reference/quacc/calculators/qchem.html","title":"qchem","text":"<p>A Q-Chem calculator built on Pymatgen and Custodian functionality</p>"},{"location":"reference/quacc/calculators/qchem.html#quacc.calculators.qchem.QChem","title":"QChem","text":"<pre><code>QChem(\natoms,\ncharge=None,\nspin_multiplicity=None,\nmethod=None,\ncores=1,\nqchem_input_params=None,\n**fileiocalculator_kwargs\n)\n</code></pre> <p>             Bases: <code>FileIOCalculator</code></p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>The Atoms object to be used for the calculation.</p> </li> <li> cores             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation.</p> </li> <li> charge             (<code>None | int</code>, default:                 <code>None</code> )         \u2013          <p>The total charge of the molecular system. Effectively defaults to zero.</p> </li> <li> spin_multiplicity             (<code>None | int</code>, default:                 <code>None</code> )         \u2013          <p>The spin multiplicity of the molecular system. Effectively defaults to the lowest spin state given the molecular structure and charge.</p> </li> <li> qchem_input_params             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of Q-Chem input parameters to be passed to pymatgen.io.qchem.sets.ForceSet.</p> </li> <li> **fileiocalculator_kwargs         \u2013          <p>Additional arguments to be passed to ase.calculators.calculator.FileIOCalculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>The ASE Atoms object with attached Q-Chem calculator.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/calculators/qchem.py</code> <pre><code>def __init__(\nself,\natoms: Atoms,\ncharge: None | int = None,\nspin_multiplicity: None | int = None,\nmethod: str | None = None,\ncores: int = 1,\nqchem_input_params: dict | None = None,\n**fileiocalculator_kwargs,\n):\n# Assign variables to self\nself.atoms = atoms\nself.cores = cores\nself.charge = charge\nself.spin_multiplicity = spin_multiplicity\nself.qchem_input_params = qchem_input_params or {}\nself.fileiocalculator_kwargs = fileiocalculator_kwargs\n# Sanity checks\nif \"directory\" in self.fileiocalculator_kwargs:\nraise NotImplementedError(\"The directory kwarg is not supported.\")\nif \"overwrite_inputs\" not in self.qchem_input_params:\nself.qchem_input_params[\"overwrite_inputs\"] = {}\nif self.charge is None and self.spin_multiplicity is not None:\nraise ValueError(\"If setting spin_multiplicity, must also specify charge.\")\nif self.qchem_input_params.get(\"smd_solvent\") and self.qchem_input_params.get(\n\"pcm_dielectric\"\n):\nraise ValueError(\"PCM and SMD cannot be employed simultaneously.\")\nif \"rem\" not in self.qchem_input_params[\"overwrite_inputs\"]:\nself.qchem_input_params[\"overwrite_inputs\"][\"rem\"] = {}\nif (\nmethod\nand \"method\" not in self.qchem_input_params[\"overwrite_inputs\"][\"rem\"]\n):\nself.qchem_input_params[\"overwrite_inputs\"][\"rem\"][\"method\"] = method\n# We will save the parameters that have been passed to the Q-Chem calculator via FileIOCalculator's\n# self.default_parameters\nself.default_parameters = {\n\"cores\": self.cores,\n\"charge\": self.charge,\n\"spin_multiplicity\": self.spin_multiplicity,\n}\n# We also want to save the contents of self.qchem_input_params. However, the overwrite_inputs\n# key will have a corresponding value which is either an empty dictionary or a nested dict of\n# dicts, requiring a bit of careful unwrapping.\nfor key in self.qchem_input_params:\nif key == \"overwrite_inputs\":\nfor subkey in self.qchem_input_params[key]:\nfor subsubkey in self.qchem_input_params[key][subkey]:\nself.default_parameters[\nf\"overwrite_{subkey}_{subsubkey}\"\n] = self.qchem_input_params[key][subkey][subsubkey]\nelse:\nself.default_parameters[key] = self.qchem_input_params[key]\ncharge, spin_multiplicity = check_charge_and_spin(\natoms, self.charge, self.spin_multiplicity\n)\nself.charge = charge\nself.spin_multiplicity = spin_multiplicity\n# Get Q-Chem executable command\nself.command = self._manage_environment()\n# Instantiate previous orbital coefficients\nself.prev_orbital_coeffs = None\n# Instantiate the calculator\nFileIOCalculator.__init__(\nself,\nrestart=None,\nignore_bad_restart_file=FileIOCalculator._deprecated,\nlabel=None,\natoms=self.atoms,\n**self.fileiocalculator_kwargs,\n)\n</code></pre>"},{"location":"reference/quacc/calculators/vasp.html","title":"vasp","text":"<p>A wrapper around ASE's Vasp calculator that makes it better suited for high-throughput DFT.</p>"},{"location":"reference/quacc/calculators/vasp.html#quacc.calculators.vasp.Vasp","title":"Vasp","text":"<pre><code>Vasp(\ninput_atoms,\npreset=None,\nuse_custodian=None,\nincar_copilot=None,\ncopy_magmoms=None,\npreset_mag_default=None,\nmag_cutoff=None,\nverbose=None,\n**kwargs\n)\n</code></pre> <p>             Bases: <code>Vasp</code></p> <p>This is a wrapper around the ASE Vasp calculator that adjusts INCAR parameters on-the-fly, allows for ASE to run VASP via Custodian, and supports several automatic k-point generation schemes from Pymatgen.</p> <p>Parameters:</p> <ul> <li> input_atoms             (<code>Atoms</code>)         \u2013          <p>The input Atoms object to be used for the calculation.</p> </li> <li> preset             (<code>None | str</code>, default:                 <code>None</code> )         \u2013          <p>The name of a YAML file containing a list of INCAR parameters to use as a \"preset\" for the calculator. quacc will automatically look in the <code>VASP_PRESET_DIR</code> (default: quacc/presets/vasp) for the file, such that preset=\"BulkSet\" is supported, for instance. The .yaml extension is not necessary. Any user-suppplied calculator **kwargs will override any corresponding preset values.</p> </li> <li> use_custodian             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to use Custodian to run VASP. Default is True in settings.</p> </li> <li> incar_copilot             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>If True, the INCAR parameters will be adjusted if they go against the VASP manual. Default is True in settings.</p> </li> <li> copy_magmoms             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>If True, any pre-existing <code>atoms.get_magnetic_moments()</code> will be set in <code>atoms.set_initial_magnetic_moments()</code>. Set this to False if you want to use a preset's magnetic moments every time.</p> </li> <li> preset_mag_default             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Default magmom value for sites without one explicitly specified in the preset. Only used if a preset is specified with an elemental_mags_dict key-value pair. Default is 1.0 in settings.</p> </li> <li> mag_cutoff             (<code>None | float</code>, default:                 <code>None</code> )         \u2013          <p>Set all initial magmoms to 0 if all have a magnitude below this value. Default is 0.05 in settings.</p> </li> <li> verbose             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>If True, warnings will be raised when INCAR parameters are automatically changed. Default is True in settings.</p> </li> <li> **kwargs         \u2013          <p>Additional arguments to be passed to the VASP calculator, e.g. <code>xc='PBE'</code>, <code>encut=520</code>. Takes all valid ASE calculator arguments, in addition to those custom to quacc.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>The ASE Atoms object with attached VASP calculator.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/calculators/vasp.py</code> <pre><code>def __init__(\nself,\ninput_atoms: Atoms,\npreset: None | str = None,\nuse_custodian: bool | None = None,\nincar_copilot: bool | None = None,\ncopy_magmoms: bool | None = None,\npreset_mag_default: float | None = None,\nmag_cutoff: None | float = None,\nverbose: bool | None = None,\n**kwargs,\n):\n# Set defaults\nuse_custodian = (\nSETTINGS.VASP_USE_CUSTODIAN if use_custodian is None else use_custodian\n)\nincar_copilot = (\nSETTINGS.VASP_INCAR_COPILOT if incar_copilot is None else incar_copilot\n)\ncopy_magmoms = (\nSETTINGS.VASP_COPY_MAGMOMS if copy_magmoms is None else copy_magmoms\n)\npreset_mag_default = (\nSETTINGS.VASP_PRESET_MAG_DEFAULT\nif preset_mag_default is None\nelse preset_mag_default\n)\nmag_cutoff = SETTINGS.VASP_MAG_CUTOFF if mag_cutoff is None else mag_cutoff\nverbose = SETTINGS.VASP_VERBOSE if verbose is None else verbose\n# Assign variables to self\nself.input_atoms = input_atoms\nself.preset = preset\nself.use_custodian = use_custodian\nself.incar_copilot = incar_copilot\nself.copy_magmoms = copy_magmoms\nself.preset_mag_default = preset_mag_default\nself.mag_cutoff = mag_cutoff\nself.verbose = verbose\nself.kwargs = kwargs\n# Check constraints\nif (\nuse_custodian\nand input_atoms.constraints\nand not all(isinstance(c, FixAtoms) for c in input_atoms.constraints)\n):\nmsg = \"Atoms object has a constraint that is not compatible with Custodian. Set use_custodian = False.\"\nraise ValueError(msg)\n# Get VASP executable command, if necessary, and specify child environment\n# variables\ncommand = self._manage_environment()\n# Get user-defined preset parameters for the calculator\nif preset:\ncalc_preset = load_vasp_yaml_calc(\nos.path.join(SETTINGS.VASP_PRESET_DIR, preset)\n)[\"inputs\"]\nelse:\ncalc_preset = {}\n# Collect all the calculator parameters and prioritize the kwargs\n# in the case of duplicates.\nself.user_calc_params = calc_preset | kwargs\nnone_keys = [k for k, v in self.user_calc_params.items() if v is None]\nfor none_key in none_keys:\ndel self.user_calc_params[none_key]\n# Allow the user to use setups='mysetups.yaml' to load in a custom setups\n# from a YAML file\nif (\nisinstance(self.user_calc_params.get(\"setups\"), str)\nand self.user_calc_params[\"setups\"] not in ase_setups.setups_defaults\n):\nself.user_calc_params[\"setups\"] = load_vasp_yaml_calc(\nos.path.join(SETTINGS.VASP_PRESET_DIR, self.user_calc_params[\"setups\"])\n)[\"inputs\"][\"setups\"]\n# If the preset has auto_kpts but the user explicitly requests kpts, then\n# we should honor that.\nif kwargs.get(\"kpts\") and calc_preset.get(\"auto_kpts\"):\ndel self.user_calc_params[\"auto_kpts\"]\n# Handle special arguments in the user calc parameters that\n# ASE does not natively support\nif self.user_calc_params.get(\"elemental_magmoms\"):\nelemental_mags_dict = self.user_calc_params[\"elemental_magmoms\"]\nelse:\nelemental_mags_dict = None\nif self.user_calc_params.get(\"auto_kpts\"):\nauto_kpts = self.user_calc_params[\"auto_kpts\"]\nelse:\nauto_kpts = None\nif self.user_calc_params.get(\"auto_dipole\"):\nauto_dipole = self.user_calc_params[\"auto_dipole\"]\nelse:\nauto_dipole = None\nself.user_calc_params.pop(\"elemental_magmoms\", None)\nself.user_calc_params.pop(\"auto_kpts\", None)\nself.user_calc_params.pop(\"auto_dipole\", None)\n# Make automatic k-point mesh\nif auto_kpts:\nkpts, gamma, reciprocal = self._convert_auto_kpts(auto_kpts)\nself.user_calc_params[\"kpts\"] = kpts\nif reciprocal and self.user_calc_params.get(\"reciprocal\") is None:\nself.user_calc_params[\"reciprocal\"] = reciprocal\nif self.user_calc_params.get(\"gamma\") is None:\nself.user_calc_params[\"gamma\"] = gamma\n# Add dipole corrections if requested\nif auto_dipole:\ncom = input_atoms.get_center_of_mass(scaled=True)\nif \"dipol\" not in self.user_calc_params:\nself.user_calc_params[\"dipol\"] = com\nif \"idipol\" not in self.user_calc_params:\nself.user_calc_params[\"idipol\"] = 3\nif \"ldipol\" not in self.user_calc_params:\nself.user_calc_params[\"ldipol\"] = True\n# Set magnetic moments\nset_magmoms(\ninput_atoms,\nelemental_mags_dict=elemental_mags_dict,\ncopy_magmoms=copy_magmoms,\nelemental_mags_default=preset_mag_default,\nmag_cutoff=mag_cutoff,\n)\n# Handle INCAR swaps as needed\nif incar_copilot:\nself.user_calc_params = self._calc_swaps(auto_kpts=auto_kpts)\n# Remove unused INCAR flags\nself.user_calc_params = self._remove_unused_flags()\n# Instantiate the calculator!\nsuper().__init__(atoms=input_atoms, command=command, **self.user_calc_params)\n</code></pre>"},{"location":"reference/quacc/calculators/vasp.html#quacc.calculators.vasp.load_vasp_yaml_calc","title":"load_vasp_yaml_calc","text":"<pre><code>load_vasp_yaml_calc(yaml_path)\n</code></pre> <p>Loads a YAML file containing calculator settings. Used for VASP calculations and can read quacc-formatted YAMLs that are of the following format: <pre><code>inputs:\n  xc: pbe\n  algo: all\n  ...\n  setups:\n    Cu: Cu_pv\n  ...\n  elemental_magmoms:\n    Fe: 5\n    Cu: 1\n    ...\n</code></pre> where <code>inputs</code> is a dictionary of ASE-style input parameters, <code>setups</code> is a dictionary of ASE-style pseudopotentials, and and <code>elemental_magmoms</code> is a dictionary of element-wise initial magmoms.</p> <p>Parameters:</p> <ul> <li> yaml_path             (<code>str | Path</code>)         \u2013          <p>Path to the YAML file. This function will look in the <code>VASP_PRESET_DIR</code> (default: quacc/presets/vasp) for the file, thereby assuming that <code>yaml_path</code> is a relative path within that folder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>The calculator configuration (i.e. settings).</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/calculators/vasp.py</code> <pre><code>def load_vasp_yaml_calc(yaml_path: str | Path) -&gt; dict:\n\"\"\"\n    Loads a YAML file containing calculator settings.\n    Used for VASP calculations and can read quacc-formatted\n    YAMLs that are of the following format:\n    ```\n    inputs:\n      xc: pbe\n      algo: all\n      ...\n      setups:\n        Cu: Cu_pv\n      ...\n      elemental_magmoms:\n        Fe: 5\n        Cu: 1\n        ...\n    ```\n    where `inputs` is a dictionary of ASE-style input parameters,\n    `setups` is a dictionary of ASE-style pseudopotentials, and\n    and `elemental_magmoms` is a dictionary of element-wise initial magmoms.\n    Parameters\n    ----------\n    yaml_path\n        Path to the YAML file. This function will look in the\n        `VASP_PRESET_DIR` (default: quacc/presets/vasp) for the file,\n        thereby assuming that `yaml_path` is a relative path within that folder.\n    Returns\n    -------\n    dict\n        The calculator configuration (i.e. settings).\n    \"\"\"\nconfig = load_yaml_calc(yaml_path)\n# Allow for either \"Cu_pv\" and \"_pv\" style setups\nif \"inputs\" in config:\nconfig[\"inputs\"] = {\nk.lower(): v.lower() if isinstance(v, str) else v\nfor k, v in config[\"inputs\"].items()\n}\nfor k, v in config[\"inputs\"].get(\"setups\", {}).items():\nif k in v:\nconfig[\"inputs\"][\"setups\"][k] = v.split(k)[-1]\nreturn config\n</code></pre>"},{"location":"reference/quacc/custodian/qchem.html","title":"qchem","text":"<p>Custodian handlers for QChem</p>"},{"location":"reference/quacc/custodian/qchem.html#quacc.custodian.qchem.run_custodian","title":"run_custodian","text":"<pre><code>run_custodian(\nqchem_cores=1,\nqchem_cmd=None,\nqchem_local_scratch=None,\nqchem_use_error_handlers=None,\nqchem_custodian_max_errors=None,\n)\n</code></pre> <p>Function to run QChem Custodian</p> <p>Parameters:</p> <ul> <li> qchem_cores             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation.</p> </li> <li> qchem_cmd             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Q-Chem command. Defaults to \"qchem\" in settings.</p> </li> <li> qchem_local_scratch             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Compute-node local scratch directory in which Q-Chem should perform IO. Defaults to /tmp in settings.</p> </li> <li> qchem_use_error_handlers             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether or not to employ error handlers. Defaults to True in settings.</p> </li> <li> qchem_custodian_max_errors             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Maximum number of errors to allow before stopping the run. Defaults to 5 in settings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/custodian/qchem.py</code> <pre><code>@requires(\nob,\n\"Openbabel must be installed. Try conda install -c conda-forge openbabel\",\n)\ndef run_custodian(\nqchem_cores: int = 1,\nqchem_cmd: str | None = None,\nqchem_local_scratch: str | None = None,\nqchem_use_error_handlers: bool | None = None,\nqchem_custodian_max_errors: int | None = None,\n) -&gt; None:\n\"\"\"\n    Function to run QChem Custodian\n    Parameters\n    ----------\n    qchem_cores\n        Number of cores to use for the Q-Chem calculation.\n    qchem_cmd\n        Q-Chem command. Defaults to \"qchem\" in settings.\n    qchem_local_scratch\n        Compute-node local scratch directory in which Q-Chem should perform IO. Defaults to /tmp in settings.\n    qchem_use_error_handlers\n        Whether or not to employ error handlers. Defaults to True in settings.\n    qchem_custodian_max_errors\n        Maximum number of errors to allow before stopping the run. Defaults to 5 in settings.\n    Returns\n    -------\n    None\n    \"\"\"\n# Adapted from atomate.qchem.firetasks.run_calc\nfrom custodian import Custodian\nfrom custodian.qchem.handlers import QChemErrorHandler\nfrom custodian.qchem.jobs import QCJob\n# Set defaults\nqchem_cmd = SETTINGS.QCHEM_CMD if qchem_cmd is None else qchem_cmd\nqchem_local_scratch = (\nSETTINGS.QCHEM_LOCAL_SCRATCH\nif qchem_local_scratch is None\nelse qchem_local_scratch\n)\nqchem_use_error_handlers = (\nSETTINGS.QCHEM_USE_ERROR_HANDLERS\nif qchem_use_error_handlers is None\nelse qchem_use_error_handlers\n)\nqchem_custodian_max_errors = (\nSETTINGS.QCHEM_CUSTODIAN_MAX_ERRORS\nif qchem_custodian_max_errors is None\nelse qchem_custodian_max_errors\n)\n# Error handlers for Q-Chem\nif qchem_use_error_handlers:\nhandlers = [QChemErrorHandler()]\nelse:\nhandlers = []\n# Run Q-Chem\njobs = [\nQCJob(\nqchem_command=qchem_cmd,\nmax_cores=qchem_cores,\ncalc_loc=qchem_local_scratch,\n)\n]\nc = Custodian(\nhandlers,\njobs,\nmax_errors=qchem_custodian_max_errors,\n)\nc.run()\n</code></pre>"},{"location":"reference/quacc/custodian/vasp.html","title":"vasp","text":"<p>Custodian handlers for VASP</p>"},{"location":"reference/quacc/custodian/vasp.html#quacc.custodian.vasp.run_custodian","title":"run_custodian","text":"<pre><code>run_custodian(\nvasp_parallel_cmd=None,\nvasp_cmd=None,\nvasp_gamma_cmd=None,\nvasp_custodian_max_errors=None,\nvasp_custodian_wall_time=None,\nvtst_fixes=None,\nvasp_custodian_handlers=None,\nvasp_custodian_validators=None,\nscratch_dir=None,\nvasp_job_kwargs=None,\ncustodian_kwargs=None,\n)\n</code></pre> <p>Function to run VASP Custodian</p> <p>Parameters:</p> <ul> <li> vasp_parallel_cmd             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>VASP parallel command, e.g. \"srun -N 2 --ntasks-per-node=24\". Defaults to the $VASP_PARALLEL_CMD environment variable in settings.</p> </li> <li> vasp_cmd             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>VASP command. Defaults to \"vasp_std\" in settings.</p> </li> <li> vasp_gamma_cmd             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>VASP gamma command. Defaults to vasp_gam in settings.</p> </li> <li> vasp_custodian_max_errors             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Maximum number of errors to allow before stopping the run. Defaults to 5 in settings.</p> </li> <li> vasp_custodian_wall_time             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Maximum wall time to allow before creating a STOPCAR. Defaults to infinity in settings.</p> </li> <li> vtst_fixes             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to apply VTST input swaps. Defaults to False in settings.</p> </li> <li> vasp_custodian_handlers             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>List of handlers to use in Custodian. See settings for list.</p> </li> <li> vasp_custodian_validators             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>List of validators to use in Custodian. See settings for list.</p> </li> <li> scratch_dir             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Scratch directory to use. Defaults to None.</p> </li> <li> vasp_job_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to pass to the Custodian VaspJob. Defaults to None.</p> </li> <li> custodian_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Any remaining keyword arguments to pass to Custodian. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/custodian/vasp.py</code> <pre><code>def run_custodian(\nvasp_parallel_cmd: str | None = None,\nvasp_cmd: str | None = None,\nvasp_gamma_cmd: str | None = None,\nvasp_custodian_max_errors: int | None = None,\nvasp_custodian_wall_time: float | None = None,\nvtst_fixes: bool | None = None,\nvasp_custodian_handlers: list[str] | None = None,\nvasp_custodian_validators: list[str] | None = None,\nscratch_dir: str | None = None,\nvasp_job_kwargs: dict | None = None,\ncustodian_kwargs: dict | None = None,\n) -&gt; None:\n\"\"\"\n    Function to run VASP Custodian\n    Parameters\n    ----------\n    vasp_parallel_cmd\n        VASP parallel command, e.g. \"srun -N 2 --ntasks-per-node=24\". Defaults to the $VASP_PARALLEL_CMD\n        environment variable in settings.\n    vasp_cmd\n        VASP command. Defaults to \"vasp_std\" in settings.\n    vasp_gamma_cmd\n        VASP gamma command. Defaults to vasp_gam in settings.\n    vasp_custodian_max_errors\n        Maximum number of errors to allow before stopping the run. Defaults to 5 in settings.\n    vasp_custodian_wall_time\n        Maximum wall time to allow before creating a STOPCAR. Defaults to infinity in settings.\n    vtst_fixes\n        Whether to apply VTST input swaps. Defaults to False in settings.\n    vasp_custodian_handlers\n        List of handlers to use in Custodian. See settings for list.\n    vasp_custodian_validators\n        List of validators to use in Custodian. See settings for list.\n    scratch_dir\n        Scratch directory to use. Defaults to None.\n    vasp_job_kwargs\n        Keyword arguments to pass to the Custodian VaspJob. Defaults to None.\n    custodian_kwargs\n        Any remaining keyword arguments to pass to Custodian. Defaults to None.\n    Returns\n    -------\n    None\n    \"\"\"\n# Adapted from atomate2.vasp.run.run_vasp\n# Set defaults\nvasp_parallel_cmd = os.path.expandvars(\nSETTINGS.VASP_PARALLEL_CMD if vasp_parallel_cmd is None else vasp_parallel_cmd\n)\nvasp_cmd = SETTINGS.VASP_CMD if vasp_cmd is None else vasp_cmd\nvasp_gamma_cmd = (\nSETTINGS.VASP_GAMMA_CMD if vasp_gamma_cmd is None else vasp_gamma_cmd\n)\nvasp_custodian_max_errors = (\nSETTINGS.VASP_CUSTODIAN_MAX_ERRORS\nif vasp_custodian_max_errors is None\nelse vasp_custodian_max_errors\n)\nvasp_custodian_wall_time = (\nSETTINGS.VASP_CUSTODIAN_WALL_TIME\nif vasp_custodian_wall_time is None\nelse vasp_custodian_wall_time\n)\nvtst_fixes = SETTINGS.VASP_CUSTODIAN_VTST if vtst_fixes is None else vtst_fixes\nvasp_custodian_handlers = (\nSETTINGS.VASP_CUSTODIAN_HANDLERS\nif vasp_custodian_handlers is None\nelse vasp_custodian_handlers\n)\nvasp_custodian_validators = (\nSETTINGS.VASP_CUSTODIAN_VALIDATORS\nif vasp_custodian_validators is None\nelse vasp_custodian_validators\n)\n# Handlers for VASP\nhandlers = []\nhandlers_dict = {\n\"VaspErrorHandler\": VaspErrorHandler(vtst_fixes=vtst_fixes),\n\"FrozenJobErrorHandler\": FrozenJobErrorHandler(),\n\"IncorrectSmearingHandler\": IncorrectSmearingHandler(),\n\"LargeSigmaHandler\": LargeSigmaHandler(),\n\"MeshSymmetryErrorHandler\": MeshSymmetryErrorHandler(),\n\"NonConvergingErrorHandler\": NonConvergingErrorHandler(),\n\"PositiveEnergyErrorHandler\": PositiveEnergyErrorHandler(),\n\"PotimErrorHandler\": PotimErrorHandler(),\n\"StdErrHandler\": StdErrHandler(),\n\"UnconvergedErrorHandler\": UnconvergedErrorHandler(),\n\"WalltimeHandler\": WalltimeHandler(),\n\"ScanMetalHandler\": ScanMetalHandler(),\n}\nvalidators_dict = {\n\"VaspFilesValidator\": VaspFilesValidator(),\n\"VasprunXMLValidator\": VasprunXMLValidator(),\n}\nhandlers = []\nfor handler_flag in vasp_custodian_handlers:\nif handler_flag not in handlers_dict:\nmsg = f\"Unknown VASP error handler: {handler_flag}\"\nraise ValueError(msg)\nhandlers.append(handlers_dict[handler_flag])\nvalidators = []\nfor validator_flag in vasp_custodian_validators:\nif validator_flag not in validators_dict:\nmsg = f\"Unknown VASP validator: {validator_flag}\"\nraise ValueError(msg)\nvalidators.append(validators_dict[validator_flag])\n# Populate settings\nvasp_cmd = f\"{vasp_parallel_cmd} {vasp_cmd}\"\nvasp_gamma_cmd = f\"{vasp_parallel_cmd} {vasp_gamma_cmd}\"\n# Run VASP\nvasp_job_kwargs = {} if vasp_job_kwargs is None else vasp_job_kwargs\ncustodian_kwargs = {} if custodian_kwargs is None else custodian_kwargs\nsplit_vasp_cmd = shlex.split(vasp_cmd)\nsplit_vasp_gamma_cmd = shlex.split(vasp_gamma_cmd)\nvasp_job_kwargs[\"gamma_vasp_cmd\"] = split_vasp_gamma_cmd\n# Run with Custodian\njobs = [VaspJob(split_vasp_cmd, **vasp_job_kwargs)]\nif vasp_custodian_wall_time:\nhandlers = [\n*list(handlers),\nWalltimeHandler(wall_time=vasp_custodian_wall_time),\n]\nc = Custodian(\nhandlers,\njobs,\nvalidators=validators,\nmax_errors=vasp_custodian_max_errors,\nscratch_dir=scratch_dir,\n**custodian_kwargs,\n)\nc.run()\n</code></pre>"},{"location":"reference/quacc/recipes/dftb/core.html","title":"core","text":"<p>Core recipes for DFTB+</p>"},{"location":"reference/quacc/recipes/dftb/core.html#quacc.recipes.dftb.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\natoms,\nmethod=\"GFN2-xTB\",\nkpts=None,\nrelax_cell=False,\ncalc_swaps=None,\ncopy_files=None,\n)\n</code></pre> <p>Carry out a structure relaxation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> method             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'DFTB']</code>, default:                 <code>'GFN2-xTB'</code> )         \u2013          <p>Method to use.</p> </li> <li> kpts             (<code>tuple | list[tuple] | dict | None</code>, default:                 <code>None</code> )         \u2013          <p>k-point grid to use. Defaults to None for molecules and (1, 1, 1) for solids.</p> </li> <li> relax_cell             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to relax the unit cell shape/volume in addition to the positions.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/dftb/core.py</code> <pre><code>@job\ndef relax_job(\natoms: Atoms | dict,\nmethod: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"DFTB\"] = \"GFN2-xTB\",\nkpts: tuple | list[tuple] | dict | None = None,\nrelax_cell: bool = False,\ncalc_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Carry out a structure relaxation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    method\n        Method to use.\n    kpts\n        k-point grid to use. Defaults to None for molecules and\n        (1, 1, 1) for solids.\n    relax_cell\n        Whether to relax the unit cell shape/volume in addition to\n        the positions.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.ase.summarize_run`\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"Hamiltonian_\": \"xTB\" if \"xtb\" in method.lower() else \"DFTB\",\n\"Hamiltonian_Method\": method if \"xtb\" in method.lower() else None,\n\"kpts\": kpts or ((1, 1, 1) if atoms.pbc.any() else None),\n\"Driver_\": \"GeometryOptimization\",\n\"Driver_LatticeOpt\": \"Yes\" if relax_cell else \"No\",\n\"Driver_AppendGeometries\": \"Yes\",\n\"Driver_MaxSteps\": 2000,\n}\nflags = merge_dicts(defaults, calc_swaps)\natoms.calc = Dftb(**flags)\nfinal_atoms = run_calc(atoms, geom_file=GEOM_FILE, copy_files=copy_files)\nif not check_logfile(LOG_FILE, \"Geometry converged\"):\nmsg = \"Geometry did not converge\"\nraise ValueError(msg)\nreturn summarize_run(\nfinal_atoms,\ninput_atoms=atoms,\nadditional_fields={\"name\": \"DFTB+ Relax\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/dftb/core.html#quacc.recipes.dftb.core.static_job","title":"static_job","text":"<pre><code>static_job(\natoms,\nmethod=\"GFN2-xTB\",\nkpts=None,\ncalc_swaps=None,\ncopy_files=None,\n)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> method             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'DFTB']</code>, default:                 <code>'GFN2-xTB'</code> )         \u2013          <p>Method to use.</p> </li> <li> kpts             (<code>tuple | list[tuple] | dict | None</code>, default:                 <code>None</code> )         \u2013          <p>k-point grid to use. Defaults to None for molecules and (1, 1, 1) for solids.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/dftb/core.py</code> <pre><code>@job\ndef static_job(\natoms: Atoms | dict,\nmethod: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"DFTB\"] = \"GFN2-xTB\",\nkpts: tuple | list[tuple] | dict | None = None,\ncalc_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    method\n        Method to use.\n    kpts\n        k-point grid to use. Defaults to None for molecules and\n        (1, 1, 1) for solids.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.ase.summarize_run`\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"Hamiltonian_\": \"xTB\" if \"xtb\" in method.lower() else \"DFTB\",\n\"Hamiltonian_Method\": method if \"xtb\" in method.lower() else None,\n\"kpts\": kpts or ((1, 1, 1) if atoms.pbc.any() else None),\n}\nflags = merge_dicts(defaults, calc_swaps)\natoms.calc = Dftb(**flags)\nfinal_atoms = run_calc(atoms, geom_file=GEOM_FILE, copy_files=copy_files)\nif check_logfile(LOG_FILE, \"SCC is NOT converged\"):\nmsg = \"SCC is not converged\"\nraise ValueError(msg)\nreturn summarize_run(\nfinal_atoms,\ninput_atoms=atoms,\nadditional_fields={\"name\": \"DFTB+ Static\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/emt/core.html","title":"core","text":"<p>Core recipes for EMT</p> <p>NOTE: This set of minimal recipes is mainly for demonstration purposes.</p>"},{"location":"reference/quacc/recipes/emt/core.html#quacc.recipes.emt.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\natoms,\nrelax_cell=False,\ncalc_swaps=None,\nopt_swaps=None,\ncopy_files=None,\n)\n</code></pre> <p>Carry out a geometry optimization.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> relax_cell             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to relax the cell</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the EMT calculator</p> </li> <li> opt_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of swaps for <code>run_ase_opt</code></p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/emt/core.py</code> <pre><code>@job\ndef relax_job(\natoms: Atoms | dict,\nrelax_cell: bool = False,\ncalc_swaps: dict | None = None,\nopt_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; OptSchema:\n\"\"\"\n    Carry out a geometry optimization.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    relax_cell\n        Whether to relax the cell\n    calc_swaps\n        Dictionary of custom kwargs for the EMT calculator\n    opt_swaps\n        Dictionary of swaps for `run_ase_opt`\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from quacc.schemas.ase.summarize_opt_run\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\nopt_swaps = opt_swaps or {}\nopt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\nopt_flags = merge_dicts(opt_defaults, opt_swaps)\natoms.calc = EMT(**calc_swaps)\ndyn = run_ase_opt(atoms, relax_cell=relax_cell, copy_files=copy_files, **opt_flags)\nreturn summarize_opt_run(dyn, additional_fields={\"name\": \"EMT Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/emt/core.html#quacc.recipes.emt.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, calc_swaps=None, copy_files=None)\n</code></pre> <p>Carry out a static calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the EMT calculator</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/emt/core.py</code> <pre><code>@job\ndef static_job(\natoms: Atoms | dict,\ncalc_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Carry out a static calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    calc_swaps\n        Dictionary of custom kwargs for the EMT calculator\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.ase.summarize_run`\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\natoms.calc = EMT(**calc_swaps)\nfinal_atoms = run_calc(atoms, copy_files=copy_files)\nreturn summarize_run(\nfinal_atoms,\ninput_atoms=atoms,\nadditional_fields={\"name\": \"EMT Static\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/emt/defects.html","title":"defects","text":"<p>Defect recipes for EMT</p>"},{"location":"reference/quacc/recipes/emt/defects.html#quacc.recipes.emt.defects.bulk_to_defects_flow","title":"bulk_to_defects_flow","text":"<pre><code>bulk_to_defects_flow(\natoms,\ndefectgen=VacancyGenerator,\ncharge_state=0,\nmake_defects_kwargs=None,\ndefect_relax=_relax_job,\ndefect_static=_static_job,\ndefect_relax_kwargs=None,\ndefect_static_kwargs=None,\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Defect generation</p> </li> <li> <p>Defect relaxations</p> </li> <li> <p>Defect statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object for the structure.</p> </li> <li> defectgen             (<code>AntiSiteGenerator | ChargeInterstitialGenerator | InterstitialGenerator | SubstitutionGenerator | VacancyGenerator | VoronoiInterstitialGenerator</code>, default:                 <code>VacancyGenerator</code> )         \u2013          <p>Defect generator</p> </li> <li> charge_state             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Charge state of the defect</p> </li> <li> make_defects_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to pass to the make_defects_from_bulk</p> </li> <li> defect_relax             (<code>Job | None</code>, default:                 <code>relax_job</code> )         \u2013          <p>Default Job to use for the relaxation of the defect structures.</p> </li> <li> defect_static             (<code>Job | None</code>, default:                 <code>static_job</code> )         \u2013          <p>Default Job to use for the static calculation of the defect structures.</p> </li> <li> defect_relax_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> <li> defect_static_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the static calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>         \u2013          <p>List of dictionary of results from quacc.schemas.ase.summarize_run or quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/emt/defects.py</code> <pre><code>@flow\ndef bulk_to_defects_flow(\natoms: Atoms | dict,\ndefectgen: (\nAntiSiteGenerator\n| ChargeInterstitialGenerator\n| InterstitialGenerator\n| SubstitutionGenerator\n| VacancyGenerator\n| VoronoiInterstitialGenerator\n) = VacancyGenerator,\ncharge_state: int = 0,\nmake_defects_kwargs: dict | None = None,\ndefect_relax: Job | None = _relax_job,\ndefect_static: Job | None = _static_job,\ndefect_relax_kwargs: dict | None = None,\ndefect_static_kwargs: dict | None = None,\n) -&gt; list[RunSchema | OptSchema]:\n\"\"\"\n    Workflow consisting of:\n    1. Defect generation\n    2. Defect relaxations\n    3. Defect statics (optional)\n    Parameters\n    ----------\n    atoms\n        Atoms object for the structure.\n    defectgen\n        Defect generator\n    charge_state\n        Charge state of the defect\n    make_defects_kwargs\n        Keyword arguments to pass to the make_defects_from_bulk\n    defect_relax\n        Default Job to use for the relaxation of the defect structures.\n    defect_static\n        Default Job to use for the static calculation of the defect structures.\n    defect_relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    defect_static_kwargs\n        Additional keyword arguments to pass to the static calculation.\n    Returns\n    -------\n    list[dict]\n        List of dictionary of results from quacc.schemas.ase.summarize_run or quacc.schemas.ase.summarize_opt_run\n    \"\"\"\ndefect_relax_kwargs = defect_relax_kwargs or {}\ndefect_static_kwargs = defect_static_kwargs or {}\nmake_defects_kwargs = make_defects_kwargs or {}\nif \"relax_cell\" not in defect_relax_kwargs:\ndefect_relax_kwargs[\"relax_cell\"] = False\n@job\ndef _make_defects(atoms):\natoms = fetch_atoms(atoms)\nreturn make_defects_from_bulk(\natoms, defectgen=defectgen, charge_state=charge_state, **make_defects_kwargs\n)\n@subflow\ndef _relax_distributed(defects):\nreturn [defect_relax(defect, **defect_relax_kwargs) for defect in defects]\n@subflow\ndef _relax_and_static_distributed(defects):\nreturn [\ndefect_static(\ndefect_relax(defect, **defect_relax_kwargs),\n**defect_static_kwargs,\n)\nfor defect in defects\n]\ndefects = _make_defects(atoms)\nif defect_static is None:\nreturn _relax_distributed(defects)\nreturn _relax_and_static_distributed(defects)\n</code></pre>"},{"location":"reference/quacc/recipes/emt/slabs.html","title":"slabs","text":"<p>Slab recipes for EMT</p>"},{"location":"reference/quacc/recipes/emt/slabs.html#quacc.recipes.emt.slabs.bulk_to_slabs_flow","title":"bulk_to_slabs_flow","text":"<pre><code>bulk_to_slabs_flow(\natoms,\nmake_slabs_kwargs=None,\nslab_relax=_relax_job,\nslab_static=_static_job,\nslab_relax_kwargs=None,\nslab_static_kwargs=None,\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab generation</p> </li> <li> <p>Slab relaxations</p> </li> <li> <p>Slab statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> make_slabs_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to make_max_slabs_from_bulk()</p> </li> <li> slab_relax             (<code>callable</code>, default:                 <code>relax_job</code> )         \u2013          <p>Default Electron to use for the relaxation of the slab structures.</p> </li> <li> slab_static             (<code>callable | None</code>, default:                 <code>static_job</code> )         \u2013          <p>Default Electron to use for the static calculation of the slab structures.</p> </li> <li> slab_relax_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> <li> slab_static_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the static calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[RunSchema | OptSchema]</code>         \u2013          <p>List of dictionary of results from quacc.schemas.ase.summarize_run or quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/emt/slabs.py</code> <pre><code>@flow\ndef bulk_to_slabs_flow(\natoms: Atoms | dict,\nmake_slabs_kwargs: dict | None = None,\nslab_relax: callable = _relax_job,\nslab_static: callable | None = _static_job,\nslab_relax_kwargs: dict | None = None,\nslab_static_kwargs: dict | None = None,\n) -&gt; list[RunSchema | OptSchema]:\n\"\"\"\n    Workflow consisting of:\n    1. Slab generation\n    2. Slab relaxations\n    3. Slab statics (optional)\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    make_slabs_kwargs\n        Additional keyword arguments to pass to make_max_slabs_from_bulk()\n    slab_relax\n        Default Electron to use for the relaxation of the slab structures.\n    slab_static\n        Default Electron to use for the static calculation of the slab structures.\n    slab_relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    slab_static_kwargs\n        Additional keyword arguments to pass to the static calculation.\n    Returns\n    -------\n    list[RunSchema | OptSchema]\n        List of dictionary of results from quacc.schemas.ase.summarize_run or quacc.schemas.ase.summarize_opt_run\n    \"\"\"\nslab_relax_kwargs = slab_relax_kwargs or {}\nslab_static_kwargs = slab_static_kwargs or {}\nmake_slabs_kwargs = make_slabs_kwargs or {}\nif \"relax_cell\" not in slab_relax_kwargs:\nslab_relax_kwargs[\"relax_cell\"] = False\n@job\ndef _make_slabs(atoms):\natoms = fetch_atoms(atoms)\nreturn make_max_slabs_from_bulk(atoms, **make_slabs_kwargs)\n@subflow\ndef _relax_distributed(slabs):\nreturn [slab_relax(slab, **slab_relax_kwargs) for slab in slabs]\n@subflow\ndef _relax_and_static_distributed(slabs):\nreturn [\nslab_static(\nslab_relax(slab, **slab_relax_kwargs),\n**slab_static_kwargs,\n)\nfor slab in slabs\n]\nslabs = _make_slabs(atoms)\nif slab_static is None:\nreturn _relax_distributed(slabs)\nreturn _relax_and_static_distributed(slabs)\n</code></pre>"},{"location":"reference/quacc/recipes/emt/_jobflow/slabs.html","title":"slabs","text":"<p>Slab recipes for EMT based on Jobflow</p>"},{"location":"reference/quacc/recipes/emt/_jobflow/slabs.html#quacc.recipes.emt._jobflow.slabs.bulk_to_slabs_flow","title":"bulk_to_slabs_flow","text":"<pre><code>bulk_to_slabs_flow(\natoms,\nmake_slabs_kwargs=None,\nslab_relax=_relax_job,\nslab_static=_static_job,\nslab_relax_kwargs=None,\nslab_static_kwargs=None,\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab generation</p> </li> <li> <p>Slab relaxations</p> </li> <li> <p>Slab statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> make_slabs_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to <code>make_max_slabs_from_bulk()</code></p> </li> <li> slab_relax             (<code>Job</code>, default:                 <code>relax_job</code> )         \u2013          <p>Maker to use for the relaxation of the slab.</p> </li> <li> slab_static             (<code>Job | None</code>, default:                 <code>static_job</code> )         \u2013          <p>Maker to use for the static calculation of the slab.</p> </li> <li> slab_relax_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> <li> slab_static_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the static calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Response</code>         \u2013          <p>A Response containing Flow of relaxation and static jobs for the generated slabs.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/emt/_jobflow/slabs.py</code> <pre><code>@job\ndef bulk_to_slabs_flow(\natoms: Atoms | dict,\nmake_slabs_kwargs: dict | None = None,\nslab_relax: Job = _relax_job,\nslab_static: Job | None = _static_job,\nslab_relax_kwargs: dict | None = None,\nslab_static_kwargs: dict | None = None,\n) -&gt; Response:\n\"\"\"\n    Workflow consisting of:\n    1. Slab generation\n    2. Slab relaxations\n    3. Slab statics (optional)\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    make_slabs_kwargs\n        Additional keyword arguments to pass to `make_max_slabs_from_bulk()`\n    slab_relax\n        Maker to use for the relaxation of the slab.\n    slab_static\n        Maker to use for the static calculation of the slab.\n    slab_relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    slab_static_kwargs\n        Additional keyword arguments to pass to the static calculation.\n    Returns\n    -------\n    Response\n        A Response containing Flow of relaxation and static jobs for the generated slabs.\n    \"\"\"\natoms = fetch_atoms(atoms)\nslab_relax_kwargs = slab_relax_kwargs or {}\nslab_static_kwargs = slab_static_kwargs or {}\nmake_slabs_kwargs = make_slabs_kwargs or {}\nif \"relax_cell\" not in slab_relax_kwargs:\nslab_relax_kwargs[\"relax_cell\"] = False\n# Generate all the slab\nslabs = make_max_slabs_from_bulk(atoms, **make_slabs_kwargs)\n# Generate the jobs for each slab\njobs = []\noutputs = []\nfor slab in slabs:\nif slab_static is None:\njob1 = slab_relax(slab, **slab_relax_kwargs)\njobs += [job1]\noutputs.append(job1.output)\nelse:\njob1 = slab_relax(slab, **slab_relax_kwargs)\njob2 = slab_static(job1.output, **slab_static_kwargs)\njobs += [job1, job2]\noutputs.append(job2.output)\nreturn Response(\noutput={\"input_bulk\": atoms, \"generated_slabs\": slabs},\nreplace=Flow(jobs, output=outputs),\n)\n</code></pre>"},{"location":"reference/quacc/recipes/gaussian/core.html","title":"core","text":"<p>Core recipes for Gaussian</p>"},{"location":"reference/quacc/recipes/gaussian/core.html#quacc.recipes.gaussian.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\natoms,\ncharge=None,\nmultiplicity=None,\nxc=\"wb97x-d\",\nbasis=\"def2-tzvp\",\nfreq=False,\ncalc_swaps=None,\ncopy_files=None,\n)\n</code></pre> <p>Carry out a geometry optimization.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> charge             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge of the system. If None, this is determined from the sum of <code>atoms.get_initial_charges()</code>.</p> </li> <li> multiplicity             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Multiplicity of the system. If None, this is determined from 1+ the sum of <code>atoms.get_initial_magnetic_moments()</code>.</p> </li> <li> xc             (<code>str</code>, default:                 <code>'wb97x-d'</code> )         \u2013          <p>Exchange-correlation functional</p> </li> <li> basis             (<code>str</code>, default:                 <code>'def2-tzvp'</code> )         \u2013          <p>Basis set</p> </li> <li> freq             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If a frequency calculation should be carried out.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.cclib.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/gaussian/core.py</code> <pre><code>@job\ndef relax_job(\natoms: Atoms,\ncharge: int | None = None,\nmultiplicity: int | None = None,\nxc: str = \"wb97x-d\",\nbasis: str = \"def2-tzvp\",\nfreq: bool = False,\ncalc_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; cclibSchema:\n\"\"\"\n    Carry out a geometry optimization.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    charge\n        Charge of the system. If None, this is determined from the sum of\n        `atoms.get_initial_charges()`.\n    multiplicity\n        Multiplicity of the system. If None, this is determined from 1+ the sum\n        of `atoms.get_initial_magnetic_moments()`.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    freq\n        If a frequency calculation should be carried out.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.cclib.summarize_run`\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"mem\": \"16GB\",\n\"chk\": \"Gaussian.chk\",\n\"nprocshared\": multiprocessing.cpu_count(),\n\"xc\": xc,\n\"basis\": basis,\n\"charge\": get_charge(atoms) if charge is None else charge,\n\"mult\": get_multiplicity(atoms) if multiplicity is None else multiplicity,\n\"opt\": \"\",\n\"pop\": \"CM5\",\n\"scf\": [\"maxcycle=250\", \"xqc\"],\n\"integral\": \"ultrafine\",\n\"nosymmetry\": \"\",\n\"freq\": \"\" if freq else None,\n\"ioplist\": [\"2/9=2000\"],  # ASE issue #660\n}\nflags = merge_dicts(defaults, calc_swaps)\natoms.calc = Gaussian(**flags)\natoms = run_calc(atoms, geom_file=GEOM_FILE, copy_files=copy_files)\nreturn summarize_run(\natoms,\nLOG_FILE,\nadditional_fields={\"name\": \"Gaussian Relax\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/gaussian/core.html#quacc.recipes.gaussian.core.static_job","title":"static_job","text":"<pre><code>static_job(\natoms,\ncharge=None,\nmultiplicity=None,\nxc=\"wb97x-d\",\nbasis=\"def2-tzvp\",\ncalc_swaps=None,\ncopy_files=None,\n)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> charge             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge of the system. If None, this is determined from the sum of <code>atoms.get_initial_charges().</code></p> </li> <li> multiplicity             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Multiplicity of the system. If None, this is determined from 1+ the sum of <code>atoms.get_initial_magnetic_moments()</code>.</p> </li> <li> xc             (<code>str</code>, default:                 <code>'wb97x-d'</code> )         \u2013          <p>Exchange-correlation functional</p> </li> <li> basis             (<code>str</code>, default:                 <code>'def2-tzvp'</code> )         \u2013          <p>Basis set</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.cclib.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/gaussian/core.py</code> <pre><code>@job\ndef static_job(\natoms: Atoms | dict,\ncharge: int | None = None,\nmultiplicity: int | None = None,\nxc: str = \"wb97x-d\",\nbasis: str = \"def2-tzvp\",\ncalc_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; cclibSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    charge\n        Charge of the system. If None, this is determined from the sum of\n        `atoms.get_initial_charges().`\n    multiplicity\n        Multiplicity of the system. If None, this is determined from 1+ the sum\n        of `atoms.get_initial_magnetic_moments()`.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.cclib.summarize_run`\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"mem\": \"16GB\",\n\"chk\": \"Gaussian.chk\",\n\"nprocshared\": multiprocessing.cpu_count(),\n\"xc\": xc,\n\"basis\": basis,\n\"charge\": get_charge(atoms) if charge is None else charge,\n\"mult\": get_multiplicity(atoms) if multiplicity is None else multiplicity,\n\"sp\": \"\",\n\"scf\": [\"maxcycle=250\", \"xqc\"],\n\"integral\": \"ultrafine\",\n\"nosymmetry\": \"\",\n\"pop\": \"CM5\",\n\"gfinput\": \"\",\n\"ioplist\": [\"6/7=3\", \"2/9=2000\"],  # see ASE issue #660\n}\nflags = merge_dicts(defaults, calc_swaps)\natoms.calc = Gaussian(**flags)\natoms = run_calc(atoms, geom_file=GEOM_FILE, copy_files=copy_files)\nreturn summarize_run(\natoms,\nLOG_FILE,\nadditional_fields={\"name\": \"Gaussian Static\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/gulp/core.html","title":"core","text":"<p>Core recipes for GULP</p>"},{"location":"reference/quacc/recipes/gulp/core.html#quacc.recipes.gulp.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\natoms,\nuse_gfnff=True,\nlibrary=None,\nrelax_cell=False,\nkeyword_swaps=None,\noption_swaps=None,\ncopy_files=None,\n)\n</code></pre> <p>Carry out a single-point calculation. Note: 'Conditions' are not yet natively supported.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> use_gfnff             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>True if (p)GFN-FF should be used; False if not.</p> </li> <li> library             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Filename of the potential library file, if required.</p> </li> <li> relax_cell             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>True if the volume should be relaxed; False if not.</p> </li> <li> keyword_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom keyword swap kwargs for the calculator.</p> </li> <li> option_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom option swap kwargs for the calculator.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/gulp/core.py</code> <pre><code>@job\ndef relax_job(\natoms: Atoms | dict,\nuse_gfnff: bool = True,\nlibrary: str | None = None,\nrelax_cell: bool = False,\nkeyword_swaps: dict | None = None,\noption_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Note: 'Conditions' are not yet natively supported.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    use_gfnff\n        True if (p)GFN-FF should be used; False if not.\n    library\n        Filename of the potential library file, if required.\n    relax_cell\n        True if the volume should be relaxed; False if not.\n    keyword_swaps\n        Dictionary of custom keyword swap kwargs for the calculator.\n    option_swaps\n        Dictionary of custom option swap kwargs for the calculator.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    dict\n        Dictionary of results from `quacc.schemas.ase.summarize_run`\n    \"\"\"\natoms = fetch_atoms(atoms)\nkeyword_swaps = keyword_swaps or {}\noption_swaps = option_swaps or {}\nif relax_cell and not atoms.pbc.any():\nwarnings.warn(\n\"Volume relaxation requested but no PBCs found. Ignoring.\", UserWarning\n)\nrelax_cell = False\ndefault_keywords = {\n\"opti\": True,\n\"gfnff\": True if use_gfnff else None,\n\"gwolf\": True if use_gfnff and atoms.pbc.any() else None,\n\"conp\": True if relax_cell and atoms.pbc.any() else None,\n\"conv\": None if relax_cell and atoms.pbc.any() else True,\n}\ndefault_options = {\n\"dump every gulp.res\": True,\nf\"output cif {GEOM_FILE_PBC}\": True if atoms.pbc.any() else None,\nf\"output xyz {GEOM_FILE_NOPBC}\": None if atoms.pbc.any() else True,\n}\nkeywords = merge_dicts(default_keywords, keyword_swaps)\noptions = merge_dicts(default_options, option_swaps)\ngulp_keywords = \" \".join(list(keywords.keys()))\ngulp_options = list(options.keys())\natoms.calc = GULP(keywords=gulp_keywords, options=gulp_options, library=library)\nfinal_atoms = run_calc(\natoms,\ngeom_file=GEOM_FILE_PBC if atoms.pbc.any() else GEOM_FILE_NOPBC,\ncopy_files=copy_files,\n)\nif not final_atoms.calc.get_opt_state():\nmsg = \"Optimization did not converge!\"\nraise ValueError(msg)\nreturn summarize_run(\nfinal_atoms,\ninput_atoms=atoms,\nadditional_fields={\"name\": \"GULP Relax\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/gulp/core.html#quacc.recipes.gulp.core.static_job","title":"static_job","text":"<pre><code>static_job(\natoms,\nuse_gfnff=True,\nlibrary=None,\nkeyword_swaps=None,\noption_swaps=None,\ncopy_files=None,\n)\n</code></pre> <p>Carry out a single-point calculation. Note: 'Conditions' are not yet natively supported.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> use_gfnff             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>True if (p)GFN-FF should be used; False if not.</p> </li> <li> library             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Filename of the potential library file, if required.</p> </li> <li> keyword_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom keyword swap kwargs for the calculator.</p> </li> <li> option_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom option swap kwargs for the calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/gulp/core.py</code> <pre><code>@job\ndef static_job(\natoms: Atoms | dict,\nuse_gfnff: bool = True,\nlibrary: str | None = None,\nkeyword_swaps: dict | None = None,\noption_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Note: 'Conditions' are not yet natively supported.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    use_gfnff\n        True if (p)GFN-FF should be used; False if not.\n    library\n        Filename of the potential library file, if required.\n    keyword_swaps\n        Dictionary of custom keyword swap kwargs for the calculator.\n    option_swaps\n        Dictionary of custom option swap kwargs for the calculator.\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.ase.summarize_run`\n    \"\"\"\natoms = fetch_atoms(atoms)\nkeyword_swaps = keyword_swaps or {}\noption_swaps = option_swaps or {}\ndefault_keywords = {\n\"gfnff\": True if use_gfnff else None,\n\"gwolf\": True if use_gfnff and atoms.pbc.any() else None,\n}\ndefault_options = {\n\"dump every gulp.res\": True,\nf\"output cif {GEOM_FILE_PBC}\": True if atoms.pbc.any() else None,\nf\"output xyz {GEOM_FILE_NOPBC}\": None if atoms.pbc.any() else True,\n}\nkeywords = merge_dicts(default_keywords, keyword_swaps)\noptions = merge_dicts(default_options, option_swaps)\ngulp_keywords = \" \".join(list(keywords.keys()))\ngulp_options = list(options.keys())\natoms.calc = GULP(keywords=gulp_keywords, options=gulp_options, library=library)\nfinal_atoms = run_calc(\natoms,\ngeom_file=GEOM_FILE_PBC if atoms.pbc.any() else GEOM_FILE_NOPBC,\ncopy_files=copy_files,\n)\nreturn summarize_run(\nfinal_atoms,\ninput_atoms=atoms,\nadditional_fields={\"name\": \"GULP Static\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/lj/core.html","title":"core","text":"<p>Core recipes for Lennard-Jones Potential</p> <p>NOTE: This set of minimal recipes is mainly for demonstration purposes</p>"},{"location":"reference/quacc/recipes/lj/core.html#quacc.recipes.lj.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\natoms,\nenergy=0.0,\ntemperature=298.15,\npressure=1.0,\ncalc_swaps=None,\nvib_kwargs=None,\ncopy_files=None,\n)\n</code></pre> <p>Run a frequency job and calculate thermochemistry.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> energy             (<code>float</code>, default:                 <code>0.0</code> )         \u2013          <p>Potential energy in eV. If 0, then the output is just the correction.</p> </li> <li> temperature             (<code>float</code>, default:                 <code>298.15</code> )         \u2013          <p>Temperature in Kelvins.</p> </li> <li> pressure             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Pressure in bar.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>dictionary of custom kwargs for the LJ calculator.</p> </li> <li> vib_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>dictionary of custom kwargs for the Vibrations object</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_vib_run and quacc.schemas.ase.summarize_thermo</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/lj/core.py</code> <pre><code>@job\ndef freq_job(\natoms: Atoms | dict,\nenergy: float = 0.0,\ntemperature: float = 298.15,\npressure: float = 1.0,\ncalc_swaps: dict | None = None,\nvib_kwargs: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; FreqSchema:\n\"\"\"\n    Run a frequency job and calculate thermochemistry.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    energy\n        Potential energy in eV. If 0, then the output is just the correction.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    calc_swaps\n        dictionary of custom kwargs for the LJ calculator.\n    vib_kwargs\n        dictionary of custom kwargs for the Vibrations object\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    dict\n        Dictionary of results from quacc.schemas.ase.summarize_vib_run and\n        quacc.schemas.ase.summarize_thermo\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\nvib_kwargs = vib_kwargs or {}\natoms.calc = LennardJones(**calc_swaps)\nvibrations = run_ase_vib(atoms, vib_kwargs=vib_kwargs, copy_files=copy_files)\nvib_summary = summarize_vib_run(\nvibrations, additional_fields={\"name\": \"LJ Frequency Analysis\"}\n)\nigt = ideal_gas(atoms, vibrations.get_frequencies(), energy=energy)\nvib_summary[\"thermo\"] = summarize_thermo(\nigt, temperature=temperature, pressure=pressure\n)\nreturn vib_summary\n</code></pre>"},{"location":"reference/quacc/recipes/lj/core.html#quacc.recipes.lj.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\natoms, calc_swaps=None, opt_swaps=None, copy_files=None\n)\n</code></pre> <p>Function to carry out a geometry optimization</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the LJ calculator.</p> </li> <li> opt_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of swaps for run_ase_opt</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_opt_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/lj/core.py</code> <pre><code>@job\ndef relax_job(\natoms: Atoms | dict,\ncalc_swaps: dict | None = None,\nopt_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; OptSchema:\n\"\"\"\n    Function to carry out a geometry optimization\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    calc_swaps\n        Dictionary of custom kwargs for the LJ calculator.\n    opt_swaps\n        Dictionary of swaps for run_ase_opt\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from `quacc.schemas.ase.summarize_opt_run`\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\nopt_swaps = opt_swaps or {}\nopt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\nopt_flags = merge_dicts(opt_defaults, opt_swaps)\natoms.calc = LennardJones(**calc_swaps)\ndyn = run_ase_opt(atoms, copy_files=copy_files, **opt_flags)\nreturn summarize_opt_run(dyn, additional_fields={\"name\": \"LJ Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/lj/core.html#quacc.recipes.lj.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, calc_swaps=None, copy_files=None)\n</code></pre> <p>Function to carry out a static calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the LJ calculator</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/lj/core.py</code> <pre><code>@job\ndef static_job(\natoms: Atoms | dict,\ncalc_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Function to carry out a static calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    calc_swaps\n        Dictionary of custom kwargs for the LJ calculator\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.ase.summarize_run`\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\natoms.calc = LennardJones(**calc_swaps)\nfinal_atoms = run_calc(atoms, copy_files=copy_files)\nreturn summarize_run(\nfinal_atoms, input_atoms=atoms, additional_fields={\"name\": \"LJ Static\"}\n)\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/core.html","title":"core","text":"<p>Core recipes for the NewtonNet code</p>"},{"location":"reference/quacc/recipes/newtonnet/core.html#quacc.recipes.newtonnet.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\natoms, temperature=298.15, pressure=1.0, calc_swaps=None\n)\n</code></pre> <p>Perform a frequency calculation using the given atoms object.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>The atoms object representing the system.</p> </li> <li> temperature             (<code>float</code>, default:                 <code>298.15</code> )         \u2013          <p>The temperature for the thermodynamic analysis.</p> </li> <li> pressure             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>The pressure for the thermodynamic analysis.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional swaps for the calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Summary of the frequency calculation and thermo calculations.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/newtonnet/core.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Try pip install quacc[newtonnet]\")\ndef freq_job(\natoms: Atoms | dict,\ntemperature: float = 298.15,\npressure: float = 1.0,\ncalc_swaps: dict | None = None,\n) -&gt; FreqSchema:\n\"\"\"\n    Perform a frequency calculation using the given atoms object.\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    temperature\n        The temperature for the thermodynamic analysis.\n    pressure\n        The pressure for the thermodynamic analysis.\n    calc_swaps\n        Optional swaps for the calculator.\n    Returns\n    -------\n    dict\n        Summary of the frequency calculation and thermo calculations.\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n\"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n}\nflags = merge_dicts(defaults, calc_swaps)\nml_calculator = NewtonNet(**flags)\natoms.calc = ml_calculator\nml_calculator.calculate(atoms)\nhessian = ml_calculator.results[\"hessian\"]\nvib = VibrationsData(atoms, hessian)\nvib_summary = summarize_vib_run(\nvib, additional_fields={\"name\": \"NewtonNet Frequency Analysis\"}\n)\nigt = ideal_gas(\natoms, vib.get_frequencies(), energy=ml_calculator.results[\"energy\"]\n)\nvib_summary[\"thermo\"] = summarize_thermo(\nigt, temperature=temperature, pressure=pressure\n)\nreturn vib_summary\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/core.html#quacc.recipes.newtonnet.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\natoms, calc_swaps=None, opt_swaps=None, copy_files=None\n)\n</code></pre> <p>Relax a structure.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the newtonnet calculator</p> </li> <li> opt_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional swaps for the optimization parameters</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>A dictionary containing the results of the calculation.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/newtonnet/core.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Try pip install quacc[newtonnet]\")\ndef relax_job(\natoms: Atoms | dict,\ncalc_swaps: dict | None = None,\nopt_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; OptSchema:\n\"\"\"\n    Relax a structure.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    calc_swaps\n        Dictionary of custom kwargs for the newtonnet calculator\n    opt_swaps\n        Optional swaps for the optimization parameters\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    OptSchema\n        A dictionary containing the results of the calculation.\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\nopt_swaps = opt_swaps or {}\ndefaults = {\n\"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n\"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n}\nopt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": Sella or FIRE}\nflags = merge_dicts(defaults, calc_swaps)\nopt_flags = merge_dicts(opt_defaults, opt_swaps)\nif \"sella.optimize\" in opt_flags.get(\"optimizer\", FIRE).__module__:\nopt_flags[\"order\"] = 0\natoms.calc = NewtonNet(**flags)\ndyn = run_ase_opt(atoms, copy_files=copy_files, **opt_swaps)\nreturn _add_stdev_and_hess(\nsummarize_opt_run(dyn, additional_fields={\"name\": \"NewtonNet Relax\"})\n)\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/core.html#quacc.recipes.newtonnet.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, calc_swaps=None, copy_files=None)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the newtonnet calculator</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>A dictionary containing the results of the calculation.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/newtonnet/core.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Try pip install quacc[newtonnet]\")\ndef static_job(\natoms: Atoms | dict,\ncalc_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    calc_swaps\n        Dictionary of custom kwargs for the newtonnet calculator\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    RunSchema\n        A dictionary containing the results of the calculation.\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n\"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n}\nflags = merge_dicts(defaults, calc_swaps)\natoms.calc = NewtonNet(**flags)\nfinal_atoms = run_calc(atoms, copy_files=copy_files)\nreturn summarize_run(\nfinal_atoms, input_atoms=atoms, additional_fields={\"name\": \"NewtonNet Static\"}\n)\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html","title":"ts","text":"<p>Transition state recipes for the NewtonNet code</p>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.irc_job","title":"irc_job","text":"<pre><code>irc_job(\natoms,\ndirection=\"forward\",\nfreq_job=_freq_job,\nfreq_job_kwargs=None,\ncalc_swaps=None,\nopt_swaps=None,\ncheck_convergence=False,\n)\n</code></pre> <p>Perform an intrinsic reaction coordinate (IRC) job using the given atoms object.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>The atoms object representing the system.</p> </li> <li> direction             (<code>Literal['forward', 'reverse']</code>, default:                 <code>'forward'</code> )         \u2013          <p>The direction of the IRC calculation (\"forward\" or \"reverse\").</p> </li> <li> temperature         \u2013          <p>The temperature for the frequency calculation in Kelvins.</p> </li> <li> pressure         \u2013          <p>The pressure for the frequency calculation in bar.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional swaps for the calculator.</p> </li> <li> opt_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional swaps for the optimization parameters.</p> </li> <li> check_convergence             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to check the convergence of the optimization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>A dictionary containing the IRC summary and thermodynamic summary.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Try pip install quacc[newtonnet]\")\n@requires(Sella, \"Sella must be installed. Try pip install quacc[optimizers]\")\ndef irc_job(\natoms: Atoms | dict,\ndirection: Literal[\"forward\", \"reverse\"] = \"forward\",\nfreq_job: callable | None = _freq_job,\nfreq_job_kwargs: dict | None = None,\ncalc_swaps: dict | None = None,\nopt_swaps: dict | None = None,\ncheck_convergence: bool = False,\n) -&gt; IRCSchema:\n\"\"\"\n    Perform an intrinsic reaction coordinate (IRC) job using the given atoms object.\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    direction\n        The direction of the IRC calculation (\"forward\" or \"reverse\").\n    temperature\n        The temperature for the frequency calculation in Kelvins.\n    pressure\n        The pressure for the frequency calculation in bar.\n    calc_swaps\n        Optional swaps for the calculator.\n    opt_swaps\n        Optional swaps for the optimization parameters.\n    check_convergence\n        Whether to check the convergence of the optimization.\n    Returns\n    -------\n    dict\n        A dictionary containing the IRC summary and thermodynamic summary.\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\nopt_swaps = opt_swaps or {}\nfreq_job_kwargs = freq_job_kwargs or {}\ndefaults = {\n\"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n\"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n}\nopt_defaults = {\n\"fmax\": 0.01,\n\"max_steps\": 1000,\n\"optimizer\": IRC,\n\"optimizer_kwargs\": {\n\"dx\": 0.1,\n\"eta\": 1e-4,\n\"gamma\": 0.4,\n\"keep_going\": True,\n},\n\"run_kwargs\": {\n\"direction\": direction,\n},\n}\nflags = merge_dicts(defaults, calc_swaps)\nopt_flags = merge_dicts(opt_defaults, opt_swaps)\n# Define calculator\natoms.calc = NewtonNet(**flags)\n# Run IRC\ndyn = run_ase_opt(atoms, **opt_flags)\nopt_irc_summary = _add_stdev_and_hess(\nsummarize_opt_run(\ndyn,\ncheck_convergence=check_convergence,\nadditional_fields={\"name\": f\"NewtonNet IRC: {direction}\"},\n)\n)\n# Run frequency job\nfreq_summary = (\nfreq_job.undecorated(opt_irc_summary, **freq_job_kwargs) if freq_job else None\n)\nopt_irc_summary[\"freq\"] = freq_summary\nreturn opt_irc_summary\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.quasi_irc_job","title":"quasi_irc_job","text":"<pre><code>quasi_irc_job(\natoms,\ndirection=\"forward\",\nfreq_job=_freq_job,\nfreq_job_kwargs=None,\nirc_swaps=None,\nopt_swaps=None,\n)\n</code></pre> <p>Perform a quasi-IRC job using the given atoms object.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>The atoms object representing the system.</p> </li> <li> direction             (<code>Literal['forward', 'reverse']</code>, default:                 <code>'forward'</code> )         \u2013          <p>The direction of the IRC calculation (\"forward\" or \"reverse\").</p> </li> <li> temperature         \u2013          <p>The temperature for the frequency calculation in Kelvins.</p> </li> <li> pressure         \u2013          <p>The pressure for the frequency calculation in bar.</p> </li> <li> irc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional swaps for the IRC optimization parameters.</p> </li> <li> opt_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional swaps for the optimization parameters.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>A dictionary containing the IRC summary, optimization summary, and thermodynamic summary.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Try pip install quacc[newtonnet]\")\n@requires(Sella, \"Sella must be installed. Try pip install quacc[optimizers]\")\ndef quasi_irc_job(\natoms: Atoms | dict,\ndirection: Literal[\"forward\", \"reverse\"] = \"forward\",\nfreq_job: callable | None = _freq_job,\nfreq_job_kwargs: dict | None = None,\nirc_swaps: dict | None = None,\nopt_swaps: dict | None = None,\n) -&gt; QuasiIRCSchema:\n\"\"\"\n    Perform a quasi-IRC job using the given atoms object.\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    direction\n        The direction of the IRC calculation (\"forward\" or \"reverse\").\n    temperature\n        The temperature for the frequency calculation in Kelvins.\n    pressure\n        The pressure for the frequency calculation in bar.\n    irc_swaps\n        Optional swaps for the IRC optimization parameters.\n    opt_swaps\n        Optional swaps for the optimization parameters.\n    Returns\n    -------\n    dict\n        A dictionary containing the IRC summary, optimization summary, and thermodynamic summary.\n    \"\"\"\nirc_swaps = irc_swaps or {}\nopt_swaps = opt_swaps or {}\nfreq_job_kwargs = freq_job_kwargs or {}\nirc_defaults = {\"max_steps\": 5}\nirc_flags = merge_dicts(irc_defaults, irc_swaps)\n# Run IRC\nirc_summary = irc_job.undecorated(\natoms, direction=direction, opt_swaps=irc_flags, freq_job=None\n)\n# Run opt\nrelax_summary = relax_job.undecorated(irc_summary, **opt_swaps)\n# Run frequency\nfreq_summary = (\nfreq_job.undecorated(relax_summary, **freq_job_kwargs) if freq_job else None\n)\nrelax_summary[\"freq\"] = freq_summary\nrelax_summary[\"irc\"] = irc_summary\nreturn relax_summary\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.ts_job","title":"ts_job","text":"<pre><code>ts_job(\natoms,\nuse_custom_hessian=False,\nfreq_job=_freq_job,\nfreq_job_kwargs=None,\ncalc_swaps=None,\nopt_swaps=None,\ncheck_convergence=True,\n)\n</code></pre> <p>Perform a transition state (TS) job using the given atoms object.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>The atoms object representing the system.</p> </li> <li> use_custom_hessian             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to use a custom Hessian matrix.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional swaps for the calculator.</p> </li> <li> opt_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional swaps for the optimization parameters.</p> </li> <li> check_convergence             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to check the convergence of the optimization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>A dictionary containing the TS summary and thermodynamic summary.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Try pip install quacc[newtonnet]\")\n@requires(Sella, \"Sella must be installed. Try pip install quacc[optimizers]\")\ndef ts_job(\natoms: Atoms | dict,\nuse_custom_hessian: bool = False,\nfreq_job: callable | None = _freq_job,\nfreq_job_kwargs: dict | None = None,\ncalc_swaps: dict | None = None,\nopt_swaps: dict | None = None,\ncheck_convergence: bool = True,\n) -&gt; TSSchema:\n\"\"\"\n    Perform a transition state (TS) job using the given atoms object.\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    use_custom_hessian\n        Whether to use a custom Hessian matrix.\n    calc_swaps\n        Optional swaps for the calculator.\n    opt_swaps\n        Optional swaps for the optimization parameters.\n    check_convergence\n        Whether to check the convergence of the optimization.\n    Returns\n    -------\n    dict\n        A dictionary containing the TS summary and thermodynamic summary.\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\nopt_swaps = opt_swaps or {}\nfreq_job_kwargs = freq_job_kwargs or {}\ndefaults = {\n\"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n\"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n}\nopt_defaults = {\n\"fmax\": 0.01,\n\"max_steps\": 1000,\n\"optimizer\": Sella,\n\"optimizer_kwargs\": {\"diag_every_n\": 0} if use_custom_hessian else {},\n}\nflags = merge_dicts(defaults, calc_swaps)\nopt_flags = merge_dicts(opt_defaults, opt_swaps)\natoms.calc = NewtonNet(**flags)\nif use_custom_hessian:\nif opt_flags.get(\"optimizer\", FIRE).__name__ != \"Sella\":\nraise ValueError(\"Custom hessian can only be used with Sella.\")\nopt_flags[\"optimizer_kwargs\"][\"hessian_function\"] = _get_hessian\nml_calculator = NewtonNet(**flags)\natoms.calc = ml_calculator\n# Run the TS optimization\ndyn = run_ase_opt(atoms, **opt_flags)\nopt_ts_summary = _add_stdev_and_hess(\nsummarize_opt_run(\ndyn,\ncheck_convergence=check_convergence,\nadditional_fields={\"name\": \"NewtonNet TS\"},\n)\n)\n# Run a frequency calculation\nfreq_summary = (\nfreq_job.undecorated(opt_ts_summary, **freq_job_kwargs) if freq_job else None\n)\nopt_ts_summary[\"freq\"] = freq_summary\nreturn opt_ts_summary\n</code></pre>"},{"location":"reference/quacc/recipes/orca/core.html","title":"core","text":"<p>Core recipes for ORCA</p>"},{"location":"reference/quacc/recipes/orca/core.html#quacc.recipes.orca.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\natoms,\ncharge=None,\nmultiplicity=None,\nxc=\"wb97x-d3bj\",\nbasis=\"def2-tzvp\",\nrun_freq=False,\ninput_swaps=None,\nblock_swaps=None,\ncopy_files=None,\n)\n</code></pre> <p>Carry out a geometry optimization.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object</p> </li> <li> charge             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge of the system. If None, this is determined from the sum of atoms.get_initial_charges().</p> </li> <li> multiplicity             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Multiplicity of the system. If None, this is determined from 1+ the sum of atoms.get_initial_magnetic_moments().</p> </li> <li> xc             (<code>str</code>, default:                 <code>'wb97x-d3bj'</code> )         \u2013          <p>Exchange-correlation functional</p> </li> <li> basis             (<code>str</code>, default:                 <code>'def2-tzvp'</code> )         \u2013          <p>Basis set</p> </li> <li> run_freq             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If a requency calculation should be carried out.</p> </li> <li> input_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of orcasimpleinput swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None.</p> </li> <li> block_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of orcablock swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cclibSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.cclib.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/orca/core.py</code> <pre><code>@job\ndef relax_job(\natoms: Atoms | dict,\ncharge: int | None = None,\nmultiplicity: int | None = None,\nxc: str = \"wb97x-d3bj\",\nbasis: str = \"def2-tzvp\",\nrun_freq: bool = False,\ninput_swaps: dict | None = None,\nblock_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; cclibSchema:\n\"\"\"\n    Carry out a geometry optimization.\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system. If None, this is determined from the sum of\n        atoms.get_initial_charges().\n    multiplicity\n        Multiplicity of the system. If None, this is determined from 1+ the sum\n        of atoms.get_initial_magnetic_moments().\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    run_freq\n        If a requency calculation should be carried out.\n    input_swaps\n        Dictionary of orcasimpleinput swaps for the calculator.\n        To enable new entries, set the value as True.\n        To remove entries from the defaults, set the value as None.\n    block_swaps\n        Dictionary of orcablock swaps for the calculator.\n        To enable new entries, set the value as True.\n        To remove entries from the defaults, set the value as None.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    cclibSchema\n        Dictionary of results from quacc.schemas.cclib.summarize_run\n    \"\"\"\natoms = fetch_atoms(atoms)\ninput_swaps = input_swaps or {}\nblock_swaps = block_swaps or {}\ndefault_inputs = {\nxc: True,\nbasis: True,\n\"opt\": True,\n\"slowconv\": True,\n\"normalprint\": True,\n\"freq\": True if run_freq else None,\n\"xyzfile\": True,\n}\ndefault_blocks = (\n{f\"%pal nprocs {multiprocessing.cpu_count()} end\": True}\nif which(\"mpirun\")\nelse {}\n)\ninputs = merge_dicts(default_inputs, input_swaps)\nblocks = merge_dicts(default_blocks, block_swaps)\norcasimpleinput = \" \".join(list(inputs.keys()))\norcablocks = \" \".join(list(blocks.keys()))\natoms.calc = ORCA(\nprofile=OrcaProfile([SETTINGS.ORCA_CMD]),\ncharge=get_charge(atoms) if charge is None else charge,\nmult=get_multiplicity(atoms) if multiplicity is None else multiplicity,\norcasimpleinput=orcasimpleinput,\norcablocks=orcablocks,\n)\natoms = run_calc(atoms, geom_file=GEOM_FILE, copy_files=copy_files)\nreturn summarize_run(\natoms,\nLOG_FILE,\nadditional_fields={\"name\": \"ORCA Relax\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/orca/core.html#quacc.recipes.orca.core.static_job","title":"static_job","text":"<pre><code>static_job(\natoms,\ncharge=None,\nmultiplicity=None,\nxc=\"wb97x-d3bj\",\nbasis=\"def2-tzvp\",\ninput_swaps=None,\nblock_swaps=None,\ncopy_files=None,\n)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> charge             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge of the system. If None, this is determined from the sum of <code>atoms.get_initial_charges()</code>.</p> </li> <li> multiplicity             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Multiplicity of the system. If None, this is determined from 1+ the sum of <code>atoms.get_initial_magnetic_moments()</code>.</p> </li> <li> xc             (<code>str</code>, default:                 <code>'wb97x-d3bj'</code> )         \u2013          <p>Exchange-correlation functional</p> </li> <li> basis             (<code>str</code>, default:                 <code>'def2-tzvp'</code> )         \u2013          <p>Basis set</p> </li> <li> input_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of orcasimpleinput swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None.</p> </li> <li> block_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of orcablock swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cclibSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.cclib.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/orca/core.py</code> <pre><code>@job\ndef static_job(\natoms: Atoms | dict,\ncharge: int | None = None,\nmultiplicity: int | None = None,\nxc: str = \"wb97x-d3bj\",\nbasis: str = \"def2-tzvp\",\ninput_swaps: dict | None = None,\nblock_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; cclibSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    charge\n        Charge of the system. If None, this is determined from the sum of\n        `atoms.get_initial_charges()`.\n    multiplicity\n        Multiplicity of the system. If None, this is determined from 1+ the sum\n        of `atoms.get_initial_magnetic_moments()`.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    input_swaps\n        Dictionary of orcasimpleinput swaps for the calculator.\n        To enable new entries, set the value as True.\n        To remove entries from the defaults, set the value as None.\n    block_swaps\n        Dictionary of orcablock swaps for the calculator.\n        To enable new entries, set the value as True.\n        To remove entries from the defaults, set the value as None.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    cclibSchema\n        Dictionary of results from quacc.schemas.cclib.summarize_run\n    \"\"\"\natoms = fetch_atoms(atoms)\ninput_swaps = input_swaps or {}\nblock_swaps = block_swaps or {}\ndefault_inputs = {\nxc: True,\nbasis: True,\n\"sp\": True,\n\"slowconv\": True,\n\"normalprint\": True,\n\"xyzfile\": True,\n}\ndefault_blocks = (\n{f\"%pal nprocs {multiprocessing.cpu_count()} end\": True}\nif which(\"mpirun\")\nelse {}\n)\ninputs = merge_dicts(default_inputs, input_swaps)\nblocks = merge_dicts(default_blocks, block_swaps)\norcasimpleinput = \" \".join(list(inputs.keys()))\norcablocks = \" \".join(list(blocks.keys()))\natoms.calc = ORCA(\nprofile=OrcaProfile([SETTINGS.ORCA_CMD]),\ncharge=get_charge(atoms) if charge is None else charge,\nmult=get_multiplicity(atoms) if multiplicity is None else multiplicity,\norcasimpleinput=orcasimpleinput,\norcablocks=orcablocks,\n)\natoms = run_calc(atoms, geom_file=GEOM_FILE, copy_files=copy_files)\nreturn summarize_run(\natoms,\nLOG_FILE,\nadditional_fields={\"name\": \"ORCA Static\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/psi4/core.html","title":"core","text":"<p>Core recipes for Psi4</p>"},{"location":"reference/quacc/recipes/psi4/core.html#quacc.recipes.psi4.core.static_job","title":"static_job","text":"<pre><code>static_job(\natoms,\ncharge=None,\nmultiplicity=None,\nmethod=\"wb97x-v\",\nbasis=\"def2-tzvp\",\ncalc_swaps=None,\ncopy_files=None,\n)\n</code></pre> <p>Function to carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> charge             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge of the system. If None, this is determined from the sum of <code>atoms.get_initial_charges()</code>.</p> </li> <li> multiplicity             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Multiplicity of the system. If None, this is determined from 1+ the sum of <code>atoms.get_initial_magnetic_moments()</code>.</p> </li> <li> method             (<code>str</code>, default:                 <code>'wb97x-v'</code> )         \u2013          <p>The level of theory to use.</p> </li> <li> basis             (<code>str</code>, default:                 <code>'def2-tzvp'</code> )         \u2013          <p>Basis set</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/psi4/core.py</code> <pre><code>@job\n@requires(psi4, \"Psi4 not installed. Try conda install -c psi4 psi4\")\ndef static_job(\natoms: Atoms | dict,\ncharge: int | None = None,\nmultiplicity: int | None = None,\nmethod: str = \"wb97x-v\",\nbasis: str = \"def2-tzvp\",\ncalc_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Function to carry out a single-point calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    charge\n        Charge of the system. If None, this is determined from the sum of\n        `atoms.get_initial_charges()`.\n    multiplicity\n        Multiplicity of the system. If None, this is determined from 1+ the sum\n        of `atoms.get_initial_magnetic_moments()`.\n    method\n        The level of theory to use.\n    basis\n        Basis set\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.ase.summarize_run`\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\nif charge is None:\ncharge = get_charge(atoms)\nif multiplicity is None:\nmultiplicity = get_multiplicity(atoms)\ndefaults = {\n\"mem\": \"16GB\",\n\"num_threads\": \"max\",\n\"method\": method,\n\"basis\": basis,\n\"charge\": charge,\n\"multiplicity\": multiplicity,\n\"reference\": \"uks\" if multiplicity &gt; 1 else \"rks\",\n}\nflags = merge_dicts(defaults, calc_swaps)\natoms.calc = Psi4(**flags)\nfinal_atoms = run_calc(atoms, copy_files=copy_files)\nreturn summarize_run(\nfinal_atoms,\ninput_atoms=atoms,\ncharge_and_multiplicity=(charge, multiplicity),\nadditional_fields={\"name\": \"Psi4 Static\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/core.html","title":"core","text":"<p>Core recipes for the Q-Chem</p>"},{"location":"reference/quacc/recipes/qchem/core.html#quacc.recipes.qchem.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\natoms,\ncharge=None,\nspin_multiplicity=None,\nmethod=\"wb97mv\",\nbasis=\"def2-svpd\",\nscf_algorithm=\"diis\",\npcm_dielectric=None,\nsmd_solvent=None,\nn_cores=None,\noverwrite_inputs=None,\nopt_swaps=None,\n)\n</code></pre> <p>Optimize aka \"relax\" a molecular structure.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> charge             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The total charge of the molecular system. Effectively defaults to zero.</p> </li> <li> spin_multiplicity             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The spin multiplicity of the molecular system. Effectively defaults to the lowest spin state given the molecular structure and charge.</p> </li> <li> method             (<code>str</code>, default:                 <code>'wb97mv'</code> )         \u2013          <p>DFT exchange-correlation functional or other electronic structure method. Defaults to wB97M-V.</p> </li> <li> basis             (<code>str</code>, default:                 <code>'def2-svpd'</code> )         \u2013          <p>Basis set. Defaults to def2-SVPD.</p> </li> <li> scf_algorithm             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>Algorithm used to converge the SCF. Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.</p> </li> <li> pcm_dielectric             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Dielectric constant of the optional polarizable continuum impicit solvation model. Defaults to None, in which case PCM will not be employed.</p> </li> <li> smd_solvent             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available. Defaults to None, in which case SMD will not be employed.</p> </li> <li> n_cores             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation. Defaults to use all cores available on a given node.</p> </li> <li> overwrite_inputs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary passed to pymatgen.io.qchem.QChemDictSet which can modify default values set therein as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.</p> </li> <li> opt_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for run_ase_opt     opt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": \"Sella\"}</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/qchem/core.py</code> <pre><code>@job\ndef relax_job(\natoms: Atoms | dict,\ncharge: int | None = None,\nspin_multiplicity: int | None = None,\nmethod: str = \"wb97mv\",\nbasis: str = \"def2-svpd\",\nscf_algorithm: str = \"diis\",\npcm_dielectric: str | None = None,\nsmd_solvent: str | None = None,\nn_cores: int | None = None,\noverwrite_inputs: dict | None = None,\nopt_swaps: dict | None = None,\n) -&gt; OptSchema:\n\"\"\"\n    Optimize aka \"relax\" a molecular structure.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    charge\n        The total charge of the molecular system.\n        Effectively defaults to zero.\n    spin_multiplicity\n        The spin multiplicity of the molecular system.\n        Effectively defaults to the lowest spin state given the molecular structure and charge.\n    method\n        DFT exchange-correlation functional or other electronic structure method.\n        Defaults to wB97M-V.\n    basis\n        Basis set.\n        Defaults to def2-SVPD.\n    scf_algorithm\n        Algorithm used to converge the SCF.\n        Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.\n    pcm_dielectric\n        Dielectric constant of the optional polarizable continuum impicit solvation model.\n        Defaults to None, in which case PCM will not be employed.\n    smd_solvent\n        Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\",\n        and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available.\n        Defaults to None, in which case SMD will not be employed.\n    n_cores\n        Number of cores to use for the Q-Chem calculation.\n        Defaults to use all cores available on a given node.\n    overwrite_inputs\n        Dictionary passed to pymatgen.io.qchem.QChemDictSet which can modify default values set therein\n        as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.\n    opt_swaps\n        Dictionary of custom kwargs for run_ase_opt\n            opt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": \"Sella\"}\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from quacc.schemas.ase.summarize_opt_run\n    \"\"\"\n# TODO: exposing TRICs?\natoms = fetch_atoms(atoms)\nchecked_charge, checked_spin_multiplicity = check_charge_and_spin(\natoms, charge, spin_multiplicity\n)\nqchem_defaults = {\n\"method\": method,\n\"charge\": charge,\n\"spin_multiplicity\": spin_multiplicity,\n\"cores\": n_cores or multiprocessing.cpu_count(),\n\"qchem_input_params\": {\n\"basis_set\": basis,\n\"scf_algorithm\": scf_algorithm,\n\"pcm_dielectric\": pcm_dielectric,\n\"smd_solvent\": smd_solvent,\n\"overwrite_inputs\": overwrite_inputs,\n\"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n},\n}\nqchem_flags = remove_dict_empties(qchem_defaults)\nopt_swaps = opt_swaps or {}\nopt_defaults = {\n\"fmax\": 0.01,\n\"max_steps\": 1000,\n\"optimizer\": FIRE if not has_sella else Sella,\n}\nopt_flags = merge_dicts(opt_defaults, opt_swaps)\nif opt_flags[\"optimizer\"].__name__ == \"Sella\" and \"order\" not in opt_flags.get(\n\"optimizer_kwargs\", {}\n):\nif \"optimizer_kwargs\" not in opt_flags:\nopt_flags[\"optimizer_kwargs\"] = {}\nopt_flags[\"optimizer_kwargs\"][\"order\"] = 0\natoms.calc = QChem(atoms, **qchem_flags)\ndyn = run_ase_opt(atoms, **opt_flags)\nreturn summarize_opt_run(\ndyn,\ncharge_and_multiplicity=(checked_charge, checked_spin_multiplicity),\nadditional_fields={\"name\": \"Q-Chem Optimization\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/core.html#quacc.recipes.qchem.core.static_job","title":"static_job","text":"<pre><code>static_job(\natoms,\ncharge=None,\nspin_multiplicity=None,\nmethod=\"wb97mv\",\nbasis=\"def2-tzvpd\",\nscf_algorithm=\"diis\",\npcm_dielectric=None,\nsmd_solvent=None,\nn_cores=None,\noverwrite_inputs=None,\n)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> charge             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The total charge of the molecular system. Effectively defaults to zero.</p> </li> <li> spin_multiplicity             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The spin multiplicity of the molecular system. Effectively defaults to the lowest spin state given the molecular structure and charge.</p> </li> <li> method             (<code>str</code>, default:                 <code>'wb97mv'</code> )         \u2013          <p>DFT exchange-correlation functional or other electronic structure method. Defaults to wB97M-V.</p> </li> <li> basis             (<code>str</code>, default:                 <code>'def2-tzvpd'</code> )         \u2013          <p>Basis set. Defaults to def2-TZVPD.</p> </li> <li> scf_algorithm             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>Algorithm used to converge the SCF. Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.</p> </li> <li> pcm_dielectric             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Dielectric constant of the optional polarizable continuum impicit solvation model. Defaults to None, in which case PCM will not be employed.</p> </li> <li> smd_solvent             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available. Defaults to None, in which case SMD will not be employed.</p> </li> <li> n_cores             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation. Defaults to use all cores available on a given node.</p> </li> <li> overwrite_inputs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary passed to pymatgen.io.qchem.QChemDictSet which can modify default values set therein as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/qchem/core.py</code> <pre><code>@job\ndef static_job(\natoms: Atoms | dict,\ncharge: int | None = None,\nspin_multiplicity: int | None = None,\nmethod: str = \"wb97mv\",\nbasis: str = \"def2-tzvpd\",\nscf_algorithm: str = \"diis\",\npcm_dielectric: str | None = None,\nsmd_solvent: str | None = None,\nn_cores: int | None = None,\noverwrite_inputs: dict | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    charge\n        The total charge of the molecular system.\n        Effectively defaults to zero.\n    spin_multiplicity\n        The spin multiplicity of the molecular system.\n        Effectively defaults to the lowest spin state given the molecular structure and charge.\n    method\n        DFT exchange-correlation functional or other electronic structure method.\n        Defaults to wB97M-V.\n    basis\n        Basis set.\n        Defaults to def2-TZVPD.\n    scf_algorithm\n        Algorithm used to converge the SCF.\n        Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.\n    pcm_dielectric\n        Dielectric constant of the optional polarizable continuum impicit solvation model.\n        Defaults to None, in which case PCM will not be employed.\n    smd_solvent\n        Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\",\n        and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available.\n        Defaults to None, in which case SMD will not be employed.\n    n_cores\n        Number of cores to use for the Q-Chem calculation.\n        Defaults to use all cores available on a given node.\n    overwrite_inputs\n        Dictionary passed to pymatgen.io.qchem.QChemDictSet which can modify default values set therein\n        as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from quacc.schemas.ase.summarize_run\n    \"\"\"\natoms = fetch_atoms(atoms)\nchecked_charge, checked_spin_multiplicity = check_charge_and_spin(\natoms, charge, spin_multiplicity\n)\nqchem_defaults = {\n\"method\": method,\n\"charge\": charge,\n\"spin_multiplicity\": spin_multiplicity,\n\"cores\": n_cores or multiprocessing.cpu_count(),\n\"qchem_input_params\": {\n\"basis_set\": basis,\n\"scf_algorithm\": scf_algorithm,\n\"pcm_dielectric\": pcm_dielectric,\n\"smd_solvent\": smd_solvent,\n\"overwrite_inputs\": overwrite_inputs,\n\"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n},\n}\nqchem_flags = remove_dict_empties(qchem_defaults)\natoms.calc = QChem(atoms, **qchem_flags)\nfinal_atoms = run_calc(atoms)\nreturn summarize_run(\nfinal_atoms,\ninput_atoms=atoms,\ncharge_and_multiplicity=(checked_charge, checked_spin_multiplicity),\nadditional_fields={\"name\": \"Q-Chem Static\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/ts.html","title":"ts","text":"<p>Transition state recipes for the Q-Chem</p>"},{"location":"reference/quacc/recipes/qchem/ts.html#quacc.recipes.qchem.ts.irc_job","title":"irc_job","text":"<pre><code>irc_job(\natoms,\ndirection,\ncharge=None,\nspin_multiplicity=None,\nmethod=\"wb97mv\",\nbasis=\"def2-svpd\",\nscf_algorithm=\"diis\",\npcm_dielectric=None,\nsmd_solvent=None,\nn_cores=None,\noverwrite_inputs=None,\nopt_swaps=None,\n)\n</code></pre> <p>IRC optimize a molecular structure.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> direction             (<code>Literal['forward', 'reverse']</code>)         \u2013          <p>Direction of the IRC. Should be \"forward\" or \"reverse\".</p> </li> <li> charge             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The total charge of the molecular system. Effectively defaults to zero.</p> </li> <li> spin_multiplicity             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The spin multiplicity of the molecular system. Effectively defaults to the lowest spin state given the molecular structure and charge.</p> </li> <li> method             (<code>str</code>, default:                 <code>'wb97mv'</code> )         \u2013          <p>DFT exchange-correlation functional or other electronic structure method. Defaults to wB97M-V.</p> </li> <li> basis             (<code>str</code>, default:                 <code>'def2-svpd'</code> )         \u2013          <p>Basis set. Defaults to def2-SVPD.</p> </li> <li> scf_algorithm             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>Algorithm used to converge the SCF. Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.</p> </li> <li> pcm_dielectric             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Dielectric constant of the optional polarizable continuum impicit solvation model. Defaults to None, in which case PCM will not be employed.</p> </li> <li> smd_solvent             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available. Defaults to None, in which case SMD will not be employed.</p> </li> <li> n_cores             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation. Defaults to use all cores available on a given node.</p> </li> <li> overwrite_inputs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary passed to pymatgen.io.qchem.QChemDictSet which can modify default values set therein as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.</p> </li> <li> opt_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for run_ase_opt     opt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": \"Sella\"}</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/qchem/ts.py</code> <pre><code>@job\n@requires(\nhas_sella,\n\"Sella must be installed. Try pip install quacc[optimizers].\",\n)\ndef irc_job(\natoms: Atoms | dict,\ndirection: Literal[\"forward\", \"reverse\"],\ncharge: int | None = None,\nspin_multiplicity: int | None = None,\nmethod: str = \"wb97mv\",\nbasis: str = \"def2-svpd\",\nscf_algorithm: str = \"diis\",\npcm_dielectric: str | None = None,\nsmd_solvent: str | None = None,\nn_cores: int | None = None,\noverwrite_inputs: dict | None = None,\nopt_swaps: dict | None = None,\n) -&gt; OptSchema:\n\"\"\"\n    IRC optimize a molecular structure.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    direction\n        Direction of the IRC. Should be \"forward\" or \"reverse\".\n    charge\n        The total charge of the molecular system.\n        Effectively defaults to zero.\n    spin_multiplicity\n        The spin multiplicity of the molecular system.\n        Effectively defaults to the lowest spin state given the molecular structure and charge.\n    method\n        DFT exchange-correlation functional or other electronic structure method.\n        Defaults to wB97M-V.\n    basis\n        Basis set.\n        Defaults to def2-SVPD.\n    scf_algorithm\n        Algorithm used to converge the SCF.\n        Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.\n    pcm_dielectric\n        Dielectric constant of the optional polarizable continuum impicit solvation model.\n        Defaults to None, in which case PCM will not be employed.\n    smd_solvent\n        Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\",\n        and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available.\n        Defaults to None, in which case SMD will not be employed.\n    n_cores\n        Number of cores to use for the Q-Chem calculation.\n        Defaults to use all cores available on a given node.\n    overwrite_inputs\n        Dictionary passed to pymatgen.io.qchem.QChemDictSet which can modify default values set therein\n        as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.\n    opt_swaps\n        Dictionary of custom kwargs for run_ase_opt\n            opt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": \"Sella\"}\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from quacc.schemas.ase.summarize_opt_run\n    \"\"\"\n# TODO: 1) expose TRICs?; 2) passing initial Hessian?\natoms = fetch_atoms(atoms)\nchecked_charge, checked_spin_multiplicity = check_charge_and_spin(\natoms, charge, spin_multiplicity\n)\nqchem_defaults = {\n\"method\": method,\n\"charge\": charge,\n\"spin_multiplicity\": spin_multiplicity,\n\"cores\": n_cores or multiprocessing.cpu_count(),\n\"qchem_input_params\": {\n\"basis_set\": basis,\n\"scf_algorithm\": scf_algorithm,\n\"pcm_dielectric\": pcm_dielectric,\n\"smd_solvent\": smd_solvent,\n\"overwrite_inputs\": overwrite_inputs,\n\"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n},\n}\nqchem_flags = remove_dict_empties(qchem_defaults)\nopt_swaps = opt_swaps or {}\nopt_defaults = {\n\"fmax\": 0.01,\n\"max_steps\": 1000,\n\"optimizer\": IRC,\n\"optimizer_kwargs\": {\"keep_going\": True},\n\"run_kwargs\": {\"direction\": direction},\n}\nopt_flags = merge_dicts(opt_defaults, opt_swaps)\nif opt_flags[\"optimizer\"] != IRC:\nraise ValueError(\"Only Sella's IRC should be used for IRC optimization.\")\natoms.calc = QChem(atoms, **qchem_flags)\ndyn = run_ase_opt(atoms, **opt_flags)\nreturn summarize_opt_run(\ndyn,\ncharge_and_multiplicity=(checked_charge, checked_spin_multiplicity),\nadditional_fields={\"name\": \"Q-Chem IRC Optimization\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/ts.html#quacc.recipes.qchem.ts.quasi_irc_job","title":"quasi_irc_job","text":"<pre><code>quasi_irc_job(\natoms,\ndirection,\nshared_kwargs=None,\nirc_opt_swaps=None,\nrelax_opt_swaps=None,\n)\n</code></pre> <p>Quasi-IRC optimize a molecular structure.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object.</p> </li> <li> direction             (<code>Literal['forward', 'reverse']</code>)         \u2013          <p>Direction of the IRC. Should be \"forward\" or \"reverse\".</p> </li> <li> shared_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of kwargs that are passed as input to both irc_job and relax_job.</p> </li> <li> irc_opt_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of opt_swap kwargs for the irc_job.</p> </li> <li> relax_opt_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of opt_swap kwargs for the relax_job.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/qchem/ts.py</code> <pre><code>@job\n@requires(\nhas_sella,\n\"Sella must be installed. Try pip install quacc[optimizers].\",\n)\ndef quasi_irc_job(\natoms: Atoms | dict,\ndirection: Literal[\"forward\", \"reverse\"],\nshared_kwargs: dict | None = None,\nirc_opt_swaps: dict | None = None,\nrelax_opt_swaps: dict | None = None,\n) -&gt; OptSchema:\n\"\"\"\n    Quasi-IRC optimize a molecular structure.\n    Parameters\n    ----------\n    atoms\n        Atoms object.\n    direction\n        Direction of the IRC. Should be \"forward\" or \"reverse\".\n    shared_kwargs\n        Dictionary of kwargs that are passed as input to both irc_job and relax_job.\n    irc_opt_swaps\n        Dictionary of opt_swap kwargs for the irc_job.\n    relax_opt_swaps\n        Dictionary of opt_swap kwargs for the relax_job.\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from quacc.schemas.ase.summarize_opt_run\n    \"\"\"\nshared_kwargs = shared_kwargs or {}\nirc_opt_swaps = irc_opt_swaps or {}\nrelax_opt_swaps = relax_opt_swaps or {}\ndefault_settings = SETTINGS.copy()\nirc_opt_swaps_defaults = {\n\"fmax\": 100,\n\"max_steps\": 10,\n}\nirc_opt_swaps = merge_dicts(irc_opt_swaps_defaults, irc_opt_swaps)\nSETTINGS.CHECK_CONVERGENCE = False\nirc_summary = irc_job(\natoms,\ndirection=direction,\nopt_swaps=irc_opt_swaps,\n**shared_kwargs,\n)\nSETTINGS.CHECK_CONVERGENCE = default_settings.CHECK_CONVERGENCE\nrelax_summary = relax_job(\nirc_summary,\nopt_swaps=relax_opt_swaps,\n**shared_kwargs,\n)\nrelax_summary[\"initial_irc\"] = irc_summary\nreturn relax_summary\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/ts.html#quacc.recipes.qchem.ts.ts_job","title":"ts_job","text":"<pre><code>ts_job(\natoms,\ncharge=None,\nspin_multiplicity=None,\nmethod=\"wb97mv\",\nbasis=\"def2-svpd\",\nscf_algorithm=\"diis\",\npcm_dielectric=None,\nsmd_solvent=None,\nn_cores=None,\noverwrite_inputs=None,\nopt_swaps=None,\n)\n</code></pre> <p>TS optimize a molecular structure.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> charge             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The total charge of the molecular system. Effectively defaults to zero.</p> </li> <li> spin_multiplicity             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The spin multiplicity of the molecular system. Effectively defaults to the lowest spin state given the molecular structure and charge.</p> </li> <li> method             (<code>str</code>, default:                 <code>'wb97mv'</code> )         \u2013          <p>DFT exchange-correlation functional or other electronic structure method. Defaults to wB97M-V.</p> </li> <li> basis             (<code>str</code>, default:                 <code>'def2-svpd'</code> )         \u2013          <p>Basis set. Defaults to def2-SVPD.</p> </li> <li> scf_algorithm             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>Algorithm used to converge the SCF. Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.</p> </li> <li> pcm_dielectric             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Dielectric constant of the optional polarizable continuum impicit solvation model. Defaults to None, in which case PCM will not be employed.</p> </li> <li> smd_solvent             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available. Defaults to None, in which case SMD will not be employed.</p> </li> <li> n_cores             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation. Defaults to use all cores available on a given node.</p> </li> <li> overwrite_inputs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary passed to pymatgen.io.qchem.QChemDictSet which can modify default values set therein as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.</p> </li> <li> opt_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for run_ase_opt     opt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": \"Sella\"}</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/qchem/ts.py</code> <pre><code>@job\n@requires(\nhas_sella,\n\"Sella must be installed. Try pip install quacc[optimizers].\",\n)\ndef ts_job(\natoms: Atoms | dict,\ncharge: int | None = None,\nspin_multiplicity: int | None = None,\nmethod: str = \"wb97mv\",\nbasis: str = \"def2-svpd\",\nscf_algorithm: str = \"diis\",\npcm_dielectric: str | None = None,\nsmd_solvent: str | None = None,\nn_cores: int | None = None,\noverwrite_inputs: dict | None = None,\nopt_swaps: dict | None = None,\n) -&gt; OptSchema:\n\"\"\"\n    TS optimize a molecular structure.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    charge\n        The total charge of the molecular system.\n        Effectively defaults to zero.\n    spin_multiplicity\n        The spin multiplicity of the molecular system.\n        Effectively defaults to the lowest spin state given the molecular structure and charge.\n    method\n        DFT exchange-correlation functional or other electronic structure method.\n        Defaults to wB97M-V.\n    basis\n        Basis set.\n        Defaults to def2-SVPD.\n    scf_algorithm\n        Algorithm used to converge the SCF.\n        Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.\n    pcm_dielectric\n        Dielectric constant of the optional polarizable continuum impicit solvation model.\n        Defaults to None, in which case PCM will not be employed.\n    smd_solvent\n        Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\",\n        and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available.\n        Defaults to None, in which case SMD will not be employed.\n    n_cores\n        Number of cores to use for the Q-Chem calculation.\n        Defaults to use all cores available on a given node.\n    overwrite_inputs\n        Dictionary passed to pymatgen.io.qchem.QChemDictSet which can modify default values set therein\n        as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.\n    opt_swaps\n        Dictionary of custom kwargs for run_ase_opt\n            opt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": \"Sella\"}\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from quacc.schemas.ase.summarize_opt_run\n    \"\"\"\n# TODO:\n#   - exposing TRICs?\n#   - passing initial Hessian?\natoms = fetch_atoms(atoms)\nchecked_charge, checked_spin_multiplicity = check_charge_and_spin(\natoms, charge, spin_multiplicity\n)\nqchem_defaults = {\n\"method\": method,\n\"charge\": charge,\n\"spin_multiplicity\": spin_multiplicity,\n\"cores\": n_cores or multiprocessing.cpu_count(),\n\"qchem_input_params\": {\n\"basis_set\": basis,\n\"scf_algorithm\": scf_algorithm,\n\"pcm_dielectric\": pcm_dielectric,\n\"smd_solvent\": smd_solvent,\n\"overwrite_inputs\": overwrite_inputs,\n\"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n},\n}\nqchem_flags = remove_dict_empties(qchem_defaults)\nopt_swaps = opt_swaps or {}\nopt_defaults = {\n\"fmax\": 0.01,\n\"max_steps\": 1000,\n\"optimizer\": Sella,\n}\nopt_flags = merge_dicts(opt_defaults, opt_swaps)\nif opt_flags[\"optimizer\"] != Sella:\nraise ValueError(\"Only Sella should be used for TS optimization.\")\natoms.calc = QChem(atoms, **qchem_flags)\ndyn = run_ase_opt(atoms, **opt_flags)\nreturn summarize_opt_run(\ndyn,\ncharge_and_multiplicity=(checked_charge, checked_spin_multiplicity),\nadditional_fields={\"name\": \"Q-Chem TS Optimization\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html","title":"core","text":"<p>Core recipes for the tblite code</p>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\natoms,\nmethod=\"GFN2-xTB\",\nenergy=0.0,\ntemperature=298.15,\npressure=1.0,\ncalc_swaps=None,\nvib_kwargs=None,\ncopy_files=None,\n)\n</code></pre> <p>Run a frequency job and calculate thermochemistry.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> method             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code>, default:                 <code>'GFN2-xTB'</code> )         \u2013          <p>GFN0-xTB, GFN1-xTB, GFN2-xTB, GFN-FF.</p> </li> <li> energy             (<code>float</code>, default:                 <code>0.0</code> )         \u2013          <p>Potential energy in eV. If 0, then the output is just the correction.</p> </li> <li> temperature             (<code>float</code>, default:                 <code>298.15</code> )         \u2013          <p>Temperature in Kelvins.</p> </li> <li> pressure             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Pressure in bar.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>dictionary of custom kwargs for the xTB calculator.</p> </li> <li> vib_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>dictionary of custom kwargs for the Vibrations object.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_vib_run and quacc.schemas.ase.summarize_thermo</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/tblite/core.py</code> <pre><code>@job\n@requires(TBLite, \"tblite must be installed. Try pip install tblite[ase]\")\ndef freq_job(\natoms: Atoms | dict,\nmethod: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"] = \"GFN2-xTB\",\nenergy: float = 0.0,\ntemperature: float = 298.15,\npressure: float = 1.0,\ncalc_swaps: dict | None = None,\nvib_kwargs: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; FreqSchema:\n\"\"\"\n    Run a frequency job and calculate thermochemistry.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    method\n        GFN0-xTB, GFN1-xTB, GFN2-xTB, GFN-FF.\n    energy\n        Potential energy in eV. If 0, then the output is just the correction.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    calc_swaps\n        dictionary of custom kwargs for the xTB calculator.\n    vib_kwargs\n        dictionary of custom kwargs for the Vibrations object.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    dict\n        Dictionary of results from quacc.schemas.ase.summarize_vib_run and\n        quacc.schemas.ase.summarize_thermo\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\nvib_kwargs = vib_kwargs or {}\natoms.calc = TBLite(method=method, **calc_swaps)\nvibrations = run_ase_vib(atoms, vib_kwargs=vib_kwargs, copy_files=copy_files)\nvib_summary = summarize_vib_run(\nvibrations, additional_fields={\"name\": \"TBLite Frequency Analysis\"}\n)\nigt = ideal_gas(atoms, vibrations.get_frequencies(), energy=energy)\nvib_summary[\"thermo\"] = summarize_thermo(\nigt, temperature=temperature, pressure=pressure\n)\nreturn vib_summary\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\natoms,\nmethod=\"GFN2-xTB\",\nrelax_cell=False,\ncalc_swaps=None,\nopt_swaps=None,\ncopy_files=None,\n)\n</code></pre> <p>Relax a structure.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> method             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code>, default:                 <code>'GFN2-xTB'</code> )         \u2013          <p>GFN0-xTB, GFN1-xTB, GFN2-xTB.</p> </li> <li> relax_cell             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to relax the cell.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the tblite calculator.</p> </li> <li> opt_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for run_ase_opt</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/tblite/core.py</code> <pre><code>@job\n@requires(TBLite, \"tblite must be installed. Try pip install tblite[ase]\")\ndef relax_job(\natoms: Atoms | dict,\nmethod: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"] = \"GFN2-xTB\",\nrelax_cell: bool = False,\ncalc_swaps: dict | None = None,\nopt_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; OptSchema:\n\"\"\"\n    Relax a structure.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    method\n        GFN0-xTB, GFN1-xTB, GFN2-xTB.\n    relax_cell\n        Whether to relax the cell.\n    calc_swaps\n        Dictionary of custom kwargs for the tblite calculator.\n    opt_swaps\n        Dictionary of custom kwargs for run_ase_opt\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from quacc.schemas.ase.summarize_opt_run\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\nopt_swaps = opt_swaps or {}\nopt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\nopt_flags = merge_dicts(opt_defaults, opt_swaps)\natoms.calc = TBLite(method=method, **calc_swaps)\ndyn = run_ase_opt(atoms, relax_cell=relax_cell, copy_files=copy_files, **opt_flags)\nreturn summarize_opt_run(dyn, additional_fields={\"name\": \"TBLite Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.static_job","title":"static_job","text":"<pre><code>static_job(\natoms,\nmethod=\"GFN2-xTB\",\ncalc_swaps=None,\ncopy_files=None,\n)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> method             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code>, default:                 <code>'GFN2-xTB'</code> )         \u2013          <p>GFN1-xTB, GFN2-xTB, and IPEA1-xTB.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the tblite calculator.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/tblite/core.py</code> <pre><code>@job\n@requires(TBLite, \"tblite must be installed. Try pip install tblite[ase]\")\ndef static_job(\natoms: Atoms | dict,\nmethod: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"] = \"GFN2-xTB\",\ncalc_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    method\n        GFN1-xTB, GFN2-xTB, and IPEA1-xTB.\n    calc_swaps\n        Dictionary of custom kwargs for the tblite calculator.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from quacc.schemas.ase.summarize_run\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\natoms.calc = TBLite(method=method, **calc_swaps)\nfinal_atoms = run_calc(atoms, copy_files=copy_files)\nreturn summarize_run(\nfinal_atoms,\ninput_atoms=atoms,\nadditional_fields={\"name\": \"TBLite Static\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html","title":"core","text":"<p>Core recipes for VASP</p>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.double_relax_job","title":"double_relax_job","text":"<pre><code>double_relax_job(\natoms,\npreset=None,\nrelax_cell=True,\ncalc_swaps1=None,\ncalc_swaps2=None,\ncopy_files=None,\n)\n</code></pre> <p>double_relax a structure. This is particularly useful for a few reasons:</p> <ol> <li> <p>To carry out a cheaper pre-relaxation before the high-quality run.</p> </li> <li> <p>To carry out a GGA calculation before a meta-GGA or hybrid calculation that requires the GGA wavefunction.</p> </li> <li> <p>To carry out volume relaxations where large changes in volume can require a second relaxation to resolve forces.</p> </li> </ol> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> preset             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Preset to use.</p> </li> <li> relax_cell             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>True if a volume relaxation (ISIF = 3) should be performed. False if only the positions (ISIF = 2) should be updated.</p> </li> <li> calc_swaps1             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the first relaxation.</p> </li> <li> calc_swaps2             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the second relaxation.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the (first) runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>{'relax1': VaspSchema, 'relax2': VaspSchema}</code>         \u2013          <p>Dictionaries of the type quacc.schemas.vasp.summarize_run.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/core.py</code> <pre><code>@job\ndef double_relax_job(\natoms: Atoms | dict,\npreset: str | None = None,\nrelax_cell: bool = True,\ncalc_swaps1: dict | None = None,\ncalc_swaps2: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; DoubleRelaxSchema:\n\"\"\"\n    double_relax a structure. This is particularly useful for a few reasons:\n    1. To carry out a cheaper pre-relaxation before the high-quality run.\n    2. To carry out a GGA calculation before a meta-GGA or hybrid calculation\n    that requires the GGA wavefunction.\n    3. To carry out volume relaxations where large changes in volume\n    can require a second relaxation to resolve forces.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use.\n    relax_cell\n        True if a volume relaxation (ISIF = 3) should be performed.\n        False if only the positions (ISIF = 2) should be updated.\n    calc_swaps1\n        Dictionary of custom kwargs for the first relaxation.\n    calc_swaps2\n        Dictionary of custom kwargs for the second relaxation.\n    copy_files\n        Files to copy to the (first) runtime directory.\n    Returns\n    -------\n    {\"relax1\": VaspSchema, \"relax2\": VaspSchema}\n        Dictionaries of the type quacc.schemas.vasp.summarize_run.\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps1 = calc_swaps1 or {}\ncalc_swaps2 = calc_swaps2 or {}\n# Run first relaxation\nsummary1 = relax_job.undecorated(\natoms,\npreset=preset,\nrelax_cell=relax_cell,\ncalc_swaps=calc_swaps1,\ncopy_files=copy_files,\n)\n# Run second relaxation\nsummary2 = relax_job.undecorated(\nsummary1,\npreset=preset,\nrelax_cell=relax_cell,\ncalc_swaps=calc_swaps2,\ncopy_files=[\"WAVECAR\"],\n)\nsummary2[\"relax1\"] = summary1\nreturn summary2\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\natoms,\npreset=None,\nrelax_cell=True,\ncalc_swaps=None,\ncopy_files=None,\n)\n</code></pre> <p>Relax a structure.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> preset             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Preset to use.</p> </li> <li> relax_cell             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>True if a volume relaxation (ISIF = 3) should be performed. False if only the positions (ISIF = 2) should be updated.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/core.py</code> <pre><code>@job\ndef relax_job(\natoms: Atoms | dict,\npreset: str | None = None,\nrelax_cell: bool = True,\ncalc_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; VaspSchema:\n\"\"\"\n    Relax a structure.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use.\n    relax_cell\n        True if a volume relaxation (ISIF = 3) should be performed.\n        False if only the positions (ISIF = 2) should be updated.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from quacc.schemas.vasp.summarize_run\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"ediffg\": -0.02,\n\"isif\": 3 if relax_cell else 2,\n\"ibrion\": 2,\n\"isym\": 0,\n\"lcharg\": False,\n\"lwave\": False,\n\"nsw\": 200,\n}\nflags = merge_dicts(defaults, calc_swaps, remove_empties=False)\natoms.calc = Vasp(atoms, preset=preset, **flags)\natoms = run_calc(atoms, copy_files=copy_files)\nreturn summarize_run(atoms, additional_fields={\"name\": \"VASP Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.static_job","title":"static_job","text":"<pre><code>static_job(\natoms, preset=None, calc_swaps=None, copy_files=None\n)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> preset             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Preset to use.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/core.py</code> <pre><code>@job\ndef static_job(\natoms: Atoms | dict,\npreset: str | None = None,\ncalc_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; VaspSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from quacc.schemas.vasp.summarize_run\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"ismear\": -5,\n\"laechg\": True,\n\"lcharg\": True,\n\"lwave\": True,\n\"nedos\": 5001,\n\"nsw\": 0,\n}\nflags = merge_dicts(defaults, calc_swaps, remove_empties=False)\natoms.calc = Vasp(atoms, preset=preset, **flags)\natoms = run_calc(atoms, copy_files=copy_files)\nreturn summarize_run(atoms, additional_fields={\"name\": \"VASP Static\"})\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp.html","title":"mp","text":"<p>Materials Project-compatible recipes</p> <p>This set of recipes is meant to be compatible with the Materials Project Reference: https://doi.org/10.1103/PhysRevMaterials.6.013801</p>"},{"location":"reference/quacc/recipes/vasp/mp.html#quacc.recipes.vasp.mp.mp_prerelax_job","title":"mp_prerelax_job","text":"<pre><code>mp_prerelax_job(\natoms,\npreset=\"MPScanSet\",\ncalc_swaps=None,\ncopy_files=None,\n)\n</code></pre> <p>Function to pre-relax a structure with Materials Project settings. By default, this uses a PBEsol pre-relax step.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> preset             (<code>str | None</code>, default:                 <code>'MPScanSet'</code> )         \u2013          <p>Preset to use.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/mp.py</code> <pre><code>@job\ndef mp_prerelax_job(\natoms: Atoms | dict,\npreset: str | None = \"MPScanSet\",\ncalc_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; VaspSchema:\n\"\"\"\n    Function to pre-relax a structure with Materials Project settings.\n    By default, this uses a PBEsol pre-relax step.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from quacc.schemas.vasp.summarize_run\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\ndefaults = {\"ediffg\": -0.05, \"xc\": \"pbesol\"}\nflags = merge_dicts(defaults, calc_swaps, remove_empties=False)\natoms.calc = Vasp(atoms, preset=preset, **flags)\natoms = run_calc(atoms, copy_files=copy_files)\nreturn summarize_run(atoms, additional_fields={\"name\": \"MP-Prerelax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp.html#quacc.recipes.vasp.mp.mp_relax_flow","title":"mp_relax_flow","text":"<pre><code>mp_relax_flow(\natoms,\nprerelax=mp_prerelax_job,\nrelax=mp_relax_job,\nprerelax_kwargs=None,\nrelax_kwargs=None,\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>MP-compatible pre-relax</p> </li> <li> <p>MP-compatible relax</p> </li> </ol> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object for the structure.</p> </li> <li> prerelax             (<code>callable | None</code>, default:                 <code>mp_prerelax_job</code> )         \u2013          <p>Default to use for the pre-relaxation.</p> </li> <li> relax             (<code>callable | None</code>, default:                 <code>mp_relax_job</code> )         \u2013          <p>Default to use for the relaxation.</p> </li> <li> prerelax_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the pre-relaxation calculation.</p> </li> <li> relax_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/mp.py</code> <pre><code>@job\ndef mp_relax_flow(\natoms: Atoms | dict,\nprerelax: callable | None = mp_prerelax_job,\nrelax: callable | None = mp_relax_job,\nprerelax_kwargs: dict | None = None,\nrelax_kwargs: dict | None = None,\n) -&gt; MPRelaxFlowSchema:\n\"\"\"\n    Workflow consisting of:\n    1. MP-compatible pre-relax\n    2. MP-compatible relax\n    Parameters\n    ----------\n    atoms\n        Atoms object for the structure.\n    prerelax\n        Default to use for the pre-relaxation.\n    relax\n        Default to use for the relaxation.\n    prerelax_kwargs\n        Additional keyword arguments to pass to the pre-relaxation calculation.\n    relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    Returns\n    -------\n    VaspSchema\n        Dictionary results from quacc.schemas.vasp.summarize_run\n    \"\"\"\nprerelax_kwargs = prerelax_kwargs or {}\nrelax_kwargs = relax_kwargs or {}\n# Run the prerelax\nprerelax_results = prerelax.undecorated(atoms, **prerelax_kwargs)\n# Update KSPACING arguments\nbandgap = prerelax_results[\"output\"].get(\"bandgap\", 0)\nif bandgap &lt; 1e-4:\nkspacing_swaps = {\"kspacing\": 0.22, \"sigma\": 0.2, \"ismear\": 2}\nelse:\nrmin = 25.22 - 2.87 * bandgap\nkspacing = 2 * np.pi * 1.0265 / (rmin - 1.0183)\nkspacing_swaps = {\"kspacing\": min(kspacing, 0.44), \"ismear\": -5, \"sigma\": 0.05}\nrelax_kwargs[\"calc_swaps\"] = kspacing_swaps | relax_kwargs.get(\"calc_swaps\", {})\n# Run the relax\nrelax_results = relax.undecorated(\nprerelax_results, copy_files=[\"WAVECAR\"], **relax_kwargs\n)\nrelax_results[\"prerelax\"] = prerelax_results\nreturn relax_results\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp.html#quacc.recipes.vasp.mp.mp_relax_job","title":"mp_relax_job","text":"<pre><code>mp_relax_job(\natoms,\npreset=\"MPScanSet\",\ncalc_swaps=None,\ncopy_files=None,\n)\n</code></pre> <p>Function to relax a structure with Materials Project settings. By default, this uses an r2SCAN relax step.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> preset             (<code>str | None</code>, default:                 <code>'MPScanSet'</code> )         \u2013          <p>Preset to use.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/mp.py</code> <pre><code>@job\ndef mp_relax_job(\natoms: Atoms | dict,\npreset: str | None = \"MPScanSet\",\ncalc_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; VaspSchema:\n\"\"\"\n    Function to relax a structure with Materials Project settings.\n    By default, this uses an r2SCAN relax step.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from quacc.schemas.vasp.summarize_run\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\natoms.calc = Vasp(atoms, preset=preset, **calc_swaps)\natoms = run_calc(atoms, copy_files=copy_files)\nreturn summarize_run(atoms, additional_fields={\"name\": \"MP-Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/qmof.html","title":"qmof","text":"<p>QMOF-compatible recipes</p> <p>This set of recipes is meant to be compatible with the QMOF Database workflow. Reference: https://doi.org/10.1016/j.matt.2021.02.015</p>"},{"location":"reference/quacc/recipes/vasp/qmof.html#quacc.recipes.vasp.qmof.qmof_relax_job","title":"qmof_relax_job","text":"<pre><code>qmof_relax_job(\natoms,\npreset=\"QMOFSet\",\nrelax_cell=True,\nrun_prerelax=True,\ncalc_swaps=None,\n)\n</code></pre> <p>Relax a structure in a multi-step process for increased computational efficiency. This is all done in a single compute job. Settings are such that they are compatible with the QMOF Database.</p> <ol> <li> <p>A \"pre-relaxation\" with BFGSLineSearch to resolve very high forces.</p> </li> <li> <p>Position relaxation with default ENCUT and coarse k-point grid.</p> </li> <li> <p>Optional: volume relaxation with coarse k-point grid.</p> </li> <li> <p>Double relaxation using production-quality settings.</p> </li> <li> <p>Static calculation.</p> </li> </ol> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> preset             (<code>str | None</code>, default:                 <code>'QMOFSet'</code> )         \u2013          <p>Preset to use. Applies for all jobs.</p> </li> <li> relax_cell             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>True if a volume relaxation should be performed. False if only the positions should be updated.</p> </li> <li> run_prerelax             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If True, a pre-relax will be carried out with BFGSLineSearch. Recommended if starting from hypothetical structures or materials with very high starting forces.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator. Applies for all jobs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary of results</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/qmof.py</code> <pre><code>@job\ndef qmof_relax_job(\natoms: Atoms | dict,\npreset: str | None = \"QMOFSet\",\nrelax_cell: bool = True,\nrun_prerelax: bool = True,\ncalc_swaps: dict | None = None,\n) -&gt; QMOFRelaxSchema:\n\"\"\"\n    Relax a structure in a multi-step process for increased\n    computational efficiency. This is all done in a single compute job.\n    Settings are such that they are compatible with the QMOF Database.\n    1. A \"pre-relaxation\" with BFGSLineSearch to resolve very high forces.\n    2. Position relaxation with default ENCUT and coarse k-point grid.\n    3. Optional: volume relaxation with coarse k-point grid.\n    4. Double relaxation using production-quality settings.\n    5. Static calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use. Applies for all jobs.\n    relax_cell\n        True if a volume relaxation should be performed.\n        False if only the positions should be updated.\n    run_prerelax\n        If True, a pre-relax will be carried out with BFGSLineSearch.\n        Recommended if starting from hypothetical structures or materials\n        with very high starting forces.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator. Applies for all jobs.\n    Returns\n    -------\n    dict\n        Dictionary of results\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\n# 1. Pre-relaxation\nif run_prerelax:\nsummary1 = _prerelax(atoms, preset, calc_swaps, fmax=5.0)\natoms = summary1[\"atoms\"]\n# 2. Position relaxation (loose)\nsummary2 = _loose_relax_positions(atoms, preset, calc_swaps)\natoms = summary2[\"atoms\"]\n# 3. Optional: Volume relaxation (loose)\nif relax_cell:\nsummary3 = _loose_relax_cell(atoms, preset, calc_swaps)\natoms = summary3[\"atoms\"]\n# 4. Double Relaxation\n# This is done for two reasons: a) because it can resolve repadding\n# issues when dV is large; b) because we can use LREAL = Auto for the\n# first relaxation and the default LREAL for the second.\nsummary4 = _double_relax(atoms, preset, calc_swaps, relax_cell=relax_cell)\natoms = summary4[1][\"atoms\"]\n# 5. Static Calculation\nsummary5 = _static(atoms, preset, calc_swaps)\nsummary5[\"prerelax_lowacc\"] = summary1 if run_prerelax else None\nsummary5[\"position_relax_lowacc\"] = summary2\nsummary5[\"volume_relax_lowacc\"] = summary3 if relax_cell else None\nsummary5[\"double_relax\"] = summary4\nreturn summary5\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html","title":"slabs","text":"<p>Recipes for slabs</p>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.bulk_to_slabs_flow","title":"bulk_to_slabs_flow","text":"<pre><code>bulk_to_slabs_flow(\natoms,\nmake_slabs_kwargs=None,\nslab_relax=slab_relax_job,\nslab_static=slab_static_job,\nslab_relax_kwargs=None,\nslab_static_kwargs=None,\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab generation</p> </li> <li> <p>Slab relaxations</p> </li> <li> <p>Slab statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> make_slabs_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to make_max_slabs_from_bulk()</p> </li> <li> slab_relax             (<code>callable</code>, default:                 <code>slab_relax_job</code> )         \u2013          <p>Default to use for the relaxation of the slab structures.</p> </li> <li> slab_static             (<code>callable | None</code>, default:                 <code>slab_static_job</code> )         \u2013          <p>Default to use for the static calculation of the slab structures.</p> </li> <li> slab_relax_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> <li> slab_static_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the static calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[VaspSchema]</code>         \u2013          <p>List of dictionary results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/slabs.py</code> <pre><code>@flow\ndef bulk_to_slabs_flow(\natoms: Atoms | dict,\nmake_slabs_kwargs: dict | None = None,\nslab_relax: callable = slab_relax_job,\nslab_static: callable | None = slab_static_job,\nslab_relax_kwargs: dict | None = None,\nslab_static_kwargs: dict | None = None,\n) -&gt; list[VaspSchema]:\n\"\"\"\n    Workflow consisting of:\n    1. Slab generation\n    2. Slab relaxations\n    3. Slab statics (optional)\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    make_slabs_kwargs\n        Additional keyword arguments to pass to make_max_slabs_from_bulk()\n    slab_relax\n        Default to use for the relaxation of the slab structures.\n    slab_static\n        Default to use for the static calculation of the slab structures.\n    slab_relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    slab_static_kwargs\n        Additional keyword arguments to pass to the static calculation.\n    Returns\n    -------\n    list[VaspSchema]\n        List of dictionary results from quacc.schemas.vasp.summarize_run\n    \"\"\"\nslab_relax_kwargs = slab_relax_kwargs or {}\nslab_static_kwargs = slab_static_kwargs or {}\nmake_slabs_kwargs = make_slabs_kwargs or {}\n@job\ndef _make_slabs(atoms):\natoms = fetch_atoms(atoms)\nreturn make_max_slabs_from_bulk(atoms, **make_slabs_kwargs)\n@subflow\ndef _relax_distributed(slabs):\nreturn [slab_relax(slab, **slab_relax_kwargs) for slab in slabs]\n@subflow\ndef _relax_and_static_distributed(slabs):\nreturn [\nslab_static(\nslab_relax(slab, **slab_relax_kwargs),\n**slab_static_kwargs,\n)\nfor slab in slabs\n]\nslabs = _make_slabs(atoms)\nif slab_static is None:\nreturn _relax_distributed(slabs)\nreturn _relax_and_static_distributed(slabs)\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.slab_relax_job","title":"slab_relax_job","text":"<pre><code>slab_relax_job(\natoms, preset=None, calc_swaps=None, copy_files=None\n)\n</code></pre> <p>Function to relax a slab.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> preset             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Preset to use.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/slabs.py</code> <pre><code>@job\ndef slab_relax_job(\natoms: Atoms | dict,\npreset: str | None = None,\ncalc_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; VaspSchema:\n\"\"\"\n    Function to relax a slab.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from quacc.schemas.vasp.summarize_run\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"auto_dipole\": True,\n\"ediffg\": -0.02,\n\"isif\": 2,\n\"ibrion\": 2,\n\"isym\": 0,\n\"lcharg\": False,\n\"lwave\": False,\n\"nsw\": 200,\n}\nflags = merge_dicts(defaults, calc_swaps, remove_empties=False)\natoms.calc = Vasp(atoms, preset=preset, **flags)\natoms = run_calc(atoms, copy_files=copy_files)\nreturn summarize_run(atoms, additional_fields={\"name\": \"VASP Slab Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.slab_static_job","title":"slab_static_job","text":"<pre><code>slab_static_job(\natoms, preset=None, calc_swaps=None, copy_files=None\n)\n</code></pre> <p>Function to carry out a single-point calculation on a slab.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> preset             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Preset to use.</p> </li> <li> calc_swaps             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>dictionary of custom kwargs for the calculator.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/slabs.py</code> <pre><code>@job\ndef slab_static_job(\natoms: Atoms | dict,\npreset: str | None = None,\ncalc_swaps: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; VaspSchema:\n\"\"\"\n    Function to carry out a single-point calculation on a slab.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use.\n    calc_swaps\n        dictionary of custom kwargs for the calculator.\n    copy_files\n        Files to copy to the runtime directory.\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from quacc.schemas.vasp.summarize_run\n    \"\"\"\natoms = fetch_atoms(atoms)\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"auto_dipole\": True,\n\"ismear\": -5,\n\"laechg\": True,\n\"lcharg\": True,\n\"lvhar\": True,\n\"lwave\": True,\n\"nedos\": 5001,\n\"nsw\": 0,\n}\nflags = merge_dicts(defaults, calc_swaps, remove_empties=False)\natoms.calc = Vasp(atoms, preset=preset, **flags)\natoms = run_calc(atoms, copy_files=copy_files)\nreturn summarize_run(atoms, additional_fields={\"name\": \"VASP Slab Static\"})\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.slab_to_ads_flow","title":"slab_to_ads_flow","text":"<pre><code>slab_to_ads_flow(\nslab,\nadsorbate,\nmake_ads_kwargs=None,\nslab_relax=slab_relax_job,\nslab_static=slab_static_job,\nslab_relax_kwargs=None,\nslab_static_kwargs=None,\n)\n</code></pre> <p>Workflow consisting of: 1. Slab-adsorbate generation 2. Slab-adsorbate relaxations 3. Slab-adsorbate statics (optional)</p> <p>Parameters:</p> <ul> <li> slab             (<code>Atoms</code>)         \u2013          <p>Atoms object for the slab structure.</p> </li> <li> adsorbate             (<code>Atoms</code>)         \u2013          <p>Atoms object for the adsorbate.</p> </li> <li> make_ads_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to make_adsorbate_structures()</p> </li> <li> slab_relax             (<code>callable</code>, default:                 <code>slab_relax_job</code> )         \u2013          <p>Default to use for the relaxation of the slab structure.</p> </li> <li> slab_static             (<code>callable | None</code>, default:                 <code>slab_static_job</code> )         \u2013          <p>Default to use for the static calculation of the slab structures.</p> </li> <li> slab_relax_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> <li> slab_static_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the static calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[VaspSchema]</code>         \u2013          <p>List of dictionaries of results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/slabs.py</code> <pre><code>@flow\ndef slab_to_ads_flow(\nslab: Atoms,\nadsorbate: Atoms,\nmake_ads_kwargs: dict | None = None,\nslab_relax: callable = slab_relax_job,\nslab_static: callable | None = slab_static_job,\nslab_relax_kwargs: dict | None = None,\nslab_static_kwargs: dict | None = None,\n) -&gt; list[VaspSchema]:\n\"\"\"\n    Workflow consisting of:\n    1. Slab-adsorbate generation\n    2. Slab-adsorbate relaxations\n    3. Slab-adsorbate statics (optional)\n    Parameters\n    ----------\n    slab\n        Atoms object for the slab structure.\n    adsorbate\n        Atoms object for the adsorbate.\n    make_ads_kwargs\n        Additional keyword arguments to pass to make_adsorbate_structures()\n    slab_relax\n        Default to use for the relaxation of the slab structure.\n    slab_static\n        Default to use for the static calculation of the slab structures.\n    slab_relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    slab_static_kwargs\n        Additional keyword arguments to pass to the static calculation.\n    Returns\n    -------\n    list[VaspSchema]\n        List of dictionaries of results from quacc.schemas.vasp.summarize_run\n    \"\"\"\nslab_relax_kwargs = slab_relax_kwargs or {}\nslab_static_kwargs = slab_static_kwargs or {}\nmake_ads_kwargs = make_ads_kwargs or {}\n@job\ndef _make_ads_slabs(atoms, adsorbate):\natoms = fetch_atoms(atoms)\nreturn make_adsorbate_structures(atoms, adsorbate, **make_ads_kwargs)\n@subflow\ndef _relax_distributed(slabs):\nreturn [slab_relax(slab, **slab_relax_kwargs) for slab in slabs]\n@subflow\ndef _relax_and_static_distributed(slabs):\nreturn [\nslab_static(\nslab_relax(slab, **slab_relax_kwargs),\n**slab_static_kwargs,\n)\nfor slab in slabs\n]\nads_slabs = _make_ads_slabs(slab, adsorbate)\nif slab_static is None:\nreturn _relax_distributed(ads_slabs)\nreturn _relax_and_static_distributed(ads_slabs)\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html","title":"ase","text":"<p>Schemas for storing ASE-based data</p>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_opt_run","title":"summarize_opt_run","text":"<pre><code>summarize_opt_run(\ndyn,\ntrajectory=None,\ncheck_convergence=None,\ncharge_and_multiplicity=None,\nprep_next_run=True,\nremove_empties=False,\nadditional_fields=None,\nstore=None,\n)\n</code></pre> <p>Get tabulated results from an ASE Atoms trajectory and store them in a database-friendly format. This is meant to be compatible with all calculator types.</p> <p>Parameters:</p> <ul> <li> dyn             (<code>Optimizer</code>)         \u2013          <p>ASE Optimizer object.</p> </li> <li> trajectory             (<code>Trajectory | list[Atoms]</code>, default:                 <code>None</code> )         \u2013          <p>ASE Trajectory object or list[Atoms] from reading a trajectory file. If None, the trajectory must be found in dyn.traj_atoms.</p> </li> <li> check_convergence             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to check the convergence of the calculation. Defaults to True in settings.</p> </li> <li> charge_and_multiplicity             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> prep_next_run             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> remove_empties             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to remove None values and empty lists/dicts from the task document.</p> </li> <li> additional_fields             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> store             (<code>Store | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):<ul> <li>builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version, description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")</li> </ul> </li> <li>dir_name: str = Field(None, description=\"Directory where the output is parsed\")</li> <li>input_structure: Molecule | Structure = Field(None, title = \"The Pymatgen Structure or Molecule object from  the input Atoms object if input_atoms is not None.\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")</li> <li>parameters: dict = Field(None, title = \"the parameters used to run the calculation.\")</li> <li>opt_parameters: dict = Field(None, title = \"the parameters used to run the optimization.\")</li> <li>results: dict = Field(None, title = \"The results from the calculation.\")</li> <li>trajectory: List[Atoms] = Trajectory of Atoms objects</li> <li>trajectory_results: List[dict] = List of ase.calc.results from the trajectory</li> </ul> <p>For periodic structures, the task document also has the following fields:</p> <ul> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the material.\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified  representation of the composition.\")</li> <li>density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")</li> <li>density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in  atoms per cm^3.\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the material.\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation  of the formula.\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the  formula.\")</li> <li>nelements: int = Field(None, description=\"Number of elements.\")</li> <li>nsites: int = Field(None, description=\"Total number of sites in the structure.\")</li> <li>structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if periodic  and store_pmg is True.\")</li> <li>symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")<ul> <li>symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")</li> <li>symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")</li> <li>symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")</li> <li>symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")</li> </ul> </li> <li>volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")</li> </ul> <p>For molecules that lack periodicity, the task document also has the following fields:</p> <ul> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in  the molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified  representation of the composition\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the molecule\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular  formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation  of the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the  formula.\")</li> <li>molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not  periodic and store_pmg is True.\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the molecule\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for  the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")<ul> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")</li> </ul> </li> </ul> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/ase.py</code> <pre><code>def summarize_opt_run(\ndyn: Optimizer,\ntrajectory: Trajectory | list[Atoms] = None,\ncheck_convergence: bool | None = None,\ncharge_and_multiplicity: tuple[int, int] | None = None,\nprep_next_run: bool = True,\nremove_empties: bool = False,\nadditional_fields: dict | None = None,\nstore: Store | None = None,\n) -&gt; OptSchema:\n\"\"\"\n    Get tabulated results from an ASE Atoms trajectory and store them in a database-friendly format.\n    This is meant to be compatible with all calculator types.\n    Parameters\n    ----------\n    dyn\n        ASE Optimizer object.\n    trajectory\n        ASE Trajectory object or list[Atoms] from reading a trajectory file.\n        If None, the trajectory must be found in dyn.traj_atoms.\n    check_convergence\n        Whether to check the convergence of the calculation. Defaults to True in settings.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.\n    prep_next_run\n        Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run\n        This clears out any attached calculator and moves the final magmoms to the initial magmoms.\n    remove_empties\n        Whether to remove None values and empty lists/dicts from the task document.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None, `SETTINGS.PRIMARY_STORE` will be used.\n    Returns\n    -------\n    dict\n        Dictionary representation of the task document with the following fields:\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):\n            - builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__, description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")\n        - dir_name: str = Field(None, description=\"Directory where the output is parsed\")\n        - input_structure: Molecule | Structure = Field(None, title = \"The Pymatgen Structure or Molecule object from\n         the input Atoms object if input_atoms is not None.\")\n        - nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")\n        - parameters: dict = Field(None, title = \"the parameters used to run the calculation.\")\n        - opt_parameters: dict = Field(None, title = \"the parameters used to run the optimization.\")\n        - results: dict = Field(None, title = \"The results from the calculation.\")\n        - trajectory: List[Atoms] = Trajectory of Atoms objects\n        - trajectory_results: List[dict] = List of ase.calc.results from the trajectory\n        For periodic structures, the task document also has the following fields:\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")\n        - composition: Composition = Field(None, description=\"Full composition for the material.\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified\n         representation of the composition.\")\n        - density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")\n        - density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in\n         atoms per cm^3.\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the material.\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation\n         of the formula.\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the\n         formula.\")\n        - nelements: int = Field(None, description=\"Number of elements.\")\n        - nsites: int = Field(None, description=\"Total number of sites in the structure.\")\n        - structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if periodic\n         and store_pmg is True.\")\n        - symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")\n            - symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")\n            - symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")\n            - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")\n            - symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")\n        - volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")\n        For molecules that lack periodicity, the task document also has the following fields:\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in\n         the molecule\")\n        - composition: Composition = Field(None, description=\"Full composition for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified\n         representation of the composition\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the molecule\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular\n         formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation\n         of the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the\n         formula.\")\n        - molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not\n         periodic and store_pmg is True.\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the molecule\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for\n         the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")\n    \"\"\"\ncheck_convergence = (\nSETTINGS.CHECK_CONVERGENCE if check_convergence is None else check_convergence\n)\nadditional_fields = additional_fields or {}\nopt_parameters = dyn.todict()\nif hasattr(dyn, \"fmax\"):\nopt_parameters = opt_parameters | {\"fmax\": dyn.fmax}\nstore = SETTINGS.PRIMARY_STORE if store is None else store\n# Check convergence\nis_converged = dyn.converged()\nif check_convergence and not is_converged:\nmsg = \"Optimization did not converge.\"\nraise ValueError(msg)\n# Get trajectory\nif not trajectory:\ntrajectory = (\ndyn.traj_atoms\nif hasattr(dyn, \"traj_atoms\")\nelse read(dyn.trajectory.filename, index=\":\")\n)\ninitial_atoms = trajectory[0]\nfinal_atoms = dyn.atoms.atoms if isinstance(dyn.atoms, Filter) else dyn.atoms\n# Get results\ntraj_results = {\n\"trajectory_results\": [atoms.calc.results for atoms in trajectory],\n\"trajectory\": [\natoms_to_metadata(atoms, charge_and_multiplicity=charge_and_multiplicity)\nfor atoms in trajectory\n],\n}\nresults = {\n\"results\": final_atoms.calc.results\n| {\"converged\": is_converged, \"nsteps\": dyn.get_number_of_steps()}\n}\n# Get the calculator inputs\nuri = get_uri(os.getcwd())\ninputs = {\n\"parameters\": dyn.atoms.calc.parameters,\n\"parameters_opt\": opt_parameters,\n\"nid\": uri.split(\":\")[0],\n\"dir_name\": \":\".join(uri.split(\":\")[1:]),\n}\ninput_atoms_db = atoms_to_metadata(\ninitial_atoms, charge_and_multiplicity=charge_and_multiplicity\n)\ninputs[\"input_structure\"] = input_atoms_db\n# Prepares the Atoms object for the next run by moving the\n# final magmoms to initial, clearing the calculator state,\n# and assigning the resulting Atoms object a unique ID.\nif prep_next_run:\nfinal_atoms = prep_next_run_(final_atoms)\n# Get tabulated properties of the structure itself\natoms_db = atoms_to_metadata(\nfinal_atoms, charge_and_multiplicity=charge_and_multiplicity\n)\n# Create a dictionary of the inputs/outputs\ntask_doc = clean_dict(\natoms_db | inputs | results | traj_results | additional_fields,\nremove_empties=remove_empties,\n)\nif store:\nresults_to_db(store, task_doc)\nreturn task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_run","title":"summarize_run","text":"<pre><code>summarize_run(\natoms,\ninput_atoms=None,\ncharge_and_multiplicity=None,\nprep_next_run=True,\nremove_empties=False,\nadditional_fields=None,\nstore=None,\n)\n</code></pre> <p>Get tabulated results from an Atoms object and calculator and store them in a database-friendly format. This is meant to be compatible with all calculator types.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>ASE Atoms following a calculation. A calculator must be attached.</p> </li> <li> input_atoms             (<code>Atoms | None</code>, default:                 <code>None</code> )         \u2013          <p>Input ASE Atoms object to store.</p> </li> <li> charge_and_multiplicity             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> prep_next_run             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> remove_empties             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to remove None values and empty lists/dicts from the task document.</p> </li> <li> additional_fields             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> store             (<code>Store | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):<ul> <li>builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version, description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")</li> </ul> </li> <li>dir_name: str = Field(None, description=\"Directory where the output is parsed\")</li> <li>input_structure: Molecule | Structure = Field(None, title = \"The Pymatgen Structure or Molecule object from  the input Atoms object if input_atoms is not None.\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")</li> <li>parameters: dict = Field(None, title = \"the parameters used to run the calculation.\")</li> <li>results: dict = Field(None, title = \"The results from the calculation.\")</li> </ul> <p>For periodic structures, the task document also has the following fields: - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\") - composition: Composition = Field(None, description=\"Full composition for the material.\") - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified  representation of the composition.\") - density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\") - density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in  atoms per cm^3.\") - elements: List[Element] = Field(None, description=\"List of elements in the material.\") - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation  of the formula.\") - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the  formula.\") - nelements: int = Field(None, description=\"Number of elements.\") - nsites: int = Field(None, description=\"Total number of sites in the structure.\") - structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if  periodic and store_pmg is True.\") - symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")     - symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")     - symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")     - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")     - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")     - symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\") - volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")</p> <p>For molecules that lack periodicity, the task document also has the following fields:</p> <ul> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the  molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified  representation of the composition\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the molecule\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular  formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of  the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the  formula.\")</li> <li>molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not  periodic and store_pmg is True.\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the molecule\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons  for the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")<ul> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")</li> </ul> </li> </ul> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/ase.py</code> <pre><code>def summarize_run(\natoms: Atoms,\ninput_atoms: Atoms | None = None,\ncharge_and_multiplicity: tuple[int, int] | None = None,\nprep_next_run: bool = True,\nremove_empties: bool = False,\nadditional_fields: dict | None = None,\nstore: Store | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Get tabulated results from an Atoms object and calculator and store them in a database-friendly format.\n    This is meant to be compatible with all calculator types.\n    Parameters\n    ----------\n    atoms\n        ASE Atoms following a calculation. A calculator must be attached.\n    input_atoms\n        Input ASE Atoms object to store.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.\n    prep_next_run\n        Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run\n        This clears out any attached calculator and moves the final magmoms to the initial magmoms.\n    remove_empties\n        Whether to remove None values and empty lists/dicts from the task document.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None, `SETTINGS.PRIMARY_STORE` will be used.\n    Returns\n    -------\n    dict\n        Dictionary representation of the task document with the following fields:\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):\n            - builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__, description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")\n        - dir_name: str = Field(None, description=\"Directory where the output is parsed\")\n        - input_structure: Molecule | Structure = Field(None, title = \"The Pymatgen Structure or Molecule object from\n         the input Atoms object if input_atoms is not None.\")\n        - nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")\n        - parameters: dict = Field(None, title = \"the parameters used to run the calculation.\")\n        - results: dict = Field(None, title = \"The results from the calculation.\")\n        For periodic structures, the task document also has the following fields:\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")\n        - composition: Composition = Field(None, description=\"Full composition for the material.\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified\n         representation of the composition.\")\n        - density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")\n        - density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in\n         atoms per cm^3.\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the material.\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation\n         of the formula.\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the\n         formula.\")\n        - nelements: int = Field(None, description=\"Number of elements.\")\n        - nsites: int = Field(None, description=\"Total number of sites in the structure.\")\n        - structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if\n         periodic and store_pmg is True.\")\n        - symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")\n            - symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")\n            - symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")\n            - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")\n            - symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")\n        - volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")\n        For molecules that lack periodicity, the task document also has the following fields:\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the\n         molecule\")\n        - composition: Composition = Field(None, description=\"Full composition for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified\n         representation of the composition\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the molecule\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular\n         formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of\n         the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the\n         formula.\")\n        - molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not\n         periodic and store_pmg is True.\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the molecule\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons\n         for the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")\n    \"\"\"\n# Make sure there is a calculator with results\nif not atoms.calc:\nmsg = \"ASE Atoms object has no attached calculator.\"\nraise ValueError(msg)\nif not atoms.calc.results:\nmsg = \"ASE Atoms object's calculator has no results.\"\nraise ValueError(msg)\nstore = SETTINGS.PRIMARY_STORE if store is None else store\nadditional_fields = additional_fields or {}\n# Fetch all tabulated results from the attached calculator\nresults = {\"results\": atoms.calc.results}\n# Get the calculator inputs\nuri = get_uri(os.getcwd())\ninputs = {\n\"parameters\": atoms.calc.parameters,\n\"nid\": uri.split(\":\")[0],\n\"dir_name\": \":\".join(uri.split(\":\")[1:]),\n}\nif input_atoms:\ninput_atoms_db = atoms_to_metadata(\ninput_atoms, charge_and_multiplicity=charge_and_multiplicity\n)\ninputs[\"input_atoms\"] = input_atoms_db\n# Prepares the Atoms object for the next run by moving the\n# final magmoms to initial, clearing the calculator state,\n# and assigning the resulting Atoms object a unique ID.\nif prep_next_run:\natoms = prep_next_run_(atoms)\n# Get tabulated properties of the structure itself\natoms_db = atoms_to_metadata(atoms, charge_and_multiplicity=charge_and_multiplicity)\n# Create a dictionary of the inputs/outputs\ntask_doc = clean_dict(\natoms_db | inputs | results | additional_fields, remove_empties=remove_empties\n)\nif store:\nresults_to_db(store, task_doc)\nreturn task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_thermo","title":"summarize_thermo","text":"<pre><code>summarize_thermo(\nigt,\ntemperature=298.15,\npressure=1.0,\ncharge_and_multiplicity=None,\nremove_empties=False,\nadditional_fields=None,\nstore=None,\n)\n</code></pre> <p>Get tabulated results from an ASE IdealGasThermo object and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> igt             (<code>IdealGasThermo</code>)         \u2013          <p>ASE IdealGasThermo object.</p> </li> <li> temperature             (<code>float</code>, default:                 <code>298.15</code> )         \u2013          <p>Temperature in Kelvins.</p> </li> <li> pressure             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Pressure in bar.</p> </li> <li> charge_and_multiplicity             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> remove_empties             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to remove None values and empty lists/dicts from the task document.</p> </li> <li> additional_fields             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> store             (<code>Store | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):<ul> <li>builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version, description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")</li> </ul> </li> <li>dir_name: str = Field(None, description=\"Directory where the output is parsed\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")</li> <li>thermo_parameters: dict = Field(None, title = \"the parameters used to run the thermo calculation.\")<ul> <li>thermo_parameters.temperature: float = Temperature in Kelvins</li> <li>thermo_parameters.pressure: float = Pressure in bar</li> <li>thermo_parameters.sigma: float = The rotational symmetry number of the molecule</li> <li>thermo_parameters.spin_multiplicity: int = The spin multiplicity of the molecule</li> <li>thermo_parameters.vib_freqs: List[float] = Vibrational frequencies in cm^-1 used for the thermo calculation</li> <li>thermo_parameters.vib_energies: List[float] = Vibrational energies in eV used for the thermo calculation</li> <li>thermo_parameters.n_imag: int = Number of imaginary vibrational frequencies ignored in the thermo calculation</li> </ul> </li> <li>results: dict = Field(None, title = \"The results from the calculation.\")<ul> <li>results.energy: float = The potential energy of the system in eV</li> <li>results.enthalpy: float = The enthalpy of the system in eV</li> <li>results.entropy: float = The entropy of the system in eV/K</li> <li>results.gibbs_energy: float = The Gibbs free energy of the system in eV</li> <li>results.zpe: float = The zero point vibrational energy of the system in eV</li> </ul> </li> </ul> <p>The task document also has the following fields from the Molecule object:</p> <ul> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the  molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified  representation of the composition\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the molecule\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular  formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of  the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the  formula.\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the molecule\")</li> <li>molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not  periodic and store_pmg is True.\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for  the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")<ul> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")</li> </ul> </li> </ul> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/ase.py</code> <pre><code>def summarize_thermo(\nigt: IdealGasThermo,\ntemperature: float = 298.15,\npressure: float = 1.0,\ncharge_and_multiplicity: tuple[int, int] | None = None,\nremove_empties: bool = False,\nadditional_fields: dict | None = None,\nstore: Store | None = None,\n) -&gt; ThermoSchema:\n\"\"\"\n    Get tabulated results from an ASE IdealGasThermo object and store them in a database-friendly format.\n    Parameters\n    ----------\n    igt\n        ASE IdealGasThermo object.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.\n    remove_empties\n        Whether to remove None values and empty lists/dicts from the task document.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None, `SETTINGS.PRIMARY_STORE` will be used.\n    Returns\n    -------\n    dict\n        Dictionary representation of the task document with the following fields:\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):\n            - builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__, description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")\n        - dir_name: str = Field(None, description=\"Directory where the output is parsed\")\n        - nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")\n        - thermo_parameters: dict = Field(None, title = \"the parameters used to run the thermo calculation.\")\n            - thermo_parameters.temperature: float = Temperature in Kelvins\n            - thermo_parameters.pressure: float = Pressure in bar\n            - thermo_parameters.sigma: float = The rotational symmetry number of the molecule\n            - thermo_parameters.spin_multiplicity: int = The spin multiplicity of the molecule\n            - thermo_parameters.vib_freqs: List[float] = Vibrational frequencies in cm^-1 used for the thermo calculation\n            - thermo_parameters.vib_energies: List[float] = Vibrational energies in eV used for the thermo calculation\n            - thermo_parameters.n_imag: int = Number of imaginary vibrational frequencies ignored in the thermo calculation\n        - results: dict = Field(None, title = \"The results from the calculation.\")\n            - results.energy: float = The potential energy of the system in eV\n            - results.enthalpy: float = The enthalpy of the system in eV\n            - results.entropy: float = The entropy of the system in eV/K\n            - results.gibbs_energy: float = The Gibbs free energy of the system in eV\n            - results.zpe: float = The zero point vibrational energy of the system in eV\n        The task document also has the following fields from the Molecule object:\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the\n         molecule\")\n        - composition: Composition = Field(None, description=\"Full composition for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified\n         representation of the composition\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the molecule\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular\n         formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of\n         the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the\n         formula.\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the molecule\")\n        - molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not\n         periodic and store_pmg is True.\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for\n         the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")\n    \"\"\"\nadditional_fields = additional_fields or {}\nstore = SETTINGS.PRIMARY_STORE if store is None else store\nuri = get_uri(os.getcwd())\nspin_multiplicity = int(2 * igt.spin + 1)\ninputs = {\n\"parameters_thermo\": {\n\"temperature\": temperature,\n\"pressure\": pressure,\n\"sigma\": igt.sigma,\n\"spin_multiplicity\": spin_multiplicity,\n\"vib_freqs\": [e / units.invcm for e in igt.vib_energies],\n\"vib_energies\": igt.vib_energies.tolist(),\n\"n_imag\": igt.n_imag,\n},\n\"nid\": uri.split(\":\")[0],\n\"dir_name\": \":\".join(uri.split(\":\")[1:]),\n}\nresults = {\n\"results\": {\n\"energy\": igt.potentialenergy,\n\"enthalpy\": igt.get_enthalpy(temperature, verbose=True),\n\"entropy\": igt.get_entropy(temperature, pressure * 10**5, verbose=True),\n\"gibbs_energy\": igt.get_gibbs_energy(\ntemperature, pressure * 10**5, verbose=True\n),\n\"zpe\": igt.get_ZPE_correction(),\n}\n}\nif charge_and_multiplicity and spin_multiplicity != charge_and_multiplicity[1]:\nwarnings.warn(\n\"The IdealGasThermo spin multiplicity does not match the user-specified multiplicity.\",\nUserWarning,\n)\natoms_db = atoms_to_metadata(\nigt.atoms, charge_and_multiplicity=charge_and_multiplicity\n)\ntask_doc = clean_dict(\natoms_db | inputs | results | additional_fields, remove_empties=remove_empties\n)\nif store:\nresults_to_db(store, task_doc)\nreturn task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_vib_run","title":"summarize_vib_run","text":"<pre><code>summarize_vib_run(\nvib,\ncharge_and_multiplicity=None,\nremove_empties=False,\nadditional_fields=None,\nstore=None,\n)\n</code></pre> <p>Get tabulated results from an ASE Vibrations object and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> vib             (<code>Vibrations</code>)         \u2013          <p>ASE Vibrations object.</p> </li> <li> charge_and_multiplicity             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> remove_empties             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to remove None values and empty lists/dicts from the task document.</p> </li> <li> additional_fields             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> store             (<code>Store | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):<ul> <li>builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version, description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")</li> </ul> </li> <li>dir_name: str = Field(None, description=\"Directory where the output is parsed\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")</li> <li>parameters: dict = Field(None, title = \"the parameters used to run the calculation.\")</li> <li>vib_parameters: dict = Field(None, title = \"the parameters used to run the vibrations.\")<ul> <li>vib_parameters.delta: float = the Vibrations delta value</li> <li>vib_parameters.direction: str = the Vibrations direction value</li> <li>vib_parameters.method: str = the Vibrations method value</li> <li>vib_parameters.ndof: int = the Vibrations ndof value</li> <li>vib_parameters.nfree: int = the Vibrations nfree value</li> </ul> </li> <li>results: dict = Field(None, title = \"The results from the calculation.\")<ul> <li>results.imag_vib_freqs: List[float] = Imaginary vibrational frequencies in cm^-1</li> <li>results.n_imag: int = Number of imaginary vibrational frequencies</li> <li>results.vib_energies: List[float] = Vibrational energies in eV. 3N-5 or 3N-6 for molecules; 3N for solids.</li> <li>results.vib_freqs: List[float] = Vibrational frequencies in cm^-1. 3N-5 or 3N-6 for molecules; 3N for solids.</li> <li>results.vib_energies_raw: List[float] = Vibrational energies in eV of length 3N.</li> <li>results.vib_freqs_raw: List[float] = Vibrational frequencies in cm^-1 of length 3N.</li> </ul> </li> </ul> <p>For periodic structures, the task document also has the following fields:</p> <ul> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the material.\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified  representation of the composition.\")</li> <li>density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")</li> <li>density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms  per cm^3.\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the material.\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the  formula.\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the  formula.\")</li> <li>nelements: int = Field(None, description=\"Number of elements.\")</li> <li>nsites: int = Field(None, description=\"Total number of sites in the structure.\")</li> <li>structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if periodic  and store_pmg is True.\")</li> <li>symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")<ul> <li>symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")</li> <li>symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")</li> <li>symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")</li> <li>symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")</li> </ul> </li> <li>volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")</li> </ul> <p>For molecules that lack periodicity, the task document also has the following fields:</p> <ul> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the  molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified  representation of the composition\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the molecule\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular  formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of  the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the  formula.\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the molecule\")</li> <li>molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not  periodic and store_pmg is True.\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for  the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")<ul> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")</li> </ul> </li> </ul> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/ase.py</code> <pre><code>def summarize_vib_run(\nvib: Vibrations,\ncharge_and_multiplicity: tuple[int, int] | None = None,\nremove_empties: bool = False,\nadditional_fields: dict | None = None,\nstore: Store | None = None,\n) -&gt; VibSchema:\n\"\"\"\n    Get tabulated results from an ASE Vibrations object and store them in a database-friendly format.\n    Parameters\n    ----------\n    vib\n        ASE Vibrations object.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.\n    remove_empties\n        Whether to remove None values and empty lists/dicts from the task document.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None, `SETTINGS.PRIMARY_STORE` will be used.\n    Returns\n    -------\n    dict\n        Dictionary representation of the task document with the following fields:\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):\n            - builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__, description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")\n        - dir_name: str = Field(None, description=\"Directory where the output is parsed\")\n        - nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")\n        - parameters: dict = Field(None, title = \"the parameters used to run the calculation.\")\n        - vib_parameters: dict = Field(None, title = \"the parameters used to run the vibrations.\")\n            - vib_parameters.delta: float = the Vibrations delta value\n            - vib_parameters.direction: str = the Vibrations direction value\n            - vib_parameters.method: str = the Vibrations method value\n            - vib_parameters.ndof: int = the Vibrations ndof value\n            - vib_parameters.nfree: int = the Vibrations nfree value\n        - results: dict = Field(None, title = \"The results from the calculation.\")\n            - results.imag_vib_freqs: List[float] = Imaginary vibrational frequencies in cm^-1\n            - results.n_imag: int = Number of imaginary vibrational frequencies\n            - results.vib_energies: List[float] = Vibrational energies in eV. 3N-5 or 3N-6 for molecules; 3N for solids.\n            - results.vib_freqs: List[float] = Vibrational frequencies in cm^-1. 3N-5 or 3N-6 for molecules; 3N for solids.\n            - results.vib_energies_raw: List[float] = Vibrational energies in eV of length 3N.\n            - results.vib_freqs_raw: List[float] = Vibrational frequencies in cm^-1 of length 3N.\n        For periodic structures, the task document also has the following fields:\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")\n        - composition: Composition = Field(None, description=\"Full composition for the material.\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified\n         representation of the composition.\")\n        - density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")\n        - density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms\n         per cm^3.\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the material.\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the\n         formula.\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the\n         formula.\")\n        - nelements: int = Field(None, description=\"Number of elements.\")\n        - nsites: int = Field(None, description=\"Total number of sites in the structure.\")\n        - structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if periodic\n         and store_pmg is True.\")\n        - symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")\n            - symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")\n            - symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")\n            - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")\n            - symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")\n        - volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")\n        For molecules that lack periodicity, the task document also has the following fields:\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the\n         molecule\")\n        - composition: Composition = Field(None, description=\"Full composition for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified\n         representation of the composition\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the molecule\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular\n         formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of\n         the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the\n         formula.\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the molecule\")\n        - molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not\n         periodic and store_pmg is True.\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for\n         the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")\n    \"\"\"\nadditional_fields = additional_fields or {}\nstore = SETTINGS.PRIMARY_STORE if store is None else store\nvib_freqs_raw = vib.get_frequencies().tolist()\nvib_energies_raw = vib.get_energies().tolist()\natoms = vib._atoms if isinstance(vib, VibrationsData) else vib.atoms\n# Convert imaginary modes to negative values for DB storage\nfor i, f in enumerate(vib_freqs_raw):\nif np.imag(f) &gt; 0:\nvib_freqs_raw[i] = -np.abs(f)\nvib_energies_raw[i] = -np.abs(vib_energies_raw[i])\nelse:\nvib_freqs_raw[i] = np.abs(f)\nvib_energies_raw[i] = np.abs(vib_energies_raw[i])\nuri = get_uri(os.getcwd())\ninputs = {\n\"parameters\": None\nif isinstance(vib, VibrationsData)\nelse atoms.calc.parameters,\n\"parameters_vib\": None\nif isinstance(vib, VibrationsData)\nelse {\n\"delta\": vib.delta,\n\"direction\": vib.direction,\n\"method\": vib.method,\n\"ndof\": vib.ndof,\n\"nfree\": vib.nfree,\n},\n\"nid\": uri.split(\":\")[0],\n\"dir_name\": \":\".join(uri.split(\":\")[1:]),\n}\natoms_db = atoms_to_metadata(atoms, charge_and_multiplicity=charge_and_multiplicity)\n# Get the true vibrational modes\nnatoms = len(atoms)\nif natoms == 1:\nvib_freqs = []\nvib_energies = []\nelif atoms.pbc.any():\nvib_freqs = vib_freqs_raw\nvib_energies = vib_energies_raw\nelse:\n# Sort by absolute value\nvib_freqs_raw_sorted = vib_freqs_raw.copy()\nvib_energies_raw_sorted = vib_energies_raw.copy()\nvib_freqs_raw_sorted.sort(key=np.abs)\nvib_energies_raw_sorted.sort(key=np.abs)\n# Cut the 3N-5 or 3N-6 modes based on their absolute value\nn_modes = 3 * natoms - 5 if atoms_db[\"symmetry\"][\"linear\"] else 3 * natoms - 6\nvib_freqs = vib_freqs_raw_sorted[-n_modes:]\nvib_energies = vib_energies_raw_sorted[-n_modes:]\nimag_vib_freqs = [f for f in vib_freqs if f &lt; 0]\nresults = {\n\"results\": {\n\"imag_vib_freqs\": imag_vib_freqs,\n\"n_imag\": len(imag_vib_freqs),\n\"vib_energies\": vib_energies,\n\"vib_freqs\": vib_freqs,\n\"vib_energies_raw\": vib_energies_raw,\n\"vib_freqs_raw\": vib_freqs_raw,\n}\n}\ntask_doc = clean_dict(\natoms_db | inputs | results | additional_fields, remove_empties=remove_empties\n)\nif store:\nresults_to_db(store, task_doc)\nreturn task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/atoms.html","title":"atoms","text":"<p>Schemas for storing metadata about Atoms objects</p>"},{"location":"reference/quacc/schemas/atoms.html#quacc.schemas.atoms.atoms_to_metadata","title":"atoms_to_metadata","text":"<pre><code>atoms_to_metadata(\natoms,\ncharge_and_multiplicity=None,\nget_metadata=True,\nstrip_info=False,\nstore_pmg=True,\nremove_empties=False,\nadditional_fields=None,\n)\n</code></pre> <p>Convert an ASE Atoms object to a dict suitable for storage in MongoDB.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>ASE Atoms object to store in {\"atoms\": atoms}</p> </li> <li> charge_and_multiplicity             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> get_metadata             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to store atoms metadata in the returned dict.</p> </li> <li> strip_info             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to strip the data from atoms.info in the returned {\"atoms\": atoms}. Note that this data will be stored in {\"atoms_info\": atoms.info} regardless</p> </li> <li> store_pmg             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to store the Pymatgen Structure/Molecule object in {\"structure\": Structure} or {\"molecule\": Molecule}, respectively.</p> </li> <li> remove_empties             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to remove None values and empty lists/dicts from the TaskDocument.</p> </li> <li> additional_fields             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the atoms object with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):<ul> <li>builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version, description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")</li> </ul> </li> </ul> <p>For periodic structures, the task document also has the following fields:</p> <ul> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the material.\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition.\")</li> <li>density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")</li> <li>density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms per cm^3.\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the material.\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula.\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")</li> <li>nelements: int = Field(None, description=\"Number of elements.\")</li> <li>nsites: int = Field(None, description=\"Total number of sites in the structure.\")</li> <li>structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if periodic and store_pmg is True.\")</li> <li>symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")<ul> <li>symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")</li> <li>symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")</li> <li>symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")</li> <li>symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")</li> </ul> </li> <li>volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")</li> </ul> <p>For molecules that lack periodicity, the task document also has the following fields:</p> <ul> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the molecule\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")</li> <li>molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not periodic and store_pmg is True.\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the molecule\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")<ul> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")</li> </ul> </li> </ul> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/atoms.py</code> <pre><code>def atoms_to_metadata(\natoms: Atoms,\ncharge_and_multiplicity: tuple[int, int] | None = None,\nget_metadata: bool = True,\nstrip_info: bool = False,\nstore_pmg: bool = True,\nremove_empties: bool = False,\nadditional_fields: dict | None = None,\n) -&gt; AtomsSchema:\n\"\"\"\n    Convert an ASE Atoms object to a dict suitable for storage in MongoDB.\n    Parameters\n    ----------\n    atoms\n        ASE Atoms object to store in {\"atoms\": atoms}\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.\n    get_metadata\n        Whether to store atoms metadata in the returned dict.\n    strip_info\n        Whether to strip the data from atoms.info in the returned {\"atoms\": atoms}.\n        Note that this data will be stored in {\"atoms_info\": atoms.info} regardless\n    store_pmg\n        Whether to store the Pymatgen Structure/Molecule object in {\"structure\": Structure}\n        or {\"molecule\": Molecule}, respectively.\n    remove_empties\n        Whether to remove None values and empty lists/dicts from the TaskDocument.\n    additional_fields\n        Additional fields to add to the document.\n    Returns\n    -------\n    dict\n        Dictionary representation of the atoms object with the following fields:\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):\n            - builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__, description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")\n        For periodic structures, the task document also has the following fields:\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")\n        - composition: Composition = Field(None, description=\"Full composition for the material.\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition.\")\n        - density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")\n        - density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms per cm^3.\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the material.\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula.\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")\n        - nelements: int = Field(None, description=\"Number of elements.\")\n        - nsites: int = Field(None, description=\"Total number of sites in the structure.\")\n        - structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if periodic and store_pmg is True.\")\n        - symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")\n            - symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")\n            - symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")\n            - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")\n            - symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")\n        - volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")\n        For molecules that lack periodicity, the task document also has the following fields:\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")\n        - composition: Composition = Field(None, description=\"Full composition for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the molecule\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")\n        - molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not periodic and store_pmg is True.\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the molecule\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")\n    \"\"\"\nadditional_fields = additional_fields or {}\natoms = copy_atoms(atoms)\nresults = {}\n# Get any charge or multiplicity keys\nif charge_and_multiplicity:\natoms.charge = charge_and_multiplicity[0]\natoms.spin_multiplicity = charge_and_multiplicity[1]\n# Strip the dummy atoms, if present\ndel atoms[[atom.index for atom in atoms if atom.symbol == \"X\"]]\n# Get Atoms metadata, if requested. emmet already has built-in tools for\n# generating pymatgen Structure/Molecule metadata, so we'll just use that.\nif get_metadata:\nif atoms.pbc.any():\nstruct = AseAtomsAdaptor().get_structure(atoms)\nmetadata = StructureMetadata().from_structure(struct).dict()\nif store_pmg:\nresults[\"structure\"] = struct\nelse:\nmol = AseAtomsAdaptor().get_molecule(atoms, charge_spin_check=False)\nmetadata = MoleculeMetadata().from_molecule(mol).dict()\nif store_pmg:\nresults[\"molecule\"] = mol\nmetadata[\"builder_meta\"][\"build_date\"] = str(\nmetadata[\"builder_meta\"][\"build_date\"]\n)\nelse:\nmetadata = {}\n# Copy the info flags as a separate entry in the DB for easy querying\nresults[\"atoms_info\"] = _quacc_sanitize(atoms.info)\n# Strip info if requested\nif strip_info:\natoms_no_info = copy_atoms(atoms)\natoms_no_info.info = {}\nresults[\"atoms\"] = atoms_no_info\nelse:\nresults[\"atoms\"] = atoms\n# Combine the metadata and results dictionaries\natoms_doc = metadata | results | additional_fields\nreturn clean_dict(atoms_doc, remove_empties=remove_empties)\n</code></pre>"},{"location":"reference/quacc/schemas/cclib.html","title":"cclib","text":"<p>Schemas for molecular DFT codes parsed by cclib</p>"},{"location":"reference/quacc/schemas/cclib.html#quacc.schemas.cclib.summarize_run","title":"summarize_run","text":"<pre><code>summarize_run(\natoms,\nlogfile_extensions,\ndir_path=None,\npop_analyses=None,\ncheck_convergence=None,\nprep_next_run=True,\nremove_empties=False,\nadditional_fields=None,\nstore=None,\n)\n</code></pre> <p>Get tabulated results from a molecular DFT run and store them in a database-friendly format. This is meant to be a general parser built on top of cclib.</p> <p>This document inherits from the following schemas: cclibTaskDocument (see below), emmet.core.structure.MoleculeMetadata, emmet.core.base.EmmetBaseModel.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>ASE Atoms object following a calculation.</p> </li> <li> logfile_extensions             (<code>str | list[str]</code>)         \u2013          <p>Possible extensions of the log file (e.g. \".log\", \".out\", \".txt\", \".chk\"). Note that only a partial match is needed. For instance, <code>.log</code> will match <code>.log.gz</code> and <code>.log.1.gz</code>. If multiple files with this extension are found, the one with the most recent change time will be used. For an exact match only, put in the full file name.</p> </li> <li> dir_path             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The path to the folder containing the calculation outputs. A value of None specifies the current working directory.</p> </li> <li> pop_analyses             (<code>list[Literal['cpsa', 'mpa', 'lpa', 'bickelhaupt', 'density', 'mbo', 'bader', 'ddec6', 'hirshfeld']] | None</code>, default:                 <code>None</code> )         \u2013          <p>The name(s) of any cclib post-processing analysis to run. Note that for bader, ddec6, and hirshfeld, a cube file (.cube, .cub) must reside in dir_path. Supports: \"cpsa\", \"mpa\", \"lpa\", \"bickelhaupt\", \"density\", \"mbo\", \"bader\", \"ddec6\", \"hirshfeld\".</p> </li> <li> check_convergence             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to throw an error if geometry optimization convergence is not reached.  Defaults to True in settings.</p> </li> <li> prep_next_run             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run. This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> remove_empties             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to remove None values and empty lists/dicts from the TaskDocument.</p> </li> <li> additional_fields             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> store             (<code>Store | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object obtained from atoms.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")</li> <li>attributes: Dict = Field(None, description=\"Computed properties and calculation outputs. See https://cclib.github.io/data_notes.html\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):<ul> <li>builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version, description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")</li> </ul> </li> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")</li> <li>dir_name: str = Field(None, description=\"Directory where the output is parsed\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the molecule\")</li> <li>energy: float = Field(None, description=\"Final total energy\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")</li> <li>logfile: str = Field(None, description=\"Path to the log file used in the post-processing analysis\")</li> <li>metadata: Dict = Field(None, description=\"Calculation metadata, including input parameters and runtime statistics. See https://cclib.github.io/data_notes.html#metadata\")</li> <li>molecule: Molecule = Field(None, description=\"Final output molecule from the task\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the molecule\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>parameters: dict = Field(None, title = \"The input parameters obtained from atoms.calc.parameters.\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")<ul> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")</li> </ul> </li> <li>tags: List[str] = Field(None, description=\"Optional tags for this task document\")</li> <li>task_label: str = Field(None, description=\"A description of the task\")</li> </ul> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/cclib.py</code> <pre><code>def summarize_run(\natoms: Atoms,\nlogfile_extensions: str | list[str],\ndir_path: str | None = None,\npop_analyses: list[\nLiteral[\n\"cpsa\",\n\"mpa\",\n\"lpa\",\n\"bickelhaupt\",\n\"density\",\n\"mbo\",\n\"bader\",\n\"ddec6\",\n\"hirshfeld\",\n]\n]\n| None = None,\ncheck_convergence: bool | None = None,\nprep_next_run: bool = True,\nremove_empties: bool = False,\nadditional_fields: dict | None = None,\nstore: Store | None = None,\n) -&gt; cclibSchema:\n\"\"\"\n    Get tabulated results from a molecular DFT run and store them in a database-friendly format.\n    This is meant to be a general parser built on top of cclib.\n    This document inherits from the following schemas: cclibTaskDocument (see below),\n    emmet.core.structure.MoleculeMetadata, emmet.core.base.EmmetBaseModel.\n    Parameters\n    ----------\n    atoms\n        ASE Atoms object following a calculation.\n    logfile_extensions\n        Possible extensions of the log file (e.g. \".log\", \".out\", \".txt\", \".chk\"). Note that\n        only a partial match is needed. For instance, `.log` will match `.log.gz` and `.log.1.gz`.\n        If multiple files with this extension are found, the one with the most recent change time\n        will be used. For an exact match only, put in the full file name.\n    dir_path\n        The path to the folder containing the calculation outputs. A value of None specifies the\n        current working directory.\n    pop_analyses\n        The name(s) of any cclib post-processing analysis to run. Note that for\n        bader, ddec6, and hirshfeld, a cube file (.cube, .cub) must reside in dir_path.\n        Supports: \"cpsa\", \"mpa\", \"lpa\", \"bickelhaupt\", \"density\", \"mbo\", \"bader\", \"ddec6\",\n        \"hirshfeld\".\n    check_convergence\n         Whether to throw an error if geometry optimization convergence is not reached.\n         Defaults to True in settings.\n    prep_next_run\n        Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run.\n        This clears out any attached calculator and moves the final magmoms to the initial magmoms.\n    remove_empties\n        Whether to remove None values and empty lists/dicts from the TaskDocument.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None, `SETTINGS.PRIMARY_STORE` will be used.\n    Returns\n    -------\n    dict\n        Dictionary representation of the task document with the following fields:\n        - atoms: Atoms = Field(None, title = \"The Atoms object obtained from atoms.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")\n        - attributes: Dict = Field(None, description=\"Computed properties and calculation outputs. See https://cclib.github.io/data_notes.html\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):\n            - builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__, description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")\n        - composition: Composition = Field(None, description=\"Full composition for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")\n        - dir_name: str = Field(None, description=\"Directory where the output is parsed\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the molecule\")\n        - energy: float = Field(None, description=\"Final total energy\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")\n        - logfile: str = Field(None, description=\"Path to the log file used in the post-processing analysis\")\n        - metadata: Dict = Field(None, description=\"Calculation metadata, including input parameters and runtime statistics. See https://cclib.github.io/data_notes.html#metadata\")\n        - molecule: Molecule = Field(None, description=\"Final output molecule from the task\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the molecule\")\n        - nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - parameters: dict = Field(None, title = \"The input parameters obtained from atoms.calc.parameters.\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")\n        - tags: List[str] = Field(None, description=\"Optional tags for this task document\")\n        - task_label: str = Field(None, description=\"A description of the task\")\n    \"\"\"\n# Make sure there is a calculator with results\nif not atoms.calc:\nmsg = \"ASE Atoms object has no attached calculator.\"\nraise ValueError(msg)\nif not atoms.calc.results:\nmsg = \"ASE Atoms object's calculator has no results.\"\nraise ValueError(msg)\nstore = SETTINGS.PRIMARY_STORE if store is None else store\n# Set defaults\ncheck_convergence = (\nSETTINGS.CHECK_CONVERGENCE if check_convergence is None else check_convergence\n)\nadditional_fields = additional_fields or {}\ndir_path = dir_path or os.getcwd()\n# Fortunately, there is already a cclib parser in Atomate2\nresults = _cclibTaskDocument.from_logfile(\ndir_path, logfile_extensions, store_trajectory=True, analysis=pop_analyses\n)\nuri = results[\"dir_name\"]\nresults[\"nid\"] = uri.split(\":\")[0]\nresults[\"dir_name\"] = \":\".join(uri.split(\":\")[1:])\nresults[\"builder_meta\"][\"build_date\"] = str(results[\"builder_meta\"][\"build_date\"])\nresults[\"logfile\"] = results[\"logfile\"].split(\":\")[-1]\nif results[\"attributes\"].get(\"trajectory\"):\nresults[\"attributes\"][\"trajectory\"] = [\natoms_to_metadata(AseAtomsAdaptor().get_atoms(molecule))\nfor molecule in results[\"attributes\"][\"trajectory\"]\n]\n# Check convergence if requested\nif check_convergence and results[\"attributes\"].get(\"optdone\") is False:\nmsg = \"Optimization not complete.\"\nraise ValueError(msg)\n# Get the calculator inputs\ninputs = {\"parameters\": atoms.calc.parameters}\n# Prepares the Atoms object for the next run by moving the\n# final magmoms to initial, clearing the calculator state,\n# and assigning the resulting Atoms object a unique ID.\nif prep_next_run:\natoms = prep_next_run_(atoms)\n# We use get_metadata=False and store_pmg=False because the TaskDocument already\n# makes the structure metadata for us\natoms_db = atoms_to_metadata(atoms, get_metadata=False, store_pmg=False)\n# Create a dictionary of the inputs/outputs\ntask_doc = clean_dict(\natoms_db | inputs | results | additional_fields,\nremove_empties=remove_empties,\n)\n# Store the results\nif store:\nresults_to_db(store, task_doc)\nreturn task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html","title":"vasp","text":"<p>Schemas for VASP</p>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.bader_runner","title":"bader_runner","text":"<pre><code>bader_runner(path=None, scratch_dir=None)\n</code></pre> <p>Runs a Bader partial charge and spin moment analysis using the VASP output files in the given path. This function requires that <code>bader</code> is located in your PATH environment variable. See http://theory.cm.utexas.edu/henkelman/code/bader for the bader code.</p> <p>Parameters:</p> <ul> <li> path             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The path where the VASP output files are located. Must include CHGCAR, AECCAR0, AECCAR2, and POTCAR files. These files can be gzip'd or not -- it doesn't matter. If None, the current working directory is used.</p> </li> <li> scratch_dir             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The path where the Bader analysis will be run. Defaults to SETTINGS.SCRATCH_DIR.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary containing the Bader analysis summary:     {         \"min_dist\": List[float],         \"atomic_volume\": List[float],         \"vacuum_charge\": float,         \"vacuum_volume\": float,         \"bader_version\": float,         \"partial_charges\": List[float],         \"spin_moments\": List[float],     }</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/vasp.py</code> <pre><code>def bader_runner(path: str | None = None, scratch_dir: str | None = None) -&gt; dict:\n\"\"\"\n    Runs a Bader partial charge and spin moment analysis using the VASP\n    output files in the given path. This function requires that `bader`\n    is located in your PATH environment variable. See\n    http://theory.cm.utexas.edu/henkelman/code/bader for the bader code.\n    Parameters\n    ----------\n    path\n        The path where the VASP output files are located.\n        Must include CHGCAR, AECCAR0, AECCAR2, and POTCAR files. These\n        files can be gzip'd or not -- it doesn't matter.\n        If None, the current working directory is used.\n    scratch_dir\n        The path where the Bader analysis will be run.\n        Defaults to SETTINGS.SCRATCH_DIR.\n    Returns\n    -------\n    dict\n        Dictionary containing the Bader analysis summary:\n            {\n                \"min_dist\": List[float],\n                \"atomic_volume\": List[float],\n                \"vacuum_charge\": float,\n                \"vacuum_volume\": float,\n                \"bader_version\": float,\n                \"partial_charges\": List[float],\n                \"spin_moments\": List[float],\n            }\n    \"\"\"\nscratch_dir = SETTINGS.SCRATCH_DIR if scratch_dir is None else scratch_dir\npath = path or os.getcwd()\n# Make sure files are present\nrelevant_files = [\"AECCAR0\", \"AECCAR2\", \"CHGCAR\", \"POTCAR\"]\nfor f in relevant_files:\nif not os.path.exists(os.path.join(path, f)) and not os.path.exists(\nos.path.join(path, f\"{f}.gz\")\n):\nmsg = f\"Could not find {f} in {path}.\"\nraise FileNotFoundError(msg)\n# Run Bader analysis\nwith TemporaryDirectory(dir=scratch_dir) as tmpdir:\ncopy_decompress(relevant_files, tmpdir)\nbader_stats = bader_analysis_from_path(path)\n# Store the partial charge, which is much more useful than the\n# raw charge and is more intuitive than the charge transferred.\n# An atom with a positive partial charge is cationic, whereas\n# an atom with a negative partial charge is anionic.\nbader_stats[\"partial_charges\"] = [-c for c in bader_stats[\"charge_transfer\"]]\n# Some cleanup of the returned dictionary\nif \"magmom\" in bader_stats:\nbader_stats[\"spin_moments\"] = bader_stats[\"magmom\"]\nbader_stats.pop(\"charge\", None)\nbader_stats.pop(\"charge_transfer\", None)\nbader_stats.pop(\"reference_used\", None)\nbader_stats.pop(\"magmom\", None)\nreturn bader_stats\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.chargemol_runner","title":"chargemol_runner","text":"<pre><code>chargemol_runner(\npath=None, atomic_densities_path=None, scratch_dir=None\n)\n</code></pre> <p>Runs a Chargemol (i.e. DDEC6 + CM5) analysis using the VASP output files in the given path. This function requires that the chargemol executable, given by the name <code>Chargemol_09_26_2017_linux_parallel</code>, <code>Chargemol_09_26_2017_linux_serial</code>, or <code>chargemol</code> is in the system PATH environment variable. See https://sourceforge.net/projects/ddec/files for the Chargemol code.</p> <p>Parameters:</p> <ul> <li> path             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The path where the VASP output files are located. Must include CHGCAR, AECCAR0, AECCAR2, and POTCAR files. These files can be gzip'd or not -- it doesn't matter. If None, the current working directory is used.</p> </li> <li> atomic_densities_path             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The path where the reference atomic densities are located for Chargemol. If None, we assume that this directory is defined in an environment variable named DDEC6_ATOMIC_DENSITIES_DIR. See the Chargemol documentation for more information.</p> </li> <li> scratch_dir             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The path where the Chargemol analysis will be run.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary containing the Chargemol analysis summary:     {         \"ddec\": {                     \"partial_charges\": List[float],                     \"spin_moments\": List[float],                     \"dipoles\": List[float],                     \"bond_order_sums\": List[float],                     \"bond_order_dict\": Dict                 },         \"cm5\": {                     \"partial_charges\": List[float],                 }     }</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/vasp.py</code> <pre><code>def chargemol_runner(\npath: str | None = None,\natomic_densities_path: str | None = None,\nscratch_dir: str | None = None,\n) -&gt; dict:\n\"\"\"\n    Runs a Chargemol (i.e. DDEC6 + CM5) analysis using the VASP output files\n    in the given path. This function requires that the chargemol executable,\n    given by the name `Chargemol_09_26_2017_linux_parallel`,\n    `Chargemol_09_26_2017_linux_serial`, or `chargemol` is in the system PATH\n    environment variable. See https://sourceforge.net/projects/ddec/files for\n    the Chargemol code.\n    Parameters\n    ----------\n    path\n        The path where the VASP output files are located.\n        Must include CHGCAR, AECCAR0, AECCAR2, and POTCAR files. These\n        files can be gzip'd or not -- it doesn't matter.\n        If None, the current working directory is used.\n    atomic_densities_path\n        The path where the reference atomic densities are located for Chargemol.\n        If None, we assume that this directory is defined in an environment variable\n        named DDEC6_ATOMIC_DENSITIES_DIR.\n        See the Chargemol documentation for more information.\n    scratch_dir\n        The path where the Chargemol analysis will be run.\n    Returns\n    -------\n    dict\n        Dictionary containing the Chargemol analysis summary:\n            {\n                \"ddec\": {\n                            \"partial_charges\": List[float],\n                            \"spin_moments\": List[float],\n                            \"dipoles\": List[float],\n                            \"bond_order_sums\": List[float],\n                            \"bond_order_dict\": Dict\n                        },\n                \"cm5\": {\n                            \"partial_charges\": List[float],\n                        }\n            }\n    \"\"\"\nscratch_dir = SETTINGS.SCRATCH_DIR if scratch_dir is None else scratch_dir\npath = path or os.getcwd()\n# Make sure files are present\nrelevant_files = [\"AECCAR0\", \"AECCAR2\", \"CHGCAR\", \"POTCAR\"]\nfor f in relevant_files:\nif not os.path.exists(os.path.join(path, f)) and not os.path.exists(\nos.path.join(path, f\"{f}.gz\")\n):\nmsg = f\"Could not find {f} in {path}.\"\nraise FileNotFoundError(msg)\n# Check environment variable\nif atomic_densities_path is None and \"DDEC6_ATOMIC_DENSITIES_DIR\" not in os.environ:\nmsg = \"DDEC6_ATOMIC_DENSITIES_DIR environment variable not defined.\"\nraise ValueError(msg)\n# Run Chargemol analysis\nwith TemporaryDirectory(dir=scratch_dir) as tmpdir:\ncopy_decompress(relevant_files, tmpdir)\nchargemol_stats = ChargemolAnalysis(\npath=path,\natomic_densities_path=atomic_densities_path,\n)\n# Some cleanup of the returned dictionary\nchargemol_stats.pop(\"rsquared_moments\", None)\nchargemol_stats.pop(\"rcubed_moments\", None)\nchargemol_stats.pop(\"rfourth_moments\", None)\nreturn chargemol_stats\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.summarize_run","title":"summarize_run","text":"<pre><code>summarize_run(\natoms,\ndir_path=None,\nprep_next_run=True,\nrun_bader=None,\ncheck_convergence=True,\nremove_empties=False,\nadditional_fields=None,\nstore=None,\n)\n</code></pre> <p>Get tabulated results from a VASP run and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>ASE Atoms object following a calculation.</p> </li> <li> dir_path             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Path to VASP outputs. A value of None specifies the current working directory</p> </li> <li> prep_next_run             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run. This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> run_bader             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether a Bader analysis should be performed. Will not run if bader executable is not in PATH even if bader is set to True. Defaults to VASP_BADER in settings.</p> </li> <li> check_convergence             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to throw an error if convergence is not reached.</p> </li> <li> remove_empties             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to remove None values and empty lists/dicts from the TaskDocument.</p> </li> <li> additional_fields             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> store             (<code>Store | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>analysis: AnalysisDoc = Field(None, title=\"Calculation Analysis\", description=\"Some analysis of calculation data after collection.\")<ul> <li>analysis.delta_volume: float = Field(None, title=\"Volume Change\", description=\"Volume change for the calculation.\")</li> <li>analysis.delta_volume_percent: float = Field(None, title=\"Volume Change Percent\", description=\"Percent volume change for the calculation.\")</li> <li>analysis.max_force: float = Field(None, title=\"Max Force\", description=\"Maximum force on any atom at the end of the calculation.\")</li> <li>analysis.warnings: List[str] = Field(None, title=\"Calculation Warnings\",description=\"Warnings issued after analysis.\")</li> <li>analysis.errors: List[str] = Field(None, title=\"Calculation Errors\", description=\"Errors issued after analysis.\")</li> </ul> </li> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):<ul> <li>builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")</li> <li>builder_meta.emmet_version: str = Field(version, description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")</li> </ul> </li> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the material.\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition.\")</li> <li>custodian: List[CustodianDoc] = Field(None, title=\"Calcs reversed data\", description=\"Detailed custodian data for each VASP calculation contributing to the task document.\")<ul> <li>custodian.corrections: List[Any] = Field(None, title=\"Custodian Corrections\", description=\"List of custodian correction data for calculation.\")</li> <li>custodian.job: dict = Field(None, title=\"Cusotodian Job Data\", description=\"Job data logged by custodian.\",)</li> </ul> </li> <li>density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")</li> <li>density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms per cm^3.\")</li> <li>dir_name: str = Field(None, description=\"The directory for this VASP task\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the material.\")</li> <li>entry: ComputedEntry = Field(None, description=\"The ComputedEntry from the task doc\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula.\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")</li> <li>input: InputDoc = Field(None, description=\"The input structure used to generate the current task document.\")<ul> <li>input.incar: Dict[str, Any] = Field(None, description=\"INCAR parameters for the calculation\")</li> <li>input.is_hubbard: bool = Field(False, description=\"Is this a Hubbard +U calculation\")</li> <li>input.kpoints: Union[Dict[str, Any], Kpoints] = Field(None, description=\"KPOINTS for the calculation\")</li> <li>input.hubbards: Dict = Field(None, description=\"The hubbard parameters used\")</li> <li>input.lattice_rec: Lattice = Field(None, description=\"Reciprocal lattice of the structure\")</li> <li>input.nkpoints: int = Field(None, description=\"Total number of k-points\")</li> <li>input.potcar: List[str] = Field(None, description=\"POTCAR symbols in the calculation\")</li> <li>input.potcar_spec: List[PotcarSpec] = Field(None, description=\"Title and hash of POTCAR files used in the calculation\")</li> <li>input.potcar_type: List[str] = Field(None, description=\"List of POTCAR functional types.\")</li> <li>input.parameters: Dict = Field(None, description=\"Parameters from vasprun\")</li> <li>input.structure: Structure = Field(None, description=\"Input structure for the calculation\")</li> </ul> </li> <li>nelements: int = Field(None, description=\"Number of elements.\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")</li> <li>nsites: int = Field(None, description=\"Total number of sites in the structure.\")</li> <li>orig_inputs: OrigInputs = Field(None, description=\"The exact set of input parameters used to generate the current task document.\")<ul> <li>orig_inputs.incar: Union[Incar, Dict] = Field(None, description=\"Pymatgen object representing the INCAR file.\")</li> <li>orig_inputs.poscar: Poscar = Field(None, description=\"Pymatgen object representing the POSCAR file.\")</li> <li>orig_inputs.kpoints: Kpoints = Field(None, description=\"Pymatgen object representing the KPOINTS file.\")</li> <li>orig_inputs.potcar: Union[Potcar, VaspPotcar, List[Any]] = Field(None, description=\"Pymatgen object representing the POTCAR file.\",)</li> </ul> </li> <li>output: OutputDoc = Field(None, description=\"The exact set of output parameters used to generate the current task document.\")<ul> <li>output.bandgap: float = Field(None, description=\"The DFT bandgap for the last calculation\")</li> <li>output.density: float = Field(..., description=\"Density of in units of g/cc.\")</li> <li>output.direct_gap: float = the direct bandgap (eV)</li> <li>output.dos_properties: DosProperties = Field(None, description=\"DOS properties for the material\")</li> <li>output.efermi: float = the fermi energy</li> <li>output.energy: float = Field(..., description=\"Total Energy in units of eV.\")</li> <li>output.energy_per_atom: float = Field(None, description=\"The final DFT energy per atom for the last calculation\")</li> <li>output.forces: List[List[float]] = Field(None, description=\"The force on each atom in units of eV/A^2.\")</li> <li>output.ionic_steps: float = the number of ionic steps</li> <li>output.is_gap_direct: bool = if the band gap is direct</li> <li>output.mag_density: float = magnetization density</li> <li>output.outcar: Outcar = Field(None, description=\"Pymatgen object representing the OUTCAR file.\")</li> <li>output.run_stats: Dict = Field(None, description=\"Runtime statistics from the calculation.\")</li> <li>output.stress: List[List[float]] = Field(None, description=\"The stress on the cell in units of kB.\")</li> <li>output.structure: Structure = Field(None, title=\"Output Structure\", description=\"Output Structure from the VASP calculation.\")</li> </ul> </li> <li>state: TaskState = Field(None, description=\"State of this calculation\")</li> <li>symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")<ul> <li>symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")</li> <li>symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")</li> <li>symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")</li> <li>symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")</li> <li>symmetry.version</li> </ul> </li> <li>vasp_version: str: the version of VASP</li> <li>volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")</li> </ul> <p>If run_bader is True, the following fields are added:</p> <ul> <li>bader<ul> <li>bader.atomic_volume: float = The atomic volume</li> <li>bader.bader_charge: float = The net bader charge</li> <li>bader.bader_spin: float = The net bader spin density</li> <li>bader.bader_version: float = The bader version</li> <li>bader.min_dist: List[float] = The bader min_dist parameter</li> <li>bader.partial_charges: List[float] = The atom-projected bader partial charges</li> <li>bader.spin_moments: List[float] = The atom-projected bader spin moments</li> </ul> </li> </ul> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/vasp.py</code> <pre><code>def summarize_run(\natoms: Atoms,\ndir_path: str | None = None,\nprep_next_run: bool = True,\nrun_bader: bool | None = None,\ncheck_convergence: bool = True,\nremove_empties: bool = False,\nadditional_fields: dict | None = None,\nstore: Store | None = None,\n) -&gt; VaspSchema:\n\"\"\"\n    Get tabulated results from a VASP run and store them in a database-friendly format.\n    Parameters\n    ----------\n    atoms\n        ASE Atoms object following a calculation.\n    dir_path\n        Path to VASP outputs. A value of None specifies the current working directory\n    prep_next_run\n        Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run.\n        This clears out any attached calculator and moves the final magmoms to the initial magmoms.\n    run_bader\n        Whether a Bader analysis should be performed. Will not run if bader executable is not in PATH even if\n        bader is set to True.\n        Defaults to VASP_BADER in settings.\n    check_convergence\n        Whether to throw an error if convergence is not reached.\n    remove_empties\n        Whether to remove None values and empty lists/dicts from the TaskDocument.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None, `SETTINGS.PRIMARY_STORE` will be used.\n    Returns\n    -------\n    dict\n        Dictionary representation of the task document with the following fields:\n        - analysis: AnalysisDoc = Field(None, title=\"Calculation Analysis\", description=\"Some analysis of calculation data after collection.\")\n            - analysis.delta_volume: float = Field(None, title=\"Volume Change\", description=\"Volume change for the calculation.\")\n            - analysis.delta_volume_percent: float = Field(None, title=\"Volume Change Percent\", description=\"Percent volume change for the calculation.\")\n            - analysis.max_force: float = Field(None, title=\"Max Force\", description=\"Maximum force on any atom at the end of the calculation.\")\n            - analysis.warnings: List[str] = Field(None, title=\"Calculation Warnings\",description=\"Warnings issued after analysis.\")\n            - analysis.errors: List[str] = Field(None, title=\"Calculation Errors\", description=\"Errors issued after analysis.\")\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):\n            - builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")\n            - builder_meta.emmet_version: str = Field(__version__, description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")\n        - composition: Composition = Field(None, description=\"Full composition for the material.\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition.\")\n        - custodian: List[CustodianDoc] = Field(None, title=\"Calcs reversed data\", description=\"Detailed custodian data for each VASP calculation contributing to the task document.\")\n            - custodian.corrections: List[Any] = Field(None, title=\"Custodian Corrections\", description=\"List of custodian correction data for calculation.\")\n            - custodian.job: dict = Field(None, title=\"Cusotodian Job Data\", description=\"Job data logged by custodian.\",)\n        - density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")\n        - density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms per cm^3.\")\n        - dir_name: str = Field(None, description=\"The directory for this VASP task\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the material.\")\n        - entry: ComputedEntry = Field(None, description=\"The ComputedEntry from the task doc\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula.\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")\n        - input: InputDoc = Field(None, description=\"The input structure used to generate the current task document.\")\n            - input.incar: Dict[str, Any] = Field(None, description=\"INCAR parameters for the calculation\")\n            - input.is_hubbard: bool = Field(False, description=\"Is this a Hubbard +U calculation\")\n            - input.kpoints: Union[Dict[str, Any], Kpoints] = Field(None, description=\"KPOINTS for the calculation\")\n            - input.hubbards: Dict = Field(None, description=\"The hubbard parameters used\")\n            - input.lattice_rec: Lattice = Field(None, description=\"Reciprocal lattice of the structure\")\n            - input.nkpoints: int = Field(None, description=\"Total number of k-points\")\n            - input.potcar: List[str] = Field(None, description=\"POTCAR symbols in the calculation\")\n            - input.potcar_spec: List[PotcarSpec] = Field(None, description=\"Title and hash of POTCAR files used in the calculation\")\n            - input.potcar_type: List[str] = Field(None, description=\"List of POTCAR functional types.\")\n            - input.parameters: Dict = Field(None, description=\"Parameters from vasprun\")\n            - input.structure: Structure = Field(None, description=\"Input structure for the calculation\")\n        - nelements: int = Field(None, description=\"Number of elements.\")\n        - nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")\n        - nsites: int = Field(None, description=\"Total number of sites in the structure.\")\n        - orig_inputs: OrigInputs = Field(None, description=\"The exact set of input parameters used to generate the current task document.\")\n            - orig_inputs.incar: Union[Incar, Dict] = Field(None, description=\"Pymatgen object representing the INCAR file.\")\n            - orig_inputs.poscar: Poscar = Field(None, description=\"Pymatgen object representing the POSCAR file.\")\n            - orig_inputs.kpoints: Kpoints = Field(None, description=\"Pymatgen object representing the KPOINTS file.\")\n            - orig_inputs.potcar: Union[Potcar, VaspPotcar, List[Any]] = Field(None, description=\"Pymatgen object representing the POTCAR file.\",)\n        - output: OutputDoc = Field(None, description=\"The exact set of output parameters used to generate the current task document.\")\n            - output.bandgap: float = Field(None, description=\"The DFT bandgap for the last calculation\")\n            - output.density: float = Field(..., description=\"Density of in units of g/cc.\")\n            - output.direct_gap: float = the direct bandgap (eV)\n            - output.dos_properties: DosProperties = Field(None, description=\"DOS properties for the material\")\n            - output.efermi: float = the fermi energy\n            - output.energy: float = Field(..., description=\"Total Energy in units of eV.\")\n            - output.energy_per_atom: float = Field(None, description=\"The final DFT energy per atom for the last calculation\")\n            - output.forces: List[List[float]] = Field(None, description=\"The force on each atom in units of eV/A^2.\")\n            - output.ionic_steps: float = the number of ionic steps\n            - output.is_gap_direct: bool = if the band gap is direct\n            - output.mag_density: float = magnetization density\n            - output.outcar: Outcar = Field(None, description=\"Pymatgen object representing the OUTCAR file.\")\n            - output.run_stats: Dict = Field(None, description=\"Runtime statistics from the calculation.\")\n            - output.stress: List[List[float]] = Field(None, description=\"The stress on the cell in units of kB.\")\n            - output.structure: Structure = Field(None, title=\"Output Structure\", description=\"Output Structure from the VASP calculation.\")\n        - state: TaskState = Field(None, description=\"State of this calculation\")\n        - symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")\n            - symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")\n            - symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")\n            - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")\n            - symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")\n            - symmetry.version\n        - vasp_version: str: the version of VASP\n        - volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")\n        If run_bader is True, the following fields are added:\n        - bader\n            - bader.atomic_volume: float = The atomic volume\n            - bader.bader_charge: float = The net bader charge\n            - bader.bader_spin: float = The net bader spin density\n            - bader.bader_version: float = The bader version\n            - bader.min_dist: List[float] = The bader min_dist parameter\n            - bader.partial_charges: List[float] = The atom-projected bader partial charges\n            - bader.spin_moments: List[float] = The atom-projected bader spin moments\n    \"\"\"\nadditional_fields = additional_fields or {}\nrun_bader = SETTINGS.VASP_BADER if run_bader is None else run_bader\ndir_path = dir_path or os.getcwd()\nstore = SETTINGS.PRIMARY_STORE if store is None else store\n# Fetch all tabulated results from VASP outputs files\n# Fortunately, emmet already has a handy function for this\nresults = TaskDoc.from_directory(dir_path).dict()\nuri = results[\"dir_name\"]\nresults[\"nid\"] = uri.split(\":\")[0]\nresults[\"dir_name\"] = \":\".join(uri.split(\":\")[1:])\nresults[\"builder_meta\"][\"build_date\"] = str(results[\"builder_meta\"][\"build_date\"])\n# Check for calculation convergence\nif check_convergence and results[\"state\"] != \"successful\":\nmsg = \"VASP calculation did not converge. Will not store task data.\"\nraise ValueError(msg)\n# Remove unnecessary fields\nfor k in [\n\"additional_json\",\n\"author\",\n\"calcs_reversed\",\n\"icsd_id\",\n\"last_updated\",\n\"structure\",  # already in output\n\"tags\",\n\"task_id\",\n\"task_label\",\n\"transformations\",\n\"vasp_objects\",\n]:\nresults.pop(k, None)\nif \"output\" in results:\nresults[\"output\"].pop(\"elph_displaced_structures\", None)\nresults[\"output\"].pop(\"frequency_dependent_dielectric\", None)\n# Get Bader analysis\nif run_bader:\ntry:\nbader_stats = bader_runner(dir_path)\nexcept Exception:\nbader_stats = None\nwarnings.warn(\"Bader analysis could not be performed.\", UserWarning)\nif bader_stats:\nresults[\"bader\"] = bader_stats\n# Attach bader charges/spins to structure object\nstruct = results[\"output\"][\"structure\"]\nstruct.add_site_property(\"bader_charge\", bader_stats[\"partial_charges\"])\nif \"spin_moments\" in bader_stats:\nstruct.add_site_property(\"bader_spin\", bader_stats[\"spin_moments\"])\nresults[\"output\"][\"structure\"] = struct\n# Prepares the Atoms object for the next run by moving the\n# final magmoms to initial, clearing the calculator state,\n# and assigning the resulting Atoms object a unique ID.\nif prep_next_run:\natoms = prep_next_run_(atoms)\n# We use get_metadata=False and store_pmg=False because the TaskDocument already\n# makes the structure metadata for us\natoms_db = atoms_to_metadata(atoms, get_metadata=False, store_pmg=False)\n# Make task document\ntask_doc = clean_dict(\nresults | atoms_db | additional_fields, remove_empties=remove_empties\n)\n# Store the results\nif store:\nresults_to_db(store, task_doc)\nreturn task_doc\n</code></pre>"},{"location":"reference/quacc/utils/atoms.html","title":"atoms","text":"<p>Utility functions for dealing with Atoms</p>"},{"location":"reference/quacc/utils/atoms.html#quacc.utils.atoms.check_charge_and_spin","title":"check_charge_and_spin","text":"<pre><code>check_charge_and_spin(\natoms, charge=None, spin_multiplicity=None\n)\n</code></pre> <p>Simple function to use the pymatgen molecule class to obtain and/or validate the multiplicity given the prescribed charge.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> charge             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Molecular charge</p> </li> <li> spin_multiplicity             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Molecular multiplicity</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>(charge, multiplicity)</code>         \u2013          </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/atoms.py</code> <pre><code>def check_charge_and_spin(\natoms: Atoms,\ncharge: int | None = None,\nspin_multiplicity: int | None = None,\n):\n\"\"\"\n    Simple function to use the pymatgen molecule class to obtain and/or\n    validate the multiplicity given the prescribed charge.\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Molecular charge\n    spin_multiplicity\n        Molecular multiplicity\n    Returns\n    -------\n    charge, multiplicity\n    \"\"\"\nif charge is None and spin_multiplicity is not None:\nraise ValueError(\"If setting spin_multiplicity, must also specify charge.\")\ntry:\nmol = AseAtomsAdaptor.get_molecule(atoms)\nif charge is not None:\nif spin_multiplicity is not None:\nmol.set_charge_and_spin(charge, spin_multiplicity)\nelse:\nmol.set_charge_and_spin(charge)\nexcept ValueError:\nmol = AseAtomsAdaptor.get_molecule(atoms, charge_spin_check=False)\nnelectrons = mol.nelectrons - charge if charge else mol.nelectrons\ndefault_spin_multiplicity = 1 if nelectrons % 2 == 0 else 2\nmol.set_charge_and_spin(\ncharge if charge is not None else mol.charge,\nspin_multiplicity\nif spin_multiplicity is not None\nelse default_spin_multiplicity,\n)\nif (mol.nelectrons + mol.spin_multiplicity) % 2 != 1:\nraise ValueError(\nf\"Charge of {mol.charge} and spin multiplicity of {mol.spin_multiplicity} is\"\n\" not possible for this molecule.\"\n)\nreturn mol.charge, mol.spin_multiplicity\n</code></pre>"},{"location":"reference/quacc/utils/atoms.html#quacc.utils.atoms.check_is_metal","title":"check_is_metal","text":"<pre><code>check_is_metal(atoms)\n</code></pre> <p>Checks if a structure is a likely metal.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if the structure is likely a metal; False otherwise</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/atoms.py</code> <pre><code>def check_is_metal(atoms: Atoms) -&gt; bool:\n\"\"\"\n    Checks if a structure is a likely metal.\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    Returns\n    -------\n    bool\n        True if the structure is likely a metal; False otherwise\n    \"\"\"\nif atoms.pbc.any():\nstruct = AseAtomsAdaptor.get_structure(atoms)\nelse:\nstruct = AseAtomsAdaptor.get_molecule(atoms)\nreturn all(k.is_metal for k in struct.composition)\n</code></pre>"},{"location":"reference/quacc/utils/atoms.html#quacc.utils.atoms.copy_atoms","title":"copy_atoms","text":"<pre><code>copy_atoms(atoms)\n</code></pre> <p>Simple function to copy an atoms object to prevent mutability.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>atoms</code>         \u2013          <p>Atoms object</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/atoms.py</code> <pre><code>def copy_atoms(atoms: Atoms) -&gt; Atoms:\n\"\"\"\n    Simple function to copy an atoms object to prevent mutability.\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    Returns\n    -------\n    atoms\n        Atoms object\n    \"\"\"\ntry:\natoms = deepcopy(atoms)\nexcept Exception:\n# Needed because of ASE issue #1084\ncalc = atoms.calc\natoms = atoms.copy()\natoms.calc = calc\nreturn atoms\n</code></pre>"},{"location":"reference/quacc/utils/atoms.html#quacc.utils.atoms.get_atoms_id","title":"get_atoms_id","text":"<pre><code>get_atoms_id(atoms)\n</code></pre> <p>Returns a unique ID for the Atoms object. Note: The .info dict and calculator is excluded from the hash generation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>md5hash</code>         \u2013          <p>MD5 hash of the Atoms object</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/atoms.py</code> <pre><code>def get_atoms_id(atoms: Atoms) -&gt; str:\n\"\"\"\n    Returns a unique ID for the Atoms object. Note: The .info dict\n    and calculator is excluded from the hash generation.\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    Returns\n    -------\n    md5hash\n        MD5 hash of the Atoms object\n    \"\"\"\natoms = copy_atoms(atoms)\natoms.info = {}\natoms.calc = None\nencoded_atoms = encode(atoms)\n# This is a hack to avoid int32/int64 and float32/float64 differences\n# between machines.\nencoded_atoms = (\nencoded_atoms.replace(\"int64\", \"int\")\n.replace(\"int32\", \"int\")\n.replace(\"float64\", \"float\")\n.replace(\"float32\", \"float\")\n)\nreturn hashlib.md5(encoded_atoms.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"reference/quacc/utils/atoms.html#quacc.utils.atoms.get_charge","title":"get_charge","text":"<pre><code>get_charge(atoms)\n</code></pre> <p>Get the (net) charge of an Atoms object. This is meant for molecules where the charge is a fixed property.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          <p>Charge of the Atoms object</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/atoms.py</code> <pre><code>def get_charge(atoms: Atoms) -&gt; int:\n\"\"\"\n    Get the (net) charge of an Atoms object. This is meant for molecules where the charge\n    is a fixed property.\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    Returns\n    -------\n    int\n        Charge of the Atoms object\n    \"\"\"\nreturn (\natoms.charge if atoms.has(\"charge\") else int(atoms.get_initial_charges().sum())\n)\n</code></pre>"},{"location":"reference/quacc/utils/atoms.html#quacc.utils.atoms.get_multiplicity","title":"get_multiplicity","text":"<pre><code>get_multiplicity(atoms)\n</code></pre> <p>Get the spin multiplicity of an Atoms object. This is meant for molecules where the spin multiplicity is a fixed property.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          <p>Charge of the Atoms object</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/atoms.py</code> <pre><code>def get_multiplicity(atoms: Atoms) -&gt; int:\n\"\"\"\n    Get the spin multiplicity of an Atoms object. This is meant for molecules where the spin\n    multiplicity is a fixed property.\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    Returns\n    -------\n    int\n        Charge of the Atoms object\n    \"\"\"\nreturn (\natoms.spin_multiplicity\nif atoms.has(\"spin_multiplicity\")\nelse int(1 + np.abs(atoms.get_initial_magnetic_moments()).sum())\n)\n</code></pre>"},{"location":"reference/quacc/utils/atoms.html#quacc.utils.atoms.prep_next_run","title":"prep_next_run","text":"<pre><code>prep_next_run(\natoms,\nassign_id=True,\nmove_magmoms=True,\nstore_results=False,\n)\n</code></pre> <p>Prepares the Atoms object for a new run.</p> <p>Depending on the arguments, this function will:     - Move the converged magnetic moments to the initial magnetic moments.     - Assign a unique ID to the Atoms object in atoms.info[\"_id\"]. Any existing IDs will     be moved to atoms.info[\"_old_ids\"].     - Store the calculator results in atoms.info[\"results\"] for later retrieval.     This makes it so the calculator results are not lost between     serialize/deserialize cycles, if desired. Each one will be stored in     atoms.info[\"results\"] = {\"calc0\": {}, \"calc1\": {}, ...} with higher numbers     being the most recent.</p> <p>In all cases, the calculator will be reset so new jobs can be run.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> assign_id             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to assign a unique ID to the Atoms object in atoms.info[\"_id\"]. Any existing IDs will be moved to atoms.info[\"_old_ids\"].</p> </li> <li> move_magmoms             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If True, move atoms.calc.results[\"magmoms\"] to atoms.get_initial_magnetic_moments()</p> </li> <li> store_results             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If True, store calculator results in atoms.info[\"results\"]. This makes it so the calculator results are not lost between serialize/deserialize cycles, if desired. Each one will be stored in atoms.info[\"results\"] = {\"calc0\": {}, \"calc1\": {}, ...} with higher numbers being the most recent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>Atoms object with calculator results attached in atoms.info[\"results\"]</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/atoms.py</code> <pre><code>def prep_next_run(\natoms: Atoms,\nassign_id: bool = True,\nmove_magmoms: bool = True,\nstore_results: bool = False,\n) -&gt; Atoms:\n\"\"\"\n    Prepares the Atoms object for a new run.\n    Depending on the arguments, this function will:\n        - Move the converged magnetic moments to the initial magnetic moments.\n        - Assign a unique ID to the Atoms object in atoms.info[\"_id\"]. Any existing IDs will\n        be moved to atoms.info[\"_old_ids\"].\n        - Store the calculator results in atoms.info[\"results\"] for later retrieval.\n        This makes it so the calculator results are not lost between\n        serialize/deserialize cycles, if desired. Each one will be stored in\n        atoms.info[\"results\"] = {\"calc0\": {}, \"calc1\": {}, ...} with higher numbers\n        being the most recent.\n    In all cases, the calculator will be reset so new jobs can be run.\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    assign_id\n        Whether to assign a unique ID to the Atoms object in atoms.info[\"_id\"].\n        Any existing IDs will be moved to atoms.info[\"_old_ids\"].\n    move_magmoms\n        If True, move atoms.calc.results[\"magmoms\"] to atoms.get_initial_magnetic_moments()\n    store_results\n        If True, store calculator results in atoms.info[\"results\"]. This makes it so the calculator results\n        are not lost between serialize/deserialize cycles, if desired. Each one will be stored in\n        atoms.info[\"results\"] = {\"calc0\": {}, \"calc1\": {}, ...} with higher numbers being the most recent.\n    Returns\n    -------\n    Atoms\n        Atoms object with calculator results attached in atoms.info[\"results\"]\n    \"\"\"\natoms = copy_atoms(atoms)\nif hasattr(atoms, \"calc\") and getattr(atoms.calc, \"results\", None) is not None:\nif store_results:\n# Dump calculator results into the .info tag\nif atoms.info.get(\"results\", None) is None:\nprior_calcs = 0\natoms.info[\"results\"] = {}\nelse:\nprior_calcs = len(atoms.info[\"results\"])\natoms.info[\"results\"][f\"calc{prior_calcs}\"] = atoms.calc.results\n# Move converged magmoms to initial magmoms\nif move_magmoms:\n# If there are initial magmoms set, then we should see what the final\n# magmoms are. If they are present, move them to initial. If they are not\n# present, it means the calculator doesn't support the \"magmoms\" property\n# so we have to retain the initial magmoms given no further info.\nif atoms.has(\"initial_magmoms\"):\natoms.set_initial_magnetic_moments(\natoms.calc.results.get(\n\"magmoms\", atoms.get_initial_magnetic_moments()\n)\n)\n# If there are no initial magmoms set, just check the results and set\n# everything to 0.0 if there is nothing there.\nelse:\natoms.set_initial_magnetic_moments(\natoms.calc.results.get(\"magmoms\", [0.0] * len(atoms))\n)\n# Clear off the calculator so we can run a new job. If we don't do this,\n# then something like atoms *= (2,2,2) still has a calculator attached, which\n# is a bit confusing.\natoms.calc = None\n# Give the Atoms object a unique ID. This will be helpful for querying later.\n# Also store any old IDs somewhere else for future reference.\n# Note: Keep this at the end of the function so that the ID is assigned based\n# on the returned Atoms object.\nif assign_id:\nif atoms.info.get(\"_id\", None) is not None:\nif atoms.info.get(\"_old_ids\") is None:\natoms.info[\"_old_ids\"] = []\natoms.info[\"_old_ids\"].append(atoms.info[\"_id\"])\natoms.info[\"_id\"] = get_atoms_id(atoms)\nreturn atoms\n</code></pre>"},{"location":"reference/quacc/utils/atoms.html#quacc.utils.atoms.set_magmoms","title":"set_magmoms","text":"<pre><code>set_magmoms(\natoms,\nelemental_mags_dict=None,\nelemental_mags_default=1.0,\ncopy_magmoms=True,\nmag_cutoff=0.05,\n)\n</code></pre> <p>Sets the initial magnetic moments in the Atoms object.</p> <p>This function deserves particular attention. The following logic is applied: - If there is a converged set of magnetic moments, those are moved to the initial magmoms if copy_magmoms is True. - If there is no converged set of magnetic moments but the user has set initial magmoms, those are simply used as is. - If there are no converged magnetic moments or initial magnetic moments, then the default magnetic moments from the preset elemental_mags_dict (if specified) are set as the initial magnetic moments. - For any of the above scenarios, if mag_cutoff is not None, the newly set initial magnetic moments are checked. If all have a magnitude below mag_cutoff, then they are all set to 0 (no spin polarization).</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> elemental_mags_dict             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of elemental symbols and their corresponding magnetic moments to set. If None, no default values will be used.</p> </li> <li> elemental_mags_default             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Default magnetic moment on an element if no magnetic moment is specified in the elemental_mags_dict. Only used if elemental_mags_dict is not None. This kwarg is mainly a convenience so that you don't need to list every single element in the elemental_mags_dict.</p> </li> <li> copy_magmoms             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to copy the magnetic moments from the converged set of magnetic moments to the initial magnetic moments.</p> </li> <li> mag_cutoff             (<code>float | None</code>, default:                 <code>0.05</code> )         \u2013          <p>Magnitude below which the magnetic moments are considered to be zero. If None, no cutoff will be applied</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>Atoms object</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/atoms.py</code> <pre><code>def set_magmoms(\natoms: Atoms,\nelemental_mags_dict: dict | None = None,\nelemental_mags_default: float = 1.0,\ncopy_magmoms: bool = True,\nmag_cutoff: float | None = 0.05,\n) -&gt; Atoms:\n\"\"\"\n    Sets the initial magnetic moments in the Atoms object.\n    This function deserves particular attention. The following logic is applied:\n    - If there is a converged set of magnetic moments, those are moved to the\n    initial magmoms if copy_magmoms is True.\n    - If there is no converged set of magnetic moments but the user has set initial magmoms,\n    those are simply used as is.\n    - If there are no converged magnetic moments or initial magnetic moments, then\n    the default magnetic moments from the preset elemental_mags_dict (if specified)\n    are set as the initial magnetic moments.\n    - For any of the above scenarios, if mag_cutoff is not None, the newly set\n    initial magnetic moments are checked. If all have a magnitude below mag_cutoff,\n    then they are all set to 0 (no spin polarization).\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    elemental_mags_dict\n        Dictionary of elemental symbols and their corresponding magnetic moments to set.\n        If None, no default values will be used.\n    elemental_mags_default\n        Default magnetic moment on an element if no magnetic moment is specified in the elemental_mags_dict.\n        Only used if elemental_mags_dict is not None. This kwarg is mainly a convenience so that you don't need to\n        list every single element in the elemental_mags_dict.\n    copy_magmoms\n        Whether to copy the magnetic moments from the converged set of magnetic moments to the initial magnetic moments.\n    mag_cutoff\n        Magnitude below which the magnetic moments are considered to be zero. If None, no cutoff will be applied\n    Returns\n    -------\n    Atoms\n        Atoms object\n    \"\"\"\n# Handle the magnetic moments\n# Check if a prior job was run and pull the prior magmoms\nif hasattr(atoms, \"calc\") and getattr(atoms.calc, \"results\", None) is not None:\nmags = atoms.calc.results.get(\"magmoms\", [0.0] * len(atoms))\n# Note: It is important that we set mags to 0.0 here rather than None if the\n# calculator has no magmoms because: 1) ispin=1 might be set, and 2) we do\n# not want the preset magmoms to be used.\nelse:\nmags = None\n# Check if the user has set any initial magmoms\nhas_initial_mags = atoms.has(\"initial_magmoms\")\n# If there are no initial magmoms set and this is not a follow-up job,\n# we may need to add some from the preset yaml.\nif mags is None:\nif not has_initial_mags:\n# If the preset dictionary has default magmoms, set\n# those by element. If the element isn't in the magmoms dict\n# then set it to mag_default.\nif elemental_mags_dict:\ninitial_mags = np.array(\n[\nelemental_mags_dict.get(atom.symbol, elemental_mags_default)\nfor atom in atoms\n]\n)\natoms.set_initial_magnetic_moments(initial_mags)\nelif copy_magmoms:\natoms.set_initial_magnetic_moments(mags)\n# If all the set mags are below mag_cutoff, set them to 0\nif mag_cutoff:\nhas_new_initial_mags = atoms.has(\"initial_magmoms\")\nnew_initial_mags = atoms.get_initial_magnetic_moments()\nif has_new_initial_mags and np.all(np.abs(new_initial_mags) &lt; mag_cutoff):\natoms.set_initial_magnetic_moments([0.0] * len(atoms))\nreturn atoms\n</code></pre>"},{"location":"reference/quacc/utils/calc.html","title":"calc","text":"<p>Utility functions for running ASE calculators</p>"},{"location":"reference/quacc/utils/calc.html#quacc.utils.calc.run_ase_opt","title":"run_ase_opt","text":"<pre><code>run_ase_opt(\natoms,\nrelax_cell=False,\nfmax=0.01,\nmax_steps=500,\noptimizer=FIRE,\noptimizer_kwargs=None,\nrun_kwargs=None,\ncopy_files=None,\n)\n</code></pre> <p>Run an ASE-based optimization in a scratch directory and copy the results back to the original directory. This can be useful if file I/O is slow in the working directory, so long as file transfer speeds are reasonable.</p> <p>This is a wrapper around the optimizers in ASE. Note: This function does not modify the atoms object in-place.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>The Atoms object to run the calculation on.</p> </li> <li> fmax             (<code>float</code>, default:                 <code>0.01</code> )         \u2013          <p>Tolerance for the force convergence (in eV/A).</p> </li> <li> max_steps             (<code>int</code>, default:                 <code>500</code> )         \u2013          <p>Maximum number of steps to take.</p> </li> <li> optimizer             (<code>Optimizer</code>, default:                 <code>FIRE</code> )         \u2013          <p>Optimizer class to use.</p> </li> <li> optimizer_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of kwargs for the optimizer.</p> </li> <li> run_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of kwargs for the run() method of the optimizer.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Filenames to copy from source to scratch directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optimizer</code>         \u2013          <p>The ASE Optimizer object.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/calc.py</code> <pre><code>def run_ase_opt(\natoms: Atoms,\nrelax_cell: bool = False,\nfmax: float = 0.01,\nmax_steps: int = 500,\noptimizer: Optimizer = FIRE,\noptimizer_kwargs: dict | None = None,\nrun_kwargs: dict | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; Optimizer:\n\"\"\"\n    Run an ASE-based optimization in a scratch directory and copy the results\n    back to the original directory. This can be useful if file I/O is slow in\n    the working directory, so long as file transfer speeds are reasonable.\n    This is a wrapper around the optimizers in ASE. Note: This function does\n    not modify the atoms object in-place.\n    Parameters\n    ----------\n    atoms\n        The Atoms object to run the calculation on.\n    fmax\n        Tolerance for the force convergence (in eV/A).\n    max_steps\n        Maximum number of steps to take.\n    optimizer\n        Optimizer class to use.\n    optimizer_kwargs\n        Dictionary of kwargs for the optimizer.\n    run_kwargs\n        Dictionary of kwargs for the run() method of the optimizer.\n    copy_files\n        Filenames to copy from source to scratch directory.\n    Returns\n    -------\n    Optimizer\n        The ASE Optimizer object.\n    \"\"\"\n# Set defaults\noptimizer_kwargs = optimizer_kwargs or {}\nrun_kwargs = run_kwargs or {}\n# Perform staging operations\natoms, tmpdir, job_results_dir = _calc_setup(atoms, copy_files=copy_files)\n# Set Sella kwargs\nif (\noptimizer.__name__ == \"Sella\"\nand not atoms.pbc.any()\nand \"internal\" not in optimizer_kwargs\n):\noptimizer_kwargs[\"internal\"] = True\n# Set up trajectory\nif \"trajectory\" in optimizer_kwargs:\nmsg = \"Quacc does not support setting the `trajectory` kwarg.\"\nraise ValueError(msg)\ntraj_filename = os.path.join(tmpdir, \"opt.traj\")\noptimizer_kwargs[\"trajectory\"] = Trajectory(traj_filename, \"w\", atoms=atoms)\n# Define optimizer class\nif relax_cell and atoms.pbc.any():\natoms = ExpCellFilter(atoms)\ndyn = optimizer(atoms, **optimizer_kwargs)\n# Run calculation\ndyn.run(fmax=fmax, steps=max_steps, **run_kwargs)\n# Prevent permission errors on Windows\nif hasattr(dyn, \"trajectory\") and hasattr(dyn.trajectory, \"close\"):\ndyn.trajectory.close()\n# Store the trajectory atoms\ndyn.traj_atoms = read(traj_filename, index=\":\")\n# Perform cleanup operations\n_calc_cleanup(tmpdir, job_results_dir)\nreturn dyn\n</code></pre>"},{"location":"reference/quacc/utils/calc.html#quacc.utils.calc.run_ase_vib","title":"run_ase_vib","text":"<pre><code>run_ase_vib(atoms, vib_kwargs=None, copy_files=None)\n</code></pre> <p>Run an ASE-based vibration analysis in a scratch directory and copy the results back to the original directory. This can be useful if file I/O is slow in the working directory, so long as file transfer speeds are reasonable.</p> <p>This is a wrapper around the vibrations module in ASE. Note: This function does not modify the atoms object in-place.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>The Atoms object to run the calculation on.</p> </li> <li> vib_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of kwargs for the vibration analysis.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Filenames to copy from source to scratch directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vibrations</code>         \u2013          <p>The updated Vibrations module</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/calc.py</code> <pre><code>def run_ase_vib(\natoms: Atoms, vib_kwargs: dict | None = None, copy_files: list[str] | None = None\n) -&gt; Vibrations:\n\"\"\"\n    Run an ASE-based vibration analysis in a scratch directory and copy the results\n    back to the original directory. This can be useful if file I/O is slow in\n    the working directory, so long as file transfer speeds are reasonable.\n    This is a wrapper around the vibrations module in ASE. Note: This function does\n    not modify the atoms object in-place.\n    Parameters\n    ----------\n    atoms\n        The Atoms object to run the calculation on.\n    vib_kwargs\n        Dictionary of kwargs for the vibration analysis.\n    copy_files\n        Filenames to copy from source to scratch directory.\n    Returns\n    -------\n    Vibrations\n        The updated Vibrations module\n    \"\"\"\n# Set defaults\nvib_kwargs = vib_kwargs or {}\n# Perform staging operations\natoms, tmpdir, job_results_dir = _calc_setup(atoms, copy_files=copy_files)\n# Run calculation\nvib = Vibrations(atoms, name=os.path.join(tmpdir, \"vib\"), **vib_kwargs)\nvib.run()\nvib.summary(log=os.path.join(tmpdir, \"vib_summary.log\"))\n# Perform cleanup operations\n_calc_cleanup(tmpdir, job_results_dir)\nreturn vib\n</code></pre>"},{"location":"reference/quacc/utils/calc.html#quacc.utils.calc.run_calc","title":"run_calc","text":"<pre><code>run_calc(atoms, geom_file=None, copy_files=None)\n</code></pre> <p>Run a calculation in a scratch directory and copy the results back to the original directory. This can be useful if file I/O is slow in the working directory, so long as file transfer speeds are reasonable.</p> <p>This is a wrapper around atoms.get_potential_energy(). Note: This function does not modify the atoms object in-place.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>The Atoms object to run the calculation on.</p> </li> <li> geom_file             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The filename of the log file that contains the output geometry, used to update the atoms object's positions and cell after a job. It is better to specify this rather than relying on ASE's atoms.get_potential_energy() function to update the positions, as this varies between codes.</p> </li> <li> copy_files             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Filenames to copy from source to scratch directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>The updated Atoms object.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/calc.py</code> <pre><code>def run_calc(\natoms: Atoms, geom_file: str | None = None, copy_files: list[str] | None = None\n) -&gt; Atoms:\n\"\"\"\n    Run a calculation in a scratch directory and copy the results back to the\n    original directory. This can be useful if file I/O is slow in the working\n    directory, so long as file transfer speeds are reasonable.\n    This is a wrapper around atoms.get_potential_energy(). Note: This\n    function does not modify the atoms object in-place.\n    Parameters\n    ----------\n    atoms\n        The Atoms object to run the calculation on.\n    geom_file\n        The filename of the log file that contains the output geometry, used\n        to update the atoms object's positions and cell after a job. It is better\n        to specify this rather than relying on ASE's atoms.get_potential_energy()\n        function to update the positions, as this varies between codes.\n    copy_files\n        Filenames to copy from source to scratch directory.\n    Returns\n    -------\n    Atoms\n        The updated Atoms object.\n    \"\"\"\n# Perform staging operations\natoms, tmpdir, job_results_dir = _calc_setup(atoms, copy_files=copy_files)\n# Run calculation via get_potential_energy()\natoms.get_potential_energy()\n# Most ASE calculators do not update the atoms object in-place with\n# a call to .get_potential_energy(), which is important if an internal\n# optimizer is used. This section is done to ensure that the atoms object\n# is updated with the correct positions and cell if a `geom_file` is provided.\nif geom_file:\n# Note: We have to be careful to make sure we don't lose the\n# converged magnetic moments, if present. That's why we simply\n# update the positions and cell in-place.\natoms_new = read(zpath(os.path.join(tmpdir, geom_file)))\nif isinstance(atoms_new, list):\natoms_new = atoms_new[-1]\n# Make sure the atom indices didn't get updated somehow (sanity check). If this\n# happens, there is a serious problem.\nif (\nnp.array_equal(atoms_new.get_atomic_numbers(), atoms.get_atomic_numbers())\nis False\n):\nmsg = \"Atomic numbers do not match between atoms and geom_file.\"\nraise ValueError(msg)\natoms.positions = atoms_new.positions\natoms.cell = atoms_new.cell\n# Perform cleanup operations\n_calc_cleanup(tmpdir, job_results_dir)\nreturn atoms\n</code></pre>"},{"location":"reference/quacc/utils/db.html","title":"db","text":"<p>Utility functions for interfacing with databases</p>"},{"location":"reference/quacc/utils/db.html#quacc.utils.db.covalent_to_db","title":"covalent_to_db","text":"<pre><code>covalent_to_db(store, dispatch_ids=None, results_dir=None)\n</code></pre> <p>Store the results of a Covalent database in a user-specified Maggma Store</p> <p>Parameters:</p> <ul> <li> store             (<code>Store</code>)         \u2013          <p>The Maggma Store object to store the results in</p> </li> <li> dispatch_ids             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dispatch ID to store. If None, all dispatch IDs in the results_dir will be stored</p> </li> <li> results_dir             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Covalent results_dir to pull if dispatch_ID is None. If None, the results_dir from ct.get_config() will be used</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/db.py</code> <pre><code>def covalent_to_db(\nstore: Store, dispatch_ids: list[str] | None = None, results_dir: str | None = None\n) -&gt; None:\n\"\"\"\n    Store the results of a Covalent database in a user-specified Maggma Store\n    Parameters\n    ----------\n    store\n        The Maggma Store object to store the results in\n    dispatch_ids\n        Dispatch ID to store. If None, all dispatch IDs in the results_dir will be stored\n    results_dir\n        The Covalent results_dir to pull if dispatch_ID is None. If None, the results_dir from ct.get_config() will be used\n    Returns\n    -------\n    None\n    \"\"\"\nimport covalent as ct\nfrom covalent._shared_files.exceptions import MissingLatticeRecordError\nif dispatch_ids and results_dir:\nmsg = \"Cannot specify both dispatch_id and results_dir\"\nraise ValueError(msg)\ndispatch_ids = dispatch_ids or []\n# Get the dispatch IDs\nif not dispatch_ids:\nif results_dir:\ndispatch_ids = os.listdir(results_dir)\nelse:\nconfig_results_dir = ct.get_config()[\"dispatcher\"][\"results_dir\"]\ndispatch_ids = os.listdir(config_results_dir)\n# Populate the docs\ndocs = []\nfor d_id in dispatch_ids:\ntry:\nresult_obj = ct.get_result(d_id)\nexcept MissingLatticeRecordError:\nwarnings.warn(f\"Could not find dispatch_id: {d_id}\", UserWarning)\ncontinue\nif result_obj and result_obj.status == \"COMPLETED\":\ndocs.append({\"dispatch_id\": d_id, \"result\": result_obj.result})\n# Store the results\nif docs:\nwith store:\nstore.update(docs, key=\"dispatch_id\")\n</code></pre>"},{"location":"reference/quacc/utils/db.html#quacc.utils.db.results_to_db","title":"results_to_db","text":"<pre><code>results_to_db(store, results)\n</code></pre> <p>Store the results of a quacc recipe in a user-specified Maggma Store. A UUID will be generated for each entry.</p> <p>Parameters:</p> <ul> <li> store             (<code>Store | str</code>)         \u2013          <p>The Maggma Store object to store the results in or a str representation of a Maggma Store (taken from <code>.to_json()</code>)</p> </li> <li> results             (<code>dict | list[dict]</code>)         \u2013          <p>The output summary dictionary or list of dictionaries from a quacc recipe</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/db.py</code> <pre><code>def results_to_db(store: Store | str, results: dict | list[dict]) -&gt; None:\n\"\"\"\n    Store the results of a quacc recipe in a user-specified Maggma Store.\n    A UUID will be generated for each entry.\n    Parameters\n    ----------\n    store\n        The Maggma Store object to store the results in or a str representation\n        of a Maggma Store (taken from `.to_json()`)\n    results\n        The output summary dictionary or list of dictionaries from a quacc recipe\n    Returns\n    -------\n    None\n    \"\"\"\nif isinstance(store, str):\nstore = MontyDecoder().decode(store)\nif isinstance(results, dict):\nresults = [results]\nfor result in results:\nresult[\"uuid\"] = str(uuid.uuid4())\nwith store:\nstore.update(results, key=\"uuid\")\n</code></pre>"},{"location":"reference/quacc/utils/defects.html","title":"defects","text":"<p>Utility functions for dealing with defects</p>"},{"location":"reference/quacc/utils/defects.html#quacc.utils.defects.make_defects_from_bulk","title":"make_defects_from_bulk","text":"<pre><code>make_defects_from_bulk(\natoms,\ndefectgen=VacancyGenerator,\ncharge_state=0,\nsc_mat=None,\nmin_atoms=80,\nmax_atoms=240,\nmin_length=10.0,\nforce_diagonal=False,\n**defectgen_kwargs\n)\n</code></pre> <p>Function to make defects from a bulk atoms object.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>bulk atoms</p> </li> <li> defectgen             (<code>AntiSiteGenerator | ChargeInterstitialGenerator | InterstitialGenerator | SubstitutionGenerator | VacancyGenerator | VoronoiInterstitialGenerator</code>, default:                 <code>VacancyGenerator</code> )         \u2013          <p>defect generator</p> </li> <li> sc_mat             (<code>ndarray | None</code>, default:                 <code>None</code> )         \u2013          <p>supercell matrix</p> </li> <li> min_atoms             (<code>int</code>, default:                 <code>80</code> )         \u2013          <p>minimum number of atoms in supercell</p> </li> <li> max_atoms             (<code>int</code>, default:                 <code>240</code> )         \u2013          <p>maximum number of atoms in supercell</p> </li> <li> min_length             (<code>float</code>, default:                 <code>10.0</code> )         \u2013          <p>minimum length of supercell</p> </li> <li> force_diagonal             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>force supercell to be diagonal</p> </li> <li> charge_state             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>charge state of defect</p> </li> <li> **defectgen_kwargs         \u2013          <p>keyword arguments to pass to the pymatgen.analysis.defects.generators get_defects() method</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>         \u2013          <p>All generated defects</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/defects.py</code> <pre><code>def make_defects_from_bulk(\natoms: Atoms,\ndefectgen: (\nAntiSiteGenerator\n| ChargeInterstitialGenerator\n| InterstitialGenerator\n| SubstitutionGenerator\n| VacancyGenerator\n| VoronoiInterstitialGenerator\n) = VacancyGenerator,\ncharge_state: int = 0,\nsc_mat: np.ndarray | None = None,\nmin_atoms: int = 80,\nmax_atoms: int = 240,\nmin_length: float = 10.0,\nforce_diagonal: bool = False,\n**defectgen_kwargs,\n) -&gt; list[Atoms]:\n\"\"\"\n    Function to make defects from a bulk atoms object.\n    Parameters\n    ----------\n    atoms\n        bulk atoms\n    defectgen\n        defect generator\n    sc_mat\n        supercell matrix\n    min_atoms\n        minimum number of atoms in supercell\n    max_atoms\n        maximum number of atoms in supercell\n    min_length\n        minimum length of supercell\n    force_diagonal\n        force supercell to be diagonal\n    charge_state\n        charge state of defect\n    **defectgen_kwargs\n        keyword arguments to pass to the pymatgen.analysis.defects.generators get_defects() method\n    Returns\n    -------\n    list[Atoms]\n        All generated defects\n    \"\"\"\n# Use pymatgen-analysis-defects and ShakeNBreak to generate defects\nstruct = AseAtomsAdaptor.get_structure(atoms)\natoms_info = atoms.info.copy()\n# Make all the defects\ndefects = defectgen().get_defects(struct, **defectgen_kwargs)\nfinal_defects = []\nfor defect in defects:\ndefect.user_charges = [charge_state]\n# Generate the supercell for a defect\ndefect_supercell = defect.get_supercell_structure(\nsc_mat=sc_mat,\ndummy_species=DummySpecies(),\nmin_atoms=min_atoms,\nmax_atoms=max_atoms,\nmin_length=min_length,\nforce_diagonal=force_diagonal,\n)\n# Generate DefectEntry object from Defect object\ndefect_entry = _get_defect_entry_from_defect(\ndefect=defect, defect_supercell=defect_supercell, charge_state=charge_state\n)\n# Instantiate class to apply rattle and bond distortion to all defects\nDist = Distortions(defects=[defect_entry])\n# Apply rattle and bond distortion to all defects\ndefect_dict, distortion_metadata = Dist.apply_distortions()\ndefect_symbol = list(distortion_metadata[\"defects\"].keys())[0]\ndistortion_dict = defect_dict[defect_symbol][\"charges\"][charge_state][\n\"structures\"\n][\"distortions\"]\n# Make atoms objects and store defect stats\nfor distortions, defect_struct in distortion_dict.items():\nfinal_defect = AseAtomsAdaptor.get_atoms(defect_struct)\nfinal_defect.info = atoms_info.copy()\ndefect_stats = {\n\"defect_symbol\": defect_symbol,\n\"charge_state\": charge_state,\n\"distortions\": distortions,\n\"bulk\": atoms,\n\"defect\": defect,\n}\nfinal_defect.info[\"defect_stats\"] = defect_stats\nfinal_defects.append(final_defect)\nreturn final_defects\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html","title":"dicts","text":"<p>Utility functions for dealing with dictionaries</p>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.clean_dict","title":"clean_dict","text":"<pre><code>clean_dict(start_dict, remove_empties=False)\n</code></pre> <p>For a given dictionary, recursively remove all items that are None or are empty lists/dicts, and then sort all entries alphabetically by key.</p> <p>Parameters:</p> <ul> <li> start_dict             (<code>dict</code>)         \u2013          <p>Dictionary to clean</p> </li> <li> remove_empties             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If True, remove empty lists and dictionaries</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Cleaned and sorted dictionary</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/dicts.py</code> <pre><code>def clean_dict(start_dict: dict, remove_empties: bool = False) -&gt; dict:\n\"\"\"\n    For a given dictionary, recursively remove all items that are None\n    or are empty lists/dicts, and then sort all entries alphabetically by key.\n    Parameters\n    ----------\n    start_dict\n        Dictionary to clean\n    remove_empties\n        If True, remove empty lists and dictionaries\n    Returns\n    -------\n    dict\n        Cleaned and sorted dictionary\n    \"\"\"\nif remove_empties:\nstart_dict = remove_dict_empties(start_dict)\nreturn sort_dict(start_dict)\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.merge_dicts","title":"merge_dicts","text":"<pre><code>merge_dicts(dict1, dict2, remove_empties=True)\n</code></pre> <p>Recursively merges two dictionaries.</p> <p>Parameters:</p> <ul> <li> dict1             (<code>dict</code>)         \u2013          <p>First dictionary</p> </li> <li> dict2             (<code>dict</code>)         \u2013          <p>Second dictionary</p> </li> <li> remove_empties             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If True, remove empty lists and dictionaries</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Merged dictionary</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/dicts.py</code> <pre><code>def merge_dicts(dict1: dict, dict2: dict, remove_empties: bool = True) -&gt; dict:\n\"\"\"\n    Recursively merges two dictionaries.\n    Parameters\n    ----------\n    dict1\n        First dictionary\n    dict2\n        Second dictionary\n    remove_empties\n        If True, remove empty lists and dictionaries\n    Returns\n    -------\n    dict\n        Merged dictionary\n    \"\"\"\nmerged = dict1.copy()\nfor key, value in dict2.items():\nif key in merged:\nif isinstance(merged[key], dict) and isinstance(value, dict):\nmerged[key] = merge_dicts(merged[key], value)\nelse:\nmerged[key] = value\nelse:\nmerged[key] = value\nif remove_empties:\nmerged = remove_dict_empties(merged)\nreturn merged\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.remove_dict_empties","title":"remove_dict_empties","text":"<pre><code>remove_dict_empties(start_dict)\n</code></pre> <p>For a given dictionary, recursively remove all items that are None or are empty lists/dicts.</p> <p>Parameters:</p> <ul> <li> start_dict             (<code>dict</code>)         \u2013          <p>Dictionary to clean</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Cleaned dictionary</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/dicts.py</code> <pre><code>def remove_dict_empties(start_dict: dict) -&gt; dict:\n\"\"\"\n    For a given dictionary, recursively remove all items that are None\n    or are empty lists/dicts.\n    Parameters\n    ----------\n    start_dict\n        Dictionary to clean\n    Returns\n    -------\n    dict\n        Cleaned dictionary\n    \"\"\"\nif isinstance(start_dict, dict):\nreturn {\nk: remove_dict_empties(v)\nfor k, v in start_dict.items()\nif v is not None and (not isinstance(v, (dict, list)) or len(v) != 0)\n}\nreturn (\n[remove_dict_empties(v) for v in start_dict]\nif isinstance(start_dict, list)\nelse start_dict\n)\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.sort_dict","title":"sort_dict","text":"<pre><code>sort_dict(start_dict)\n</code></pre> <p>For a given dictionary, recursively sort all entries alphabetically by key.</p> <p>Parameters:</p> <ul> <li> start_dict             (<code>dict</code>)         \u2013          <p>Dictionary to sort</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Sorted dictionary</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/dicts.py</code> <pre><code>def sort_dict(start_dict: dict) -&gt; dict:\n\"\"\"\n    For a given dictionary, recursively sort all entries alphabetically by key.\n    Parameters\n    ----------\n    start_dict\n        Dictionary to sort\n    Returns\n    -------\n    dict\n        Sorted dictionary\n    \"\"\"\nreturn {\nk: sort_dict(v) if isinstance(v, dict) else v\nfor k, v in sorted(start_dict.items())\n}\n</code></pre>"},{"location":"reference/quacc/utils/files.html","title":"files","text":"<p>Utility functions for file and path handling</p>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.check_logfile","title":"check_logfile","text":"<pre><code>check_logfile(logfile, check_str)\n</code></pre> <p>Check if a logfile has a given string (case-insensitive).</p> <p>Parameters:</p> <ul> <li> logfile             (<code>str</code>)         \u2013          <p>Path to the logfile.</p> </li> <li> check_str             (<code>str</code>)         \u2013          <p>String to check for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if the string is found in the logfile, False otherwise.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/files.py</code> <pre><code>def check_logfile(logfile: str, check_str: str) -&gt; bool:\n\"\"\"\n    Check if a logfile has a given string (case-insensitive).\n    Parameters\n    ----------\n    logfile : str\n        Path to the logfile.\n    check_str : str\n        String to check for.\n    Returns\n    -------\n    bool\n        True if the string is found in the logfile, False otherwise.\n    \"\"\"\nzlog = zpath(logfile)\nwith zopen(zlog, \"r\") as f:\nfor line in f:\nif not isinstance(line, str):\nline = line.decode(\"utf-8\")\nif check_str.lower() in line.lower():\nreturn True\nreturn False\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.copy_decompress","title":"copy_decompress","text":"<pre><code>copy_decompress(source_files, destination)\n</code></pre> <p>Copy and decompress files from source to destination.</p> <p>Parameters:</p> <ul> <li> source_files             (<code>list[str]</code>)         \u2013          <p>List of files to copy and decompress.</p> </li> <li> destination             (<code>str</code>)         \u2013          <p>Destination directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/files.py</code> <pre><code>def copy_decompress(source_files: list[str], destination: str) -&gt; None:\n\"\"\"\n    Copy and decompress files from source to destination.\n    Parameters\n    ----------\n    source_files\n        List of files to copy and decompress.\n    destination\n        Destination directory.\n    Returns\n    -------\n    None\n    \"\"\"\nfor f in source_files:\nz_path = zpath(f)\nif os.path.exists(z_path):\nz_file = os.path.basename(z_path)\ncopy(z_path, os.path.join(destination, z_file))\ndecompress_file(os.path.join(destination, z_file))\nelse:\nwarnings.warn(f\"Cannot find file: {z_path}\", UserWarning)\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.find_recent_logfile","title":"find_recent_logfile","text":"<pre><code>find_recent_logfile(dir_name, logfile_extensions)\n</code></pre> <p>Find the most recent logfile in a given directory.</p> <p>Parameters:</p> <ul> <li> dir_name             (<code>Path | str</code>)         \u2013          <p>The path to the directory to search</p> </li> <li> logfile_extensions             (<code>str | list[str]</code>)         \u2013          <p>The extension (or list of possible extensions) of the logfile to search for. For an exact match only, put in the full file name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>logfile</code>         \u2013          <p>The path to the most recent logfile with the desired extension</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/files.py</code> <pre><code>def find_recent_logfile(dir_name: Path | str, logfile_extensions: str | list[str]):\n\"\"\"\n    Find the most recent logfile in a given directory.\n    Parameters\n    ----------\n    dir_name\n        The path to the directory to search\n    logfile_extensions\n        The extension (or list of possible extensions) of the logfile to search for.\n        For an exact match only, put in the full file name.\n    Returns\n    -------\n    logfile\n        The path to the most recent logfile with the desired extension\n    \"\"\"\nmod_time = 0.0\nlogfile = None\nif isinstance(logfile_extensions, str):\nlogfile_extensions = [logfile_extensions]\nfor f in os.listdir(dir_name):\nf_path = os.path.join(dir_name, f)\nfor ext in logfile_extensions:\nif ext in f and os.path.getmtime(f_path) &gt; mod_time:\nmod_time = os.path.getmtime(f_path)\nlogfile = os.path.abspath(f_path)\nreturn logfile\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.get_uri","title":"get_uri","text":"<pre><code>get_uri(dir_name)\n</code></pre> <p>Return the URI path for a directory.</p> <p>This allows files hosted on different file servers to have distinct locations.</p> <p>Adapted from Atomate2.</p> <p>Parameters:</p> <ul> <li> dir_name             (<code>str</code>)         \u2013          <p>A directory name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>Full URI path, e.g., \"fileserver.host.com:/full/path/of/dir_name\".</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/files.py</code> <pre><code>def get_uri(dir_name: str | Path) -&gt; str:\n\"\"\"\n    Return the URI path for a directory.\n    This allows files hosted on different file servers to have distinct locations.\n    Adapted from Atomate2.\n    Parameters\n    ----------\n    dir_name : str\n        A directory name.\n    Returns\n    -------\n    str\n        Full URI path, e.g., \"fileserver.host.com:/full/path/of/dir_name\".\n    \"\"\"\nfullpath = Path(dir_name).absolute()\nhostname = socket.gethostname()\nwith contextlib.suppress(socket.gaierror, socket.herror):\nhostname = socket.gethostbyaddr(hostname)[0]\nreturn f\"{hostname}:{fullpath}\"\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.load_yaml_calc","title":"load_yaml_calc","text":"<pre><code>load_yaml_calc(yaml_path)\n</code></pre> <p>Loads a YAML file containing calculator settings. This YAML loader looks for a special flag \"parent\" in the YAML file. If this flag is present, the YAML file specified in the \"parent\" flag is loaded and its contents are inherited by the child YAML file.</p> <p>Parameters:</p> <ul> <li> yaml_path             (<code>str | Path</code>)         \u2013          <p>Path to the YAML file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>The calculator configuration (i.e. settings).</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/files.py</code> <pre><code>def load_yaml_calc(yaml_path: str | Path) -&gt; dict:\n\"\"\"\n    Loads a YAML file containing calculator settings.\n    This YAML loader looks for a special flag \"parent\" in the YAML file.\n    If this flag is present, the YAML file specified in the \"parent\" flag\n    is loaded and its contents are inherited by the child YAML file.\n    Parameters\n    ----------\n    yaml_path\n        Path to the YAML file.\n    Returns\n    -------\n    dict\n        The calculator configuration (i.e. settings).\n    \"\"\"\nyaml_path = Path(yaml_path).with_suffix(\".yaml\")\nif not yaml_path.exists():\nmsg = f\"Cannot find {yaml_path}\"\nraise ValueError(msg)\n# Load YAML file\nwith open(yaml_path) as stream:\nconfig = yaml.safe_load(stream)\n# Inherit arguments from any parent YAML files\n# but do not overwrite those in the child file.\nfor config_arg in config.copy():\nif \"parent\" in config_arg.lower():\nyaml_parent_path = Path(yaml_path).parent / Path(config[config_arg])\nparent_config = load_yaml_calc(yaml_parent_path)\nfor k, v in parent_config.items():\nif k not in config:\nconfig[k] = v\nelse:\nv_new = parent_config.get(k, {})\nfor kk, vv in v_new.items():\nif kk not in config[k]:\nconfig[k][kk] = vv\ndel config[config_arg]\nreturn config\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.make_unique_dir","title":"make_unique_dir","text":"<pre><code>make_unique_dir(base_path=None)\n</code></pre> <p>Make a directory with a unique name. Uses the same format as Jobflow.</p> <p>Parameters:</p> <ul> <li> base_path             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Path to the base directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>Path to the job directory.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/files.py</code> <pre><code>def make_unique_dir(base_path: str | None = None) -&gt; str:\n\"\"\"\n    Make a directory with a unique name. Uses the same format as Jobflow.\n    Parameters\n    ----------\n    base_path\n        Path to the base directory.\n    Returns\n    -------\n    str\n        Path to the job directory.\n    \"\"\"\ntime_now = datetime.utcnow().strftime(\"%Y-%m-%d-%H-%M-%S-%f\")\njob_dir = f\"quacc-{time_now}-{randint(10000, 99999)}\"\nif base_path:\njob_dir = os.path.join(base_path, job_dir)\nos.makedirs(job_dir)\nreturn job_dir\n</code></pre>"},{"location":"reference/quacc/utils/slabs.html","title":"slabs","text":"<p>Utility functions for dealing with slabs</p>"},{"location":"reference/quacc/utils/slabs.html#quacc.utils.slabs.flip_atoms","title":"flip_atoms","text":"<pre><code>flip_atoms(atoms, return_struct=False)\n</code></pre> <p>Convenience function for vertically flipping periodic atoms or structures</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | Structure | Slab</code>)         \u2013          <p>Atoms/.Structure to flip</p> </li> <li> return_struct             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>True if a Pymatgen structure object should be returned. False if an ASE atoms object should be returned</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms | Structure | Slab</code>         \u2013          <p>Inverted slab</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/slabs.py</code> <pre><code>def flip_atoms(\natoms: Atoms | Structure | Slab, return_struct: bool = False\n) -&gt; Atoms | Structure | Slab:\n\"\"\"\n    Convenience function for vertically flipping periodic atoms or structures\n    Parameters\n    ----------\n    atoms\n        Atoms/.Structure to flip\n    return_struct\n        True if a Pymatgen structure object should be returned.\n        False if an ASE atoms object should be returned\n    Returns\n    -------\n    Atoms | Structure | Slab\n        Inverted slab\n    \"\"\"\nif isinstance(atoms, Atoms):\nnew_atoms = copy_atoms(atoms)\natoms_info = atoms.info.copy()\nelse:\nnew_atoms = AseAtomsAdaptor.get_atoms(atoms)\natoms_info = {}\nnew_atoms.rotate(180, \"x\")\nnew_atoms.wrap()\nnew_atoms.info = atoms_info\nif return_struct:\nnew_atoms = AseAtomsAdaptor.get_structure(new_atoms)\nreturn new_atoms\n</code></pre>"},{"location":"reference/quacc/utils/slabs.html#quacc.utils.slabs.get_surface_energy","title":"get_surface_energy","text":"<pre><code>get_surface_energy(bulk, slab, bulk_energy, slab_energy)\n</code></pre> <p>Calculate the surface energy to form a given surface slab from a bulk structure. For asymmetric slabs, this is better thought of as the cleavage energy.</p> <p>Parameters:</p> <ul> <li> bulk             (<code>Atoms</code>)         \u2013          <p>The bulk structure.</p> </li> <li> slab             (<code>Atoms</code>)         \u2013          <p>The slab structure.</p> </li> <li> bulk_energy             (<code>float</code>)         \u2013          <p>The total energy of the bulk structure.</p> </li> <li> slab_energy             (<code>float</code>)         \u2013          <p>The total energy of the slab structure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>         \u2013          <p>The surface energy in eV/A^2.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/slabs.py</code> <pre><code>def get_surface_energy(\nbulk: Atoms, slab: Atoms, bulk_energy: float, slab_energy: float\n) -&gt; float:\n\"\"\"\n    Calculate the surface energy to form a given surface slab from a bulk structure.\n    For asymmetric slabs, this is better thought of as the cleavage energy.\n    Parameters\n    -----------\n    bulk\n        The bulk structure.\n    slab\n        The slab structure.\n    bulk_energy\n        The total energy of the bulk structure.\n    slab_energy\n        The total energy of the slab structure.\n    Returns\n    -------\n    float\n        The surface energy in eV/A^2.\n    \"\"\"\nalpha = len(slab) / len(bulk)\ncell = slab.get_cell()\nA = np.linalg.norm(np.cross(cell[0], cell[1]))\nreturn (slab_energy - alpha * bulk_energy) / (2 * A)\n</code></pre>"},{"location":"reference/quacc/utils/slabs.html#quacc.utils.slabs.make_adsorbate_structures","title":"make_adsorbate_structures","text":"<pre><code>make_adsorbate_structures(\natoms,\nadsorbate,\nmin_distance=2.0,\nmodes=None,\nallowed_surface_symbols=None,\nallowed_surface_indices=None,\nads_site_finder_kwargs=None,\nfind_ads_sites_kwargs=None,\n)\n</code></pre> <p>Add a single adsorbate to a structure for every requested adsorption mode</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>The atoms to add adsorbates to.</p> </li> <li> adsorbate             (<code>Atoms</code>)         \u2013          <p>The adsorbate to add. Note: It will be placed on the surface in the exact input orientation provided by the user (the adsorption mode is along the c axis and the coordinating atom is the one in the -z direction).</p> </li> <li> min_distance             (<code>float</code>, default:                 <code>2.0</code> )         \u2013          <p>The (minimum) distance to set between the adsorbate and the surface site.</p> </li> <li> modes             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The adsorption mode(s) to consider. Options include: \"ontop\", \"bridge\", \"hollow\", \"subsurface\".</p> </li> <li> allowed_surface_symbols             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The symbols of surface atoms to consider. If None, will use all surface atoms. Note: This method could be improved for bridge/hollow sites.</p> </li> <li> allowed_surface_indices             (<code>list[int] | None</code>, default:                 <code>None</code> )         \u2013          <p>The indices of surface atoms to consider. If None, will use all surface atoms. Generally used if a specific site is to be excluded from the set. Note: This method could be improved for bridge/hollow sites.</p> </li> <li> ads_site_finder_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>The keyword arguments to pass to the AdsorbateSiteFinder().</p> </li> <li> find_ads_sites_kwargs             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>The keyword arguments to pass to AdsorbateSiteFinder.find_adsorption_sites().</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>         \u2013          <p>The structures with adsorbates</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/slabs.py</code> <pre><code>def make_adsorbate_structures(\natoms: Atoms,\nadsorbate: Atoms,\nmin_distance: float = 2.0,\nmodes: list[str] | None = None,\nallowed_surface_symbols: list[str] | None = None,\nallowed_surface_indices: list[int] | None = None,\nads_site_finder_kwargs: dict | None = None,\nfind_ads_sites_kwargs: dict | None = None,\n) -&gt; list[Atoms]:\n\"\"\"\n    Add a single adsorbate to a structure for every requested adsorption mode\n    Parameters\n    ----------\n    atoms\n        The atoms to add adsorbates to.\n    adsorbate\n        The adsorbate to add.\n        Note: It will be placed on the surface in the exact input orientation provided by the user (the adsorption mode is\n        along the c axis and the coordinating atom is the one in the -z direction).\n    min_distance\n        The (minimum) distance to set between the adsorbate and the surface site.\n    modes\n        The adsorption mode(s) to consider. Options include: \"ontop\", \"bridge\", \"hollow\", \"subsurface\".\n    allowed_surface_symbols\n        The symbols of surface atoms to consider. If None, will use all surface atoms.\n        Note: This method could be improved for bridge/hollow sites.\n    allowed_surface_indices\n        The indices of surface atoms to consider. If None, will use all surface atoms. Generally used if a specific site is to be excluded from the set.\n        Note: This method could be improved for bridge/hollow sites.\n    ads_site_finder_kwargs\n        The keyword arguments to pass to the AdsorbateSiteFinder().\n    find_ads_sites_kwargs\n        The keyword arguments to pass to AdsorbateSiteFinder.find_adsorption_sites().\n    Returns\n    --------\n    list[Atoms]\n        The structures with adsorbates\n    \"\"\"\natoms = copy_atoms(atoms)\nif modes is None:\nmodes = [\"ontop\", \"bridge\", \"hollow\"]\nads_site_finder_kwargs = ads_site_finder_kwargs or {}\nfind_ads_sites_kwargs = find_ads_sites_kwargs or {}\n# Check for double-used parameters\nif min_distance and \"distance\" in find_ads_sites_kwargs:\nmsg = \"Cannot specify both min_distance and find_ads_sites_kwargs['distance']\"\nraise ValueError(msg)\nif modes and \"positions\" in find_ads_sites_kwargs:\nmsg = \"Cannot specify both modes and find_ads_sites_kwargs['positions']\"\nraise ValueError(msg)\nfind_ads_sites_kwargs[\"distance\"] = min_distance\nfind_ads_sites_kwargs[\"positions\"] = [mode.lower() for mode in modes]\n# Check the provided surface indices are reasonable\natom_indices = [atom.index for atom in atoms]\nif allowed_surface_indices and any(\nidx not in atom_indices for idx in allowed_surface_indices\n):\nmsg = \"All indices in allowed_surface_indices must be in atoms.\"\nraise ValueError(msg, allowed_surface_indices, atom_indices)\n# Add 0.0 initial magmoms to atoms/adsorbate if needed\nif atoms.has(\"initial_magmoms\") and not adsorbate.has(\"initial_magmoms\"):\nadsorbate.set_initial_magnetic_moments([0.0] * len(adsorbate))\nif adsorbate.has(\"initial_magmoms\") and not atoms.has(\"initial_magmoms\"):\natoms.set_initial_magnetic_moments([0.0] * len(atoms))\n# Make a Pymatgen structure and molecule\nstruct = AseAtomsAdaptor.get_structure(atoms)\nmol = AseAtomsAdaptor.get_molecule(adsorbate, charge_spin_check=False)\n# Get the adsorption sites\nads_finder = AdsorbateSiteFinder(struct, **ads_site_finder_kwargs)\nads_sites = ads_finder.find_adsorption_sites(**find_ads_sites_kwargs)\n# Find and add the adsorbates\nnew_atoms = []\nfor mode, ads_coords in ads_sites.items():\n# Check if mode is in desired list\nif mode not in modes:\ncontinue\nfor ads_coord in ads_coords:\n# Place adsorbate\nstruct_with_adsorbate = ads_finder.add_adsorbate(mol, ads_coord)\n# Convert back to Atoms object\natoms_with_adsorbate = AseAtomsAdaptor.get_atoms(struct_with_adsorbate)\n# Get distance matrix between adsorbate binding atom and surface\nd = atoms_with_adsorbate.get_all_distances(mic=True)[\n0 : len(atoms), len(atoms) :\n]\n# Find closest surface atoms\nmin_d = np.min(d)\nsurface_atom_indices = np.where(\n(d &gt;= min_d - min_d * 0.1) &amp; (d &lt;= min_d + min_d * 0.1)\n)[0]\nsurface_atom_symbols = atoms_with_adsorbate[\nsurface_atom_indices\n].get_chemical_symbols()\n# Check if surface binding site is not in the specified\n# user list. If so, skip this one\nif allowed_surface_symbols and all(\nsurface_atom_symbol not in allowed_surface_symbols\nfor surface_atom_symbol in surface_atom_symbols\n):\ncontinue\nif allowed_surface_indices and all(\nsurface_atom_idx not in allowed_surface_indices\nfor surface_atom_idx in surface_atom_indices\n):\ncontinue\n# Store adsorbate info\natoms_with_adsorbate.info = atoms.info.copy()\nads_stats = {\n\"adsorbate\": adsorbate,\n\"initial_mode\": mode,\n\"surface_atoms_symbols\": surface_atom_symbols,\n\"surface_atoms_indices\": surface_atom_indices,\n}\nif atoms_with_adsorbate.info.get(\"adsorbates\", None) is None:\natoms_with_adsorbate.info[\"adsorbates\"] = [ads_stats]\nelse:\natoms_with_adsorbate.info[\"adsorbates\"].extend([ads_stats])\n# Add slab+adsorbate to list\nnew_atoms.append(atoms_with_adsorbate)\nreturn new_atoms\n</code></pre>"},{"location":"reference/quacc/utils/slabs.html#quacc.utils.slabs.make_max_slabs_from_bulk","title":"make_max_slabs_from_bulk","text":"<pre><code>make_max_slabs_from_bulk(\natoms,\nmax_slabs=None,\nmax_index=1,\nrandomize=False,\nmin_slab_size=10.0,\nmin_length_width=8.0,\nmin_vacuum_size=20.0,\nz_fix=2.0,\nflip_asymmetric=True,\nallowed_surface_symbols=None,\n**slabgen_kwargs\n)\n</code></pre> <p>Generate no more than max_slabs number of slabs from a bulk structure. The procedure is as follows: 1. Generate all slabs 2. If number of slabs is greater than max_slabs, tune ftol from 0.1 to 0.8 in increments of 0.1. This reduces the number of vertical shifts to consider. 3. If number of slabs is still greater than max_slabs, only return the slabs with the fewest number of atoms per cell such that the returned amount is less than or equal to max_slabs.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Bulk structure to generate slabs from</p> </li> <li> max_slabs             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Maximum number of slabs to generate</p> </li> <li> randomize             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If True, return a random selection of max_slabs number of slabs. Otherwise, follow the procedure outlined above.</p> </li> <li> max_index             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Maximum Miller index for slab generation</p> </li> <li> min_slab_size             (<code>float</code>, default:                 <code>10.0</code> )         \u2013          <p>Minimum slab size (depth) in angstroms</p> </li> <li> min_length_width             (<code>float</code>, default:                 <code>8.0</code> )         \u2013          <p>Minimum length and width of the slab in angstroms</p> </li> <li> min_vacuum_size             (<code>float</code>, default:                 <code>20.0</code> )         \u2013          <p>Minimum vacuum size in angstroms</p> </li> <li> z_fix             (<code>float | None</code>, default:                 <code>2.0</code> )         \u2013          <p>Distance (in angstroms) from top of slab for which atoms should be fixed</p> </li> <li> flip_asymmetric             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If an asymmetric surface should be flipped and added to the list</p> </li> <li> allowed_surface_symbols             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>List of chemical symbols that must be present on the surface of the slab otherwise the slab will be discarded, e.g. [\"Cu\", \"Ni\"]</p> </li> <li> **slabgen_kwargs         \u2013          </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Atoms]</code>         \u2013          <p>List of slabs</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/slabs.py</code> <pre><code>def make_max_slabs_from_bulk(\natoms: Atoms,\nmax_slabs: int | None = None,\nmax_index: int = 1,\nrandomize: bool = False,\nmin_slab_size: float = 10.0,\nmin_length_width: float = 8.0,\nmin_vacuum_size: float = 20.0,\nz_fix: float | None = 2.0,\nflip_asymmetric: bool = True,\nallowed_surface_symbols: list[str] | None = None,\n**slabgen_kwargs,\n) -&gt; list[Atoms]:\n\"\"\"\n    Generate no more than max_slabs number of slabs from a bulk structure.\n    The procedure is as follows:\n    1. Generate all slabs\n    2. If number of slabs is greater than max_slabs, tune ftol from 0.1 to 0.8\n    in increments of 0.1. This reduces the number of vertical shifts to consider.\n    3. If number of slabs is still greater than max_slabs, only return the slabs\n    with the fewest number of atoms per cell such that the returned amount is\n    less than or equal to max_slabs.\n    Parameters\n    ----------\n    atoms\n        Bulk structure to generate slabs from\n    max_slabs\n        Maximum number of slabs to generate\n    randomize\n        If True, return a random selection of max_slabs number of slabs. Otherwise,\n        follow the procedure outlined above.\n    max_index\n        Maximum Miller index for slab generation\n    min_slab_size\n        Minimum slab size (depth) in angstroms\n    min_length_width\n        Minimum length and width of the slab in angstroms\n    min_vacuum_size\n        Minimum vacuum size in angstroms\n    z_fix\n        Distance (in angstroms) from top of slab for which atoms should be fixed\n    flip_asymmetric\n        If an asymmetric surface should be flipped and added to the list\n    allowed_surface_symbols\n        List of chemical symbols that must be present on the surface of the slab otherwise\n        the slab will be discarded, e.g. [\"Cu\", \"Ni\"]\n    **slabgen_kwargs: keyword arguments to pass to the pymatgen generate_all_slabs() function\n    Returns\n    --------\n    List[Atoms]\n        List of slabs\n    \"\"\"\nslabs = make_slabs_from_bulk(\natoms,\nmax_index=max_index,\nmin_slab_size=min_slab_size,\nmin_length_width=min_length_width,\nmin_vacuum_size=min_vacuum_size,\nz_fix=z_fix,\nflip_asymmetric=flip_asymmetric,\nallowed_surface_symbols=allowed_surface_symbols,\n**slabgen_kwargs,\n)\nif randomize:\nsubsample = max_slabs or len(slabs)\nreturn random.sample(slabs, subsample)\n# Try to reduce the number of slabs if the user really wants it...\n# (desperate times call for desperate measures)\nif max_slabs and slabs is not None and len(slabs) &gt; max_slabs:\nwarnings.warn(\nf\"You requested {max_slabs} slabs, but {len(slabs)} were generated. Tuning ftol in generate_all_slabs() to try to reduce the number of slabs, at the expense of sampling fewer surface configurations.\",\nUserWarning,\n)\nfor ftol in np.arange(0.1, 0.9, 0.1):\nslabgen_kwargs[\"ftol\"] = ftol\nslabs_ftol = make_slabs_from_bulk(\natoms,\nmax_index=max_index,\nmin_slab_size=min_slab_size,\nmin_length_width=min_length_width,\nmin_vacuum_size=min_vacuum_size,\nz_fix=z_fix,\nflip_asymmetric=flip_asymmetric,\nallowed_surface_symbols=allowed_surface_symbols,\n**slabgen_kwargs,\n)\nif len(slabs_ftol) &lt; len(slabs):\nslabs = slabs_ftol\nif len(slabs) &lt;= max_slabs:\nbreak\nif len(slabs) &gt; max_slabs:\nwarnings.warn(\nf\"You requested {max_slabs} slabs, but {len(slabs)} were generated. Could not reduce further. Picking the smallest slabs by number of atoms.\",\nUserWarning,\n)\nslabs.sort(key=len)\nslabs = slabs[:max_slabs]\nreturn slabs\n</code></pre>"},{"location":"reference/quacc/utils/slabs.html#quacc.utils.slabs.make_slabs_from_bulk","title":"make_slabs_from_bulk","text":"<pre><code>make_slabs_from_bulk(\natoms,\nmax_index=1,\nmin_slab_size=10.0,\nmin_length_width=8.0,\nmin_vacuum_size=20.0,\nz_fix=2.0,\nflip_asymmetric=True,\nallowed_surface_symbols=None,\n**slabgen_kwargs\n)\n</code></pre> <p>Function to make slabs from a bulk atoms object.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>bulk atoms</p> </li> <li> max_index             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Maximum Miller index for slab generation</p> </li> <li> min_slab_size             (<code>float</code>, default:                 <code>10.0</code> )         \u2013          <p>Minimum slab size (depth) in angstroms</p> </li> <li> min_length_width             (<code>float</code>, default:                 <code>8.0</code> )         \u2013          <p>Minimum length and width of the slab in angstroms</p> </li> <li> min_vacuum_size             (<code>float</code>, default:                 <code>20.0</code> )         \u2013          <p>Minimum vacuum size in angstroms</p> </li> <li> z_fix             (<code>float | None</code>, default:                 <code>2.0</code> )         \u2013          <p>Distance (in angstroms) from top of slab for which atoms should be fixed</p> </li> <li> flip_asymmetric             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If an asymmetric surface should be flipped and added to the list</p> </li> <li> allowed_surface_symbols             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>List of chemical symbols that must be present on the surface of the slab otherwise the slab will be discarded, e.g. [\"Cu\", \"Ni\"]</p> </li> <li> **slabgen_kwargs         \u2013          </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>         \u2013          <p>All generated slabs</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/slabs.py</code> <pre><code>def make_slabs_from_bulk(\natoms: Atoms,\nmax_index: int = 1,\nmin_slab_size: float = 10.0,\nmin_length_width: float = 8.0,\nmin_vacuum_size: float = 20.0,\nz_fix: float | None = 2.0,\nflip_asymmetric: bool = True,\nallowed_surface_symbols: list[str] | None = None,\n**slabgen_kwargs,\n) -&gt; list[Atoms]:\n\"\"\"\n    Function to make slabs from a bulk atoms object.\n    Parameters\n    ----------\n    atoms\n        bulk atoms\n    max_index\n        Maximum Miller index for slab generation\n    min_slab_size\n        Minimum slab size (depth) in angstroms\n    min_length_width\n        Minimum length and width of the slab in angstroms\n    min_vacuum_size\n        Minimum vacuum size in angstroms\n    z_fix\n        Distance (in angstroms) from top of slab for which atoms should be fixed\n    flip_asymmetric\n        If an asymmetric surface should be flipped and added to the list\n    allowed_surface_symbols\n        List of chemical symbols that must be present on the surface of the slab otherwise the slab will be discarded, e.g. [\"Cu\", \"Ni\"]\n    **slabgen_kwargs: keyword arguments to pass to the pymatgen generate_all_slabs() function\n    Returns\n    -------\n    list[Atoms]\n        All generated slabs\n    \"\"\"\n# Note: This will not work properly for 2D structures. See Oxana/Martin's code\n# for adjustments for 2D: https://github.com/oxana-a/atomate/blob/ads_wf/atomate/vasp/firetasks/adsorption_tasks.py\n# Use pymatgen to generate slabs\nstruct = AseAtomsAdaptor.get_structure(atoms)\natoms_info = atoms.info.copy()\n# Make all the slabs\nslabs = generate_all_slabs(\nstruct,\nmax_index,\nmin_slab_size,\nmin_vacuum_size,\ncenter_slab=True,\n**slabgen_kwargs,\n)\n# If the two terminations are not equivalent, make new slab\n# by inverting the original slab and add it to the list\nif flip_asymmetric:\nnew_slabs = []\nfor slab in slabs:\nif not slab.is_symmetric():\n# Flip the slab and its oriented unit cell\nnew_slab = flip_atoms(slab, return_struct=True)\nnew_oriented_unit_cell = flip_atoms(\nslab.oriented_unit_cell, return_struct=True\n)\n# Reconstruct the full slab object, noting the new\n# shift and oriented unit cell\nnew_slab = Slab(\nnew_slab.lattice,\nnew_slab.species,\ncoords=new_slab.frac_coords,\nmiller_index=slab.miller_index,\noriented_unit_cell=new_oriented_unit_cell,\nshift=-slab.shift,\nscale_factor=slab.scale_factor,\nsite_properties=new_slab.site_properties,\n)\n# It looks better to center the inverted slab so we do\n# that here.\nnew_slab = center_slab(new_slab)\n# Add the new slab to the list\nnew_slabs.append(new_slab)\nslabs.extend(new_slabs)\n# For each slab, make sure the lengths and widths are large enough\n# and fix atoms z_fix away from the top of the slab.\nslabs_with_props = []\nfor slab in slabs:\n# Make sure desired atoms are on surface\nif allowed_surface_symbols:\n# Find atoms at surface\nsurf_sites = AdsorbateSiteFinder(slab.copy()).surface_sites\nsurface_species = [s.specie.symbol for s in surf_sites]\nif allowed_surface_symbols and all(\nallowed_surface_atom not in surface_species\nfor allowed_surface_atom in allowed_surface_symbols\n):\ncontinue\n# Supercell creation (if necessary)\na_factor = int(np.ceil(min_length_width / slab.lattice.abc[0]))\nb_factor = int(np.ceil(min_length_width / slab.lattice.abc[1]))\nslab.make_supercell([a_factor, b_factor, 1])\n# Add constraints. Note: This does not actually add an adsorbate\nif z_fix:\nsel_dyn = AdsorbateSiteFinder(\nslab.copy(), selective_dynamics=True, height=z_fix\n).slab.site_properties[\"selective_dynamics\"]\nslab.add_site_property(\"selective_dynamics\", sel_dyn)\n# Add slab to list\nslabs_with_props.append(slab)\nfinal_slabs = []\nif not slabs_with_props:\nreturn final_slabs\n# Make atoms objects and store slab stats\nfor slab_with_props in slabs_with_props:\nfinal_slab = AseAtomsAdaptor.get_atoms(slab_with_props)\nslab_stats = {\n\"bulk\": atoms,\n\"miller_index\": slab_with_props.miller_index,\n\"shift\": round(slab_with_props.shift, 3),\n\"scale_factor\": slab_with_props.scale_factor,\n}\nfinal_slab.info = atoms_info.copy()\nfinal_slab.info[\"slab_stats\"] = slab_stats\nfinal_slabs.append(final_slab)\nreturn final_slabs\n</code></pre>"},{"location":"reference/quacc/utils/thermo.html","title":"thermo","text":"<p>Utility functions for thermochemistry</p>"},{"location":"reference/quacc/utils/thermo.html#quacc.utils.thermo.ideal_gas","title":"ideal_gas","text":"<pre><code>ideal_gas(\natoms, vib_freqs, energy=0.0, spin_multiplicity=None\n)\n</code></pre> <p>Calculate thermodynamic properties for a molecule from a given vibrational analysis. This is for free gases only and will not be valid for solids or adsorbates on surfaces. Any imaginary vibrational modes after the 3N-5/3N-6 cut will simply be ignored.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>The Atoms object associated with the vibrational analysis.</p> </li> <li> vib_freqs             (<code>list[float | complex]</code>)         \u2013          <p>The list of vibrations to use in cm^-1, typically obtained from Vibrations.get_frequencies().</p> </li> <li> energy             (<code>float</code>, default:                 <code>0.0</code> )         \u2013          <p>Potential energy in eV. If 0 eV, then the thermochemical correction is computed.</p> </li> <li> spin_multiplicity             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The spin multiplicity (2S+1). If None, this will be determined automatically from the attached magnetic moments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>IdealGasThermo object</code>         \u2013          </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/thermo.py</code> <pre><code>def ideal_gas(\natoms: Atoms,\nvib_freqs: list[float | complex],\nenergy: float = 0.0,\nspin_multiplicity: int | None = None,\n) -&gt; IdealGasThermo:\n\"\"\"\n    Calculate thermodynamic properties for a molecule from a given vibrational analysis.\n    This is for free gases only and will not be valid for solids or adsorbates on surfaces.\n    Any imaginary vibrational modes after the 3N-5/3N-6 cut will simply be ignored.\n    Parameters\n    ----------\n    atoms\n        The Atoms object associated with the vibrational analysis.\n    vib_freqs\n        The list of vibrations to use in cm^-1, typically obtained from Vibrations.get_frequencies().\n    energy\n        Potential energy in eV. If 0 eV, then the thermochemical correction is computed.\n    spin_multiplicity\n        The spin multiplicity (2S+1). If None, this will be determined automatically from the\n        attached magnetic moments.\n    Returns\n    -------\n    IdealGasThermo object\n    \"\"\"\n# Switch off PBC since this is only for molecules\natoms.set_pbc(False)\n# Ensure all negative modes are made complex\nfor i, f in enumerate(vib_freqs):\nif not isinstance(f, complex) and f &lt; 0:\nvib_freqs[i] = complex(0 - f * 1j)\n# Convert vibrational frequencies to energies\nvib_energies = [f * units.invcm for f in vib_freqs]\n# Get the spin from the Atoms object.\nif spin_multiplicity:\nspin = (spin_multiplicity - 1) / 2\nelif (\ngetattr(atoms, \"calc\", None) is not None\nand getattr(atoms.calc, \"results\", None) is not None\nand atoms.calc.results.get(\"magmom\", None) is not None\n):\nspin = round(atoms.calc.results[\"magmom\"]) / 2\nelif (\ngetattr(atoms, \"calc\", None) is not None\nand getattr(atoms.calc, \"results\", None) is not None\nand atoms.calc.results.get(\"magmoms\", None) is not None\n):\nspin = round(np.sum(atoms.calc.results[\"magmoms\"])) / 2\nelif atoms.has(\"initial_magmoms\"):\nspin = round(np.sum(atoms.get_initial_magnetic_moments())) / 2\nelse:\nspin = 0\n# Get symmetry for later use\nnatoms = len(atoms)\nmetadata = atoms_to_metadata(atoms)\n# Get the geometry\nif natoms == 1:\ngeometry = \"monatomic\"\nelif metadata[\"symmetry\"][\"linear\"]:\ngeometry = \"linear\"\nelse:\ngeometry = \"nonlinear\"\nreturn IdealGasThermo(\nvib_energies,\ngeometry,\npotentialenergy=energy,\natoms=atoms,\nsymmetrynumber=metadata[\"symmetry\"][\"rotation_number\"],\nspin=spin,\nignore_imag_modes=True,\n)\n</code></pre>"},{"location":"reference/quacc/utils/wflows.html","title":"wflows","text":""},{"location":"reference/quacc/utils/wflows.html#quacc.utils.wflows.fetch_atoms","title":"fetch_atoms","text":"<pre><code>fetch_atoms(atoms)\n</code></pre> <p>Returns an Atoms object from a typical quacc recipe input, which can either be an <code>Atoms</code> object or a dictionary with an entry <code>{\"atoms\": Atoms}</code>. It may seem a bit silly to do this, but there is a purpose. If you want to write a workflow where the output of one recipe is passed to the input of another recipe, you can always do output[\"atoms\"] to fetch the output Atoms object to pass to the input to the second function. However, this process will often be its own compute step in workflow management tools because they need to resolve the output in order to query it. Depending on the workflow manager, this can be a waste of compute resources, so it's oftentimes better to do this parsing inside the compute task itself, which is why passing in the raw dictionary can be preferred.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or dictionary with an entry {\"atoms\": Atoms}</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>Atoms object</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/wflows.py</code> <pre><code>def fetch_atoms(atoms: Atoms | dict) -&gt; Atoms:\n\"\"\"\n    Returns an Atoms object from a typical quacc recipe input, which can\n    either be an `Atoms` object or a dictionary with an entry `{\"atoms\": Atoms}`.\n    It may seem a bit silly to do this, but there is a purpose. If you want to\n    write a workflow where the output of one recipe is passed to the input of\n    another recipe, you can always do output[\"atoms\"] to fetch the output Atoms\n    object to pass to the input to the second function. However, this process\n    will often be its own compute step in workflow management tools because they\n    need to resolve the output in order to query it. Depending on the workflow manager,\n    this can be a waste of compute resources, so it's oftentimes better to do this\n    parsing inside the compute task itself, which is why passing in the raw dictionary\n    can be preferred.\n    Parameters\n    ----------\n    atoms\n        Atoms object or dictionary with an entry {\"atoms\": Atoms}\n    Returns\n    -------\n    Atoms\n        Atoms object\n    \"\"\"\ntry:\nreturn atoms[\"atoms\"]\nexcept Exception:\nreturn atoms\n</code></pre>"},{"location":"reference/quacc/utils/wflows.html#quacc.utils.wflows.flow","title":"flow","text":"<pre><code>flow(_func=None, **kwargs)\n</code></pre> <p>Decorator for workflows, which consist of at least one compute job. This is a @flow decorator.</p> <p>@flow = @ct.lattice [Covalent]. For Parsl and Jobflow, the decorator returns the undecorated function.</p> <p>Parameters:</p> <ul> <li> _func             (<code>callable | None</code>, default:                 <code>None</code> )         \u2013          <p>The function to decorate.</p> </li> <li> **kwargs         \u2013          <p>Keyword arguments to pass to the decorator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>callable</code>         \u2013          <p>The decorated function.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/wflows.py</code> <pre><code>def flow(_func: callable | None = None, **kwargs) -&gt; callable | ct_lattice:\n\"\"\"\n    Decorator for workflows, which consist of at least one compute job. This is a @flow decorator.\n    @flow = @ct.lattice [Covalent]. For Parsl and Jobflow, the decorator returns the\n    undecorated function.\n    Parameters\n    ----------\n    _func\n        The function to decorate.\n    **kwargs\n        Keyword arguments to pass to the decorator.\n    Returns\n    -------\n    callable\n        The decorated function.\n    \"\"\"\nfrom quacc import SETTINGS\nwflow_engine = (\nSETTINGS.WORKFLOW_ENGINE.lower() if SETTINGS.WORKFLOW_ENGINE else None\n)\nif wflow_engine == \"covalent\":\nimport covalent as ct\ndecorated = ct.lattice(_func, **kwargs)\nelif wflow_engine in {\"jobflow\", \"parsl\"} or not wflow_engine:\ndecorated = _func\nelse:\nmsg = f\"Unknown workflow engine: {wflow_engine}\"\nraise ValueError(msg)\nreturn decorated\n</code></pre>"},{"location":"reference/quacc/utils/wflows.html#quacc.utils.wflows.job","title":"job","text":"<pre><code>job(_func=None, **kwargs)\n</code></pre> <p>Decorator for individual compute jobs. This is a @job decorator.</p> <p>@job = @ct.electron [Covalent] = @python_app [Parsl] = @job [Jobflow]</p> <p>Parameters:</p> <ul> <li> _func             (<code>callable | None</code>, default:                 <code>None</code> )         \u2013          <p>The function to decorate.</p> </li> <li> **kwargs         \u2013          <p>Keyword arguments to pass to the decorator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>callable</code>         \u2013          <p>The decorated function. The decorated function will have an attribute <code>undecorated</code> which is the undecorated function.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/wflows.py</code> <pre><code>def job(\n_func: callable | None = None, **kwargs\n) -&gt; callable | ct_electron | JobflowJob | PythonApp:\n\"\"\"\n    Decorator for individual compute jobs. This is a @job decorator.\n    @job = @ct.electron [Covalent] = @python_app [Parsl] = @job [Jobflow]\n    Parameters\n    ----------\n    _func\n        The function to decorate.\n    **kwargs\n        Keyword arguments to pass to the decorator.\n    Returns\n    -------\n    callable\n        The decorated function. The decorated function will have an attribute `undecorated`\n        which is the undecorated function.\n    \"\"\"\nfrom quacc import SETTINGS\nwflow_engine = (\nSETTINGS.WORKFLOW_ENGINE.lower() if SETTINGS.WORKFLOW_ENGINE else None\n)\nif wflow_engine == \"covalent\":\nimport covalent as ct\ndecorated = ct.electron(_func, **kwargs)\nelif wflow_engine == \"jobflow\":\nfrom jobflow import job as jf_job\ndecorated = jf_job(_func, **kwargs)\nelif wflow_engine == \"parsl\":\nfrom parsl import python_app\ndecorated = python_app(_func, **kwargs)\nelif not wflow_engine:\ndecorated = _func\nelse:\nmsg = f\"Unknown workflow engine: {wflow_engine}\"\nraise ValueError(msg)\ndecorated.undecorated = _func\nreturn decorated\n</code></pre>"},{"location":"reference/quacc/utils/wflows.html#quacc.utils.wflows.subflow","title":"subflow","text":"<pre><code>subflow(_func=None, **kwargs)\n</code></pre> <p>Decorator for (dynamic) sub-workflows. This is a @subflow decorator.</p> <p>@subflow = @ct.electron(@ct.lattice) [Covalent] = @join_app [Parsl]. For Jobflow, the decorator returns the undecorated function.</p> <p>Parameters:</p> <ul> <li> _func             (<code>callable | None</code>, default:                 <code>None</code> )         \u2013          <p>The function to decorate.</p> </li> <li> **kwargs         \u2013          <p>Keyword arguments to pass to the decorator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>callable</code>         \u2013          <p>The decorated function.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/utils/wflows.py</code> <pre><code>def subflow(_func: callable | None = None, **kwargs) -&gt; callable | ct_electron:\n\"\"\"\n    Decorator for (dynamic) sub-workflows. This is a @subflow decorator.\n    @subflow = @ct.electron(@ct.lattice) [Covalent] = @join_app [Parsl].\n    For Jobflow, the decorator returns the undecorated function.\n    Parameters\n    ----------\n    _func\n        The function to decorate.\n    **kwargs\n        Keyword arguments to pass to the decorator.\n    Returns\n    -------\n    callable\n        The decorated function.\n    \"\"\"\nfrom quacc import SETTINGS\nwflow_engine = (\nSETTINGS.WORKFLOW_ENGINE.lower() if SETTINGS.WORKFLOW_ENGINE else None\n)\nif wflow_engine == \"covalent\":\nimport covalent as ct\ndecorated = ct.electron(ct.lattice(_func), **kwargs)\nelif wflow_engine == \"parsl\":\nfrom parsl import join_app\ndecorated = join_app(_func, **kwargs)\nelif wflow_engine == \"jobflow\" or not wflow_engine:\ndecorated = _func\nelse:\nmsg = f\"Unknown workflow engine: {wflow_engine}\"\nraise ValueError(msg)\nreturn decorated\n</code></pre>"},{"location":"start/demo.html","title":"Quick Start","text":"<p>Want to get up and running with quacc as fast possible? Here we go!</p>"},{"location":"start/demo.html#installation","title":"Installation","text":"<p>Run the following commands in the terminal:</p> <pre><code>pip install --upgrade https://gitlab.com/ase/ase/-/archive/master/ase-master.zip\npip install quacc[covalent]\ncovalent start\n</code></pre> <p>Then open the URL printed in the terminal (usually http://localhost:48008) and run a sample workflow below!</p> <p>Tip</p> <p>Don't want to use Covalent? No problem! Quacc supports a variety of workflow managers (or none at all!).</p>"},{"location":"start/demo.html#demo-workflow-1-a-simple-one","title":"Demo Workflow 1: A Simple One","text":"<p>This demo workflow will relax a bulk Cu structure using the EMT calculator.</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\n# Define the workflow\nworkflow = flow(relax_job)\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Dispatch the workflow to the Covalent server\n# with the bulk Cu Atoms object as the input\ndispatch_id = ct.dispatch(workflow)(atoms)\n# Fetch the result from the server\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <p></p>"},{"location":"start/demo.html#demo-workflow-2-a-more-complex-one","title":"Demo Workflow 2: A More Complex One","text":"<p>This demo workflow will relax a bulk Cu structure using the EMT calculator, use the relaxed structure to generate a set of surface slabs, and then run a relaxation and static calculation on each generated slab.</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n# Define the workflow and set how to execute\n@flow(executor=\"local\")\ndef workflow(atoms):\n# Relax a bulk structure\nrelaxed_bulk = relax_job(atoms)\n# With the relaxed bulk as input, generate and relax slabs\nrelaxed_slabs = bulk_to_slabs_flow(relaxed_bulk)\nreturn relaxed_slabs\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Dispatch the workflow to the Covalent server\n# with the bulk Cu Atoms object as the input\ndispatch_id = ct.dispatch(workflow)(atoms)\n# Fetch the result from the server\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <p></p>"},{"location":"start/demo.html#what-next","title":"What Next?","text":"<p>Read through the User Guide to learn more about using quacc! And of course, feel free to explore the calculations you just ran in the Covalent UI.</p> <p></p>"},{"location":"user/recipes_intro.html","title":"Intro to Recipes","text":"<p>In quacc, each code comes with pre-packaged jobs and workflows, which we call recipes for short. This tutorial walks you through how to use these provided recipes to run simple calculations that can be tested out on your local machine.</p>"},{"location":"user/recipes_intro.html#pre-requisites","title":"Pre-Requisites","text":"<p>If you are not yet familiar with the ASE <code>Atoms</code> object, you should read the ASE tutorial, as this is the main object used to represent molecules and structures within quacc. Additionally, it is worthwhile to be familiar with the basics of an ASE Calculator. The \"Open Science with ASE: Core Tutorials\" is also an excellent resource for learning about the basics of ASE in a structured way.</p> <p>Tip</p> <p>If you are coming from the Pymatgen ecosystem, you can use the <code>pymatgen.io.ase.AseAtomsAdaptor</code> class to convert between Pymatgen <code>Structure</code>/<code>Molecule</code> objects and the ASE <code>Atoms</code> object.</p>"},{"location":"user/recipes_intro.html#examples","title":"Examples","text":""},{"location":"user/recipes_intro.html#a-simple-calculation-with-emt","title":"A Simple Calculation with EMT","text":"<pre><code>graph LR\n  A[Input] --&gt; B(EMT Relax) --&gt; C[Output]</code></pre> <p>Let's start with a simple example. Here, we will use a cheap calculator based on effective medium theory (EMT) to run a structure relaxation on a bulk structure of copper, as shown below.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Run a structure relaxation on the Atoms object\nresult = relax_job(atoms)\nprint(result)\n</code></pre> <p>Walking through step-by-step, we first defined an <code>Atoms</code> object representation of the material we wish to run the calculation on. In this example, we have imported the bulk Cu structure from ASE's predefined library of bulk structures.</p> <p>With the <code>Atoms</code> object defined, we then imported a desired recipe and instantiated it. In this case, since we want to use EMT, we can look in <code>quacc.recipes.emt</code> to see all the available recipes. We are interested in doing a structure relaxation, so we imported the <code>quacc.recipes.emt.core.relax_job</code> recipe. We then instantiated and ran the recipe by passing in the <code>Atoms</code> object we defined earlier.</p> <p>The recipe output (<code>result</code>) is a bit too large to print here; nonetheless, for context, it is a dictionary that has the following primary keys:</p> <pre><code>[\n\"atoms\",\n\"atoms_info\",\n\"builder_meta\",\n\"chemsys\",\n\"composition\",\n\"composition_reduced\",\n\"density\",\n\"density_atomic\",\n\"dir_name\",\n\"elements\",\n\"formula_anonymous\",\n\"formula_pretty\",\n\"input_structure\",\n\"name\",\n\"nelements\",\n\"nid\",\n\"nsites\",\n\"parameters\",\n\"parameters_opt\",\n\"results\",\n\"structure\",\n\"symmetry\",\n\"trajectory\",\n\"trajectory_results\",\n\"volume\",\n]\n</code></pre> <p>The <code>\"atoms\"</code> key contains a copy of the output <code>Atoms</code> object, the <code>\"results\"</code> key contains a dictionary of the results of the calculation, and the <code>\"parameters\"</code> key contains a dictionary of the parameters used in the calculation.</p> <p>Tip</p> <p>You can make an <code>Atoms</code> object from common files like a CIF, XYZ, or POSCAR by using the <code>ase.io.read</code> function. For instance, <code>from ase.io import read</code> followed by <code>atoms = read(\"&lt;/path/to/file&gt;\")</code>.</p>"},{"location":"user/recipes_intro.html#a-simple-mixed-code-workflow","title":"A Simple Mixed-Code Workflow","text":"<pre><code>graph LR\n  A[Input] --&gt; B(EMT Relax) --&gt; C(GFN2-xTB Static) --&gt; D[Output]</code></pre> <p>Now let's return to our bulk Cu example from above and start adding on some complexity. Here, we will use EMT to run a relaxation on the bulk Cu structure and then use the output of this calculation as the input to a static calculation with the semi-empirical quantum mechanics method GFN2-xTB as implemented in <code>quacc.recipes.tblite.core.static_job</code>. This example highlights how there are no restrictions in terms of how many codes you can use in a single workflow.</p> <p>Note</p> <p>Some codes require additional setup, including <code>tblite</code>. Refer to the Calculator Setup section for details.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.tblite.core import static_job\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Run a structure relaxation with EMT\nresult1 = relax_job(atoms)\n# Run a static calculation with GFN2-xTB\nresult2 = static_job(result1, method=\"GFN2-xTB\")\nprint(result2)\n</code></pre> <p>Tip</p> <p>The output of most compute jobs is a dictionary summarizing the results of the calculation. It always has a key <code>\"atoms\"</code> that contains a copy of the output <code>Atoms</code> object. The first argument to all recipes accepts either the <code>Atoms</code> object directly or a dictionary containing it.</p> <p>What happens if the first job fails, you might ask? Then the code will crash, no results will be stored, and you'd have to start from scratch. That'd be sad, but thankfully this is where using a workflow manager can save the day.</p> <p>Read on to learn how to define workflows with complex connectivity and how to dispatch them across distributed computing resources.</p>"},{"location":"user/settings.html","title":"Settings Management","text":""},{"location":"user/settings.html#modifying-quacc-settings","title":"Modifying Quacc Settings","text":"<p>The default global quacc settings can be found in the <code>settings.py</code> file. If you wish to modify any of the global quacc settings, there are several ways to do so.</p>"},{"location":"user/settings.html#using-a-yaml-file","title":"Using a YAML File","text":"<p>If you are planning to modify parameters for most of your calculations, the easiest way is to create a YAML file with custom settings. For instance, it might look something like the following if you wanted to modify the <code>WORKFLOW_ENGINE</code>, <code>SCRATCH_DIR</code>, and <code>CREATE_UNIQUE_WORKDIR</code> settings for all your workflows.</p> ~/.quacc.yaml<pre><code>WORKFLOW_ENGINE: covalent # (1)!\nSCRATCH_DIR: /tmp # (2)!\nCREATE_UNIQUE_WORKDIR: true # (3)!\n</code></pre> <ol> <li> <p>This would set the workflow engine to Covalent. If you wish to disable the use of a workflow engine, set this to <code>null</code>.</p> </li> <li> <p>This would set the quacc scratch directory to <code>/tmp</code> on whatever machine the calculations are run on.</p> </li> <li> <p>This would ensure that each job in your quacc workflow is run in a unique, isolated working directory. This is often useful when running workflows in parallel, although some workflow engines like Covalent have their own mechanisms for this.</p> </li> </ol> <p>By default, quacc looks for this YAML file at <code>~/.quacc.yaml</code>. If you wish to store the YAML file somewhere else or with a different name, you can define the environment variable <code>QUACC_CONFIG_FILE</code> and point it to the YAML path of your choosing.</p>"},{"location":"user/settings.html#using-environment-variables","title":"Using Environment Variables","text":"<p>If you want to define quacc settings on-the-fly without writing them to a YAML file, you can instead modify the desired settings by defining individual environment variables with <code>QUACC</code> as the prefix. For instance, to modify the <code>SCRATCH_DIR</code> setting to be <code>/tmp</code>, simply define <code>QUACC_SCRATCH_DIR=/tmp</code> as a new environment variable.</p>"},{"location":"user/settings.html#modifying-the-global-settings-in-a-script","title":"Modifying the Global Settings in a Script","text":"<p>If you want to define quacc settings on-the-fly without writing them to a YAML file or using environment variables, you can do so within your script by modifying the <code>SETTINGS</code> object as follows:</p> <pre><code>from quacc import SETTINGS\nSETTINGS.CREATE_UNIQUE_WORKDIR = True\n</code></pre> <p>Important</p> <p>If you use this method to modify the <code>WORKFLOW_ENGINE</code> setting, note that you must do so before importing any recipes (e.g. at the top of your script or notebook).</p>"},{"location":"user/settings.html#list-of-quacc-settings","title":"List of Quacc Settings","text":"quacc/settings.py<pre><code>    # ---------------------------\n    # Workflow Engine\n    # ---------------------------\n    WORKFLOW_ENGINE: Optional[str] = Field(\n        \"covalent\"\n        if covalent\n        else \"parsl\"\n        if parsl\n        else \"jobflow\"\n        if jobflow\n        else None,\n        description=(\n            \"The workflow manager to use.\"\n            \"Options include: 'covalent', 'parsl', 'jobflow', or None\"\n        ),\n    )\n\n    # ---------------------------\n    # General Settings\n    # ---------------------------\n\n    CONFIG_FILE: str = Field(\n        _DEFAULT_CONFIG_FILE_PATH,\n        description=(\n            \"Path to the YAML file to load alternative quacc configuration \"\n            \"defaults from.\"\n        ),\n    )\n    RESULTS_DIR: str = Field(\n        os.getcwd(),\n        description=(\n            \"Directory to store I/O-based calculation results in.\"\n            \"Note that this behavior may be modified by the chosen workflow engine.\"\n            \"For instance, Covalent specifies the base directory as the `workdir` \"\n            \"of a local executor or the `remote_workdir` of a remote executor.\"\n            \"In this case, the `RESULTS_DIR` will be a subdirectory of that directory.\"\n        ),\n    )\n    SCRATCH_DIR: str = Field(\n        \"/tmp\" if os.path.exists(\"/tmp\") else os.getcwd(),\n        description=\"Scratch directory for calculations.\",\n    )\n    CREATE_UNIQUE_WORKDIR: bool = Field(\n        False,\n        description=(\n            \"Whether to have a unique working directory in RESULTS_DIR for each job.\"\n            \"Some workflow engines have an option to do this for you already.\"\n        ),\n    )\n    GZIP_FILES: bool = Field(\n        True, description=\"Whether generated files should be gzip'd.\"\n    )\n    CHECK_CONVERGENCE: bool = Field(\n        True,\n        description=\"Whether to check for convergence in the `summarize_run`-type functions, if supported.\",\n    )\n\n    # ---------------------------\n    # Data Store Settings\n    # ---------------------------\n    PRIMARY_STORE: str = Field(\n        None,\n        description=(\n            \"String-based JSON representation of the primary Maggma data store \"\n            \"where calculation results will be stored.\"\n            \"Taken from the `.to_json()` method of the corresponding Store object.\"\n        ),\n    )\n\n    # ---------------------------\n    # ORCA Settings\n    # ---------------------------\n    ORCA_CMD: str = Field(\n        \"orca\",\n        description=(\n            \"Path to the ORCA executable. This must be the full, absolute path \"\n            \"for parallel calculations to work.\"\n        ),\n    )\n\n    # ---------------------------\n    # VASP Settings\n    # ---------------------------\n\n    # VASP Settings: Main\n    VASP_PARALLEL_CMD: str = Field(\n        \"\",\n        description=(\n            \"Parallel command to run VASP with Custodian.\"\n            \"For example: srun -N 2 --ntasks-per-node 48\"\n            \"Note that this does not include the executable name.\"\n        ),\n    )\n    VASP_CMD: str = Field(\n        \"vasp_std\", description=\"Command to run the standard version of VASP.\"\n    )\n    VASP_GAMMA_CMD: str = Field(\n        \"vasp_gam\", description=\"Command to run the gamma-point only version of VASP.\"\n    )\n\n    # VASP Settings: General\n    VASP_INCAR_COPILOT: bool = Field(\n        True,\n        description=(\n            \"Whether co-pilot mode should be used for VASP INCAR handling.\"\n            \"This will modify INCAR flags on-the-fly if they disobey the VASP manual.\"\n            \"A warning will be raised in each case.\"\n        ),\n    )\n    VASP_BADER: bool = Field(\n        bool(which(\"bader\")),\n        description=(\n            \"Whether to run a Bader analysis when summarizing VASP results.\"\n            \"Requires bader to be in PATH.\"\n        ),\n    )\n    VASP_PRESET_MAG_DEFAULT: float = Field(\n        1.0,\n        description=(\n            \"Default initial magmom to use for a given element if a preset \"\n            \"with magmoms is provided but an element is missing from the list\"\n        ),\n    )\n    VASP_MAG_CUTOFF: float = Field(\n        0.05,\n        description=(\n            \"If the absolute value of all magnetic moments are below this value, \"\n            \"they will be set to 0 such that a spin-unpolarized calculation will be performed\"\n        ),\n    )\n    VASP_COPY_MAGMOMS: bool = Field(\n        True,\n        description=(\n            \"If True, any pre-existing atoms.get_magnetic_moments() will be set\"\n            \"in atoms.set_initial_magnetic_moments().\"\n        ),\n    )\n    VASP_VERBOSE: bool = Field(\n        True,\n        description=\"If True, warnings will be raised when INCAR parameters are changed.\",\n    )\n    VASP_PRESET_DIR: str = Field(\n        os.path.dirname(vasp_defaults.__file__),\n        description=\"Path to the VASP preset directory\",\n    )\n\n    # VASP Settings: Custodian\n    VASP_USE_CUSTODIAN: bool = Field(\n        True, description=\"Whether Custodian should be used to run VASP\"\n    )\n    VASP_CUSTODIAN_VTST: bool = Field(\n        False,\n        description=(\n            \"If VTST-related input swaps should be used when running Custodian.\"\n            \"Requires VASP to be compiled with VTST\"\n        ),\n    )\n    VASP_CUSTODIAN_MAX_ERRORS: int = Field(\n        5, description=\"Maximum errors for Custodian\"\n    )\n    VASP_CUSTODIAN_HANDLERS: List[str] = Field(\n        [\n            \"VaspErrorHandler\",\n            \"MeshSymmetryErrorHandler\",\n            \"UnconvergedErrorHandler\",\n            \"NonConvergingErrorHandler\",\n            \"PotimErrorHandler\",\n            \"PositiveEnergyErrorHandler\",\n            \"FrozenJobErrorHandler\",\n            \"StdErrHandler\",\n            \"LargeSigmaHandler\",\n            \"IncorrectSmearingHandler\",\n        ],\n        description=\"Handlers for Custodian\",\n    )\n    VASP_CUSTODIAN_VALIDATORS: List[str] = Field(\n        [\"VasprunXMLValidator\", \"VaspFilesValidator\"],\n        description=\"Validators for Custodian\",\n    )\n    VASP_CUSTODIAN_WALL_TIME: Optional[int] = Field(\n        None,\n        description=(\n            \"After this many seconds, Custodian will stop running \"\n            \"and ensure that VASP writes a STOPCAR\"\n        ),\n    )\n\n    # ---------------------------\n    # Q-Chem Settings\n    # ---------------------------\n\n    # Q-Chem Settings: Main\n    QCHEM_CMD: str = Field(\n        \"qchem\", description=\"Command to run the standard version of Q-Chem.\"\n    )\n\n    QCHEM_LOCAL_SCRATCH: str = Field(\n        \"/tmp\" if os.path.exists(\"/tmp\") else os.getcwd(),\n        description=\"Compute-node local scratch directory in which Q-Chem should perform IO.\",\n    )\n\n    # Q-Chem Settings: Custodian\n    QCHEM_USE_ERROR_HANDLERS: bool = Field(\n        True,\n        description=\"Whether Custodian's error handlers should be employed for Q-Chem.\",\n    )\n\n    QCHEM_CUSTODIAN_MAX_ERRORS: int = Field(\n        5, description=\"Maximum errors for Q-Chem Custodian.\"\n    )\n\n    # ---------------------------\n    # NewtonNet Settings\n    # ---------------------------\n    NEWTONNET_MODEL_PATH: Union[str, List[str]] = Field(\n        \"best_model_state.tar\", description=\"Path to NewtonNet .tar model\"\n    )\n    NEWTONNET_CONFIG_PATH: Union[str, List[str]] = Field(\n        \"config.yml\", description=\"Path to NewtonNet YAML settings file\"\n    )\n</code></pre>"},{"location":"user/advanced/atomate2.html","title":"Quacc + Atomate2","text":"<p>Atomate2 is a fantastic computational materials science workflow program that shares many similarities with quacc. If you wish to combine workflows from quacc with those from Atomate2, that is possible through the use of Jobflow.</p> <p>Tip</p> <p>Refer to the Using a Workflow Engine guide for more information on how to use Jobflow with quacc.</p> <p>For instance, consider a toy example where you want to relax a bulk Cu structure using the <code>tblite</code> calculator in quacc, which you then use to run a VASP relaxation and bandstructure workflow in Atomate2. That would look like the following.</p> <pre><code>from ase.build import bulk\nfrom atomate2.vasp.flows.core import RelaxBandStructureMaker\nfrom jobflow import Flow\nfrom quacc.recipes.tblite.core import relax_job\natoms = bulk(\"Cu\")\njob1 = relax_job(atoms)\nbandstructure_flow = RelaxBandStructureMaker().make_flow(\njob1.output[\"structure\"]\n)  # (1)!\nflow = Flow([job1]) + bandstructure_flow  # (2)!\n</code></pre> <ol> <li> <p>All Atomate2 workflows take a Pymatgen <code>Structure</code> or <code>Molecule</code> object as input. This is one of the properties in the returned output of a quacc recipe, which is why we can do <code>job1.output[\"structure\"]</code>.</p> </li> <li> <p>The <code>+</code> operator can be used to combine two flows into one. We converted the first job into its own <code>Flow</code> definition to enable this.</p> </li> </ol>"},{"location":"user/advanced/database.html","title":"Using a Database","text":"<p>Oftentimes, it is beneficial to store the results in a database for easy querying (like the example below). This is quite simple to do in quacc regardless of the workflow manager you are using by taking advantage of the numerous data store options in maggma.</p> <p></p> General PurposeCovalentJobflow <p>Automated Approach</p> <p>For a given recipe, you can have quacc automatically store the final output summaries in your desired database by defining a Maggma data store in the <code>PRIMARY_STORE</code> quacc setting.</p> <p>For instance, let's pretend you have decided to make a <code>MongoStore</code> be your database of choice. After defining or loading your Maggma store, you would call <code>.to_json()</code> to get a dictionary representation. You can then store this JSON, formatted as a string, in the <code>PRIMARY_STORE</code> global quacc setting.</p> <pre><code>from maggma.stores import MongoStore\nstore = MongoStore(\n\"my_db_name\",\n\"my_collection_name\",\nusername=\"my_username\",\npassword=\"my_password\",\nhost=\"localhost\",\nport=27017,\n)\nprint(store.to_json())  # This is the JSON string you would store in PRIMARY_STORE\n</code></pre> ~/.quacc.yaml<pre><code>PRIMARY_STORE: '{\"@module\": \"maggma.stores.mongolike\", \"@class\": \"MongoStore\", \"@version\": \"0.51.19\", \"database\": \"my_db_name\", \"collection_name\": \"my_collection_name\", \"host\": \"localhost\", \"port\": 27017, \"username\": \"my_username\", \"password\": \"my_password\", \"ssh_tunnel\": null, \"safe_update\": false, \"auth_source\": \"my_db_name\", \"mongoclient_kwargs\": {}, \"default_sort\": null}'\n</code></pre> <p>Manual Approach</p> <p>If you would prefer to store results in your database manually (perhaps because you are limited in terms of how much data you can store), you can use the <code>quacc.utils.db.results_to_db</code> function, as shown in the example below.</p> <pre><code>from maggma.stores import MongoStore\nfrom quacc.utils.db import results_to_db\n# Let `results` be an output (or list of outputs) from quacc recipes\n# Define your database details\nstore = MongoStore(\n\"my_db_name\",\n\"my_collection_name\",\nusername=\"my_username\",\npassword=\"my_password\",\nhost=\"localhost\",\nport=27017,\n)\n# Store the results\nresults_to_db(store, results)\n</code></pre> <p>Covalent automatically stores all the inputs and outputs in an SQLite database, which you can find at the <code>\"db_path\"</code> when you run <code>covalent config</code>, and the results can be queried using the <code>ct.get_result(&lt;dispatch ID&gt;)</code> syntax. However, if you want to store the results in a different database of your choosing, you can do so quite easily.</p> <p>An example is shown below for storing the results in your custom database via the <code>quacc.utils.db.covalent_to_db</code> function.</p> <pre><code>from maggma.stores import MongoStore\nfrom quacc.utils.db import covalent_to_db\n# Define your database credentials\nstore = MongoStore(\n\"my_db_name\",\n\"my_collection_name\",\nusername=\"my_username\",\npassword=\"my_password\",\nhost=\"localhost\",\nport=27017,\n)\n# Store the results\ncovalent_to_db(store)\n</code></pre> <p>If you are using Jobflow to construct your workflows, it will automatically store the results in the database you defined during the setup process. No additional steps are needed.</p>"},{"location":"user/advanced/file_transfers.html","title":"Transferring Files","text":""},{"location":"user/advanced/file_transfers.html#local-file-transfers","title":"Local File Transfers","text":""},{"location":"user/advanced/file_transfers.html#transfers-from-a-known-file-location","title":"Transfers from a Known File Location","text":"<p>Sometimes, you may want to transfer files between jobs. Every recipe within quacc takes an optional keyword argument <code>copy_files</code> that is a list of absolute filepaths to files you wish to have copied to the directory where the calculation is ultimately run.</p> <p>For instance, if you have a file <code>WAVECAR</code> stored in <code>/path/to/my/file/stage</code>, then you could ensure that is present in the calculation's working directory as follows:</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.vasp.core import relax_job\natoms = bulk(\"Cu\")\nrelax_job(atoms, copy_files=[\"/path/to/my/file/stage/WAVECAR\"])\n</code></pre>"},{"location":"user/advanced/file_transfers.html#transfers-between-jobs","title":"Transfers Between Jobs","text":"<p>Sometimes, however, you may not necessarily know a priori where the source file is. For instance, perhaps you want to copy the file <code>WAVECAR</code> from a previous job in your workflow that is stored in a unique directory only determined at runtime. In this scenario, you can still use the <code>copy_files</code> keyword argument, but you will need to fetch the prior job's directory. This can be done as follows:</p> <pre><code>import os\nfrom ase.build import bulk\nfrom quacc.recipes.vasp.core import relax_job, static_job\natoms = bulk(\"Cu\")\nresults1 = relax_job(atoms)\nstatic_job(results1, copy_files=[os.path.join(results1[\"dir_name\"], \"WAVECAR\")])\n</code></pre>"},{"location":"user/advanced/file_transfers.html#non-local-file-transfers","title":"Non-Local File Transfers","text":"<p>If using quacc across distributed computing environments, there may not be a guarantee that the file you wish to transfer is even on the same machine as your current job. In this scenario, the best approach is to create a dedicated file staging area on your machine of choice where you can store files you wish to transfer.</p> <p>For instance, if using a job scheduler like Slurm, you could have a step in your job script that copies files (e.g. via <code>scp</code>) from a remote location to a local staging area. Then, you can use the <code>copy_files</code> keyword argument to copy the files from the staging area to the calculation's working directory.</p> <p>Alternatively, several of the supported workflow managers have built-in options to enable file staging. For instance, Covalent has a variety of options for file transfers that can be specified in the <code>@ct.electron</code> decorator or pre-instantiated <code>Electron</code> object, which can be used to automate file staging before the calculation begins (or after the calculation ends).</p>"},{"location":"user/basics/wflow_overview.html","title":"Workflow Engines Overview","text":"<p>Everyone's computing needs are different, so we ensured that quacc is interoperable with a variety of modern workflow management tools. There are 300+ workflow management tools out there, so we can't possibly support them all. Instead, we have focused on a select few that adopt a similar decorator-based approach to defining workflows with substantial support for HPC systems.</p>"},{"location":"user/basics/wflow_overview.html#choosing-a-workflow-engine","title":"Choosing a Workflow Engine","text":""},{"location":"user/basics/wflow_overview.html#summary","title":"Summary","text":"<p>Tip</p> <p>Generally, we highly recommend either Covalent or Parsl for most users. If you are new to workflow engines or would like a helpful UI to monitor workflows, try Covalent. If you have a need for speed and are savvy with supercomputers, try Parsl.</p>"},{"location":"user/basics/wflow_overview.html#pros-and-cons","title":"Pros and Cons","text":"CovalentParslJobflow <p>Covalent is a workflow management solution from the company Agnostiq.</p> <p>Pros:</p> <ul> <li>Extremely simple to setup and use, even for complex workflows</li> <li>Best-in-class visual dashboard for job monitoring</li> <li>Easy to use in distributed, heterogeneous compute environments</li> <li>Excellent documentation</li> <li>Automatic and simple database integration</li> <li>The compute nodes do not need to be able to connect to the internet</li> </ul> <p>Cons:</p> <ul> <li>Not as widely used as other workflow management solutions</li> <li>It requires a centralized server to be running continuously in order to manage the workflows</li> <li>High-security HPC environments may be difficult to access via SSH with the centralized server approach</li> <li>Not ideal for large numbers of short-duration jobs on remote HPC machines</li> </ul> <p>Parsl is a workflow management solution out of Argonne National Laboratory, the University of Chicago, and the University of Illinois. It is well-adapted for running on virtually any HPC environment with a job scheduler.</p> <p>Pros:</p> <ul> <li>Extremely configurable for virtually any HPC environment</li> <li>Relatively simple to define the workflows</li> <li>Active community, particularly across academia</li> <li>Well-suited for pilot jobs and has near-ideal scaling performance</li> <li>Thorough documentation</li> <li>Does not rely on maintaining a centralized server of any kind</li> </ul> <p>Cons:</p> <ul> <li>Defining the right configuration options for your desired HPC setup can be an initial hurdle</li> <li>Monitoring job progress is more challenging and less detailed than other solutions</li> <li>Challenging to orchestrate workflows with steps running across heterogeneous resources</li> <li>The concept of always returning a \"future\" object can be confusing for new users</li> </ul> <p>Jobflow is developed and maintained by the Materials Project team at Lawrence Berkeley National Laboratory and serves as a seamless interface to FireWorks for dispatching and monitoring compute jobs.</p> <p>Jobflow</p> <p>Pros:</p> <ul> <li>Simple interface for defining individual jobs and workflows</li> <li>Native support for databases</li> <li>Directly compatible with Atomate2</li> <li>Actively supported by the Materials Project team</li> </ul> <p>Cons:</p> <ul> <li>Parsing the output of a workflow is not as intuitive as other solutions</li> <li>Defining dynamic workflows with Jobflow's <code>Response</code> object can be slightly more complex than other solutions</li> <li>Only supports FireWorks for job dispatching at the moment</li> </ul> <p>FireWorks:</p> <p>Pros:</p> <ul> <li>FireWorks is well-suited for a variety of job management approaches</li> <li>Helpful dashboard for monitoring job progress</li> </ul> <p>Cons:</p> <ul> <li>FireWorks documentation can be difficult to navigate without prior experience</li> <li>FireWorks can have a steep learning curve due to its many configuration options</li> <li>The reliance on MongoDB can be challenging for new users and certain HPC environments</li> <li>New features are not currently planned</li> </ul>"},{"location":"user/basics/wflow_syntax.html","title":"Workflow Syntax","text":""},{"location":"user/basics/wflow_syntax.html#introduction","title":"Introduction","text":"<p>Here, we provide code snippets for several decorator-based workflow engines. For a comparison of the pros and cons of each approach, refer to the Workflow Engines Overview page. We describe the specifics of how to use each workflow engine in more detail later in the documentation. Nonetheless, this page serves as a quick point of reference that is independent of quacc-specific recipes.</p> <p>Tip</p> <p>You don't need to learn how to use all the different workflow solutions. You only need to learn the syntax for the one you plan to use! Regardless, the behavior is relatively similar across all of them.</p>"},{"location":"user/basics/wflow_syntax.html#examples","title":"Examples","text":""},{"location":"user/basics/wflow_syntax.html#simple-workflow","title":"Simple Workflow","text":"<p>Let's do the following:</p> <ol> <li>Add two numbers (e.g. <code>1 + 2</code>)</li> <li>Multiply the output of Step 1 by a third number (e.g. <code>3 * 3</code>)</li> </ol> <p>In practice, we would want each of the two tasks to be their own compute job.</p> <pre><code>graph LR\n  A[Input] --&gt; B(add) --&gt; C(mult) --&gt; D[Output];</code></pre> CovalentParslJobflow <p>Info</p> <p>For a more detailed tutorial on how to use Covalent, refer to the \"Covalent Quick Start\".</p> <p>Take a moment to learn about the main Covalent Concepts, namely the <code>@ct.electron</code> and <code>@ct.lattice</code> decorators, which describe individual compute tasks and workflows, respectively.</p> <p>All <code>Electron</code> and <code>Lattice</code> objects behave as normal Python functions when the necessary arguments are supplied. However, if the <code>ct.dispatch</code> command is used, the workflow will be dispatched to the Covalent server for execution and monitoring.</p> <p>Important</p> <p>If you haven't done so yet, make sure you started the Covalent server with <code>covalent start</code> in the command-line.</p> <pre><code>import covalent as ct\n@ct.electron #  (1)!\ndef add(a, b):\nreturn a + b\n@ct.electron\ndef mult(a, b):\nreturn a * b\n@ct.lattice #  (2)!\ndef workflow(a, b, c):\nreturn mult(add(a, b), c)\n# Locally\nresult = workflow(1, 2, 3)  # 9  (3)!\n# Dispatched\ndispatch_id = ct.dispatch(workflow)(1, 2, 3)  # (4)!\nprint(ct.get_result(dispatch_id, wait=True))  # 9  (5)!\n</code></pre> <ol> <li> <p><code>@ct.electron</code> tells Covalent to treat the function as a compute job.</p> </li> <li> <p><code>@ct.lattice</code> tells Covalent to treat the function as a workflow.</p> </li> <li> <p>If you call any <code>@ct.electron</code>- or <code>@ct.lattice</code>-decorated functions normally, Covalent will simply run it like a normal function.</p> </li> <li> <p>The <code>ct.dispatch</code> function tells Covalent to dispatch the workflow to the Covalent server. A unique dispatch ID will be returned instead of the actual result so that the result can be fetched asynchronously.</p> </li> <li> <p>The <code>ct.get_result</code> function tells Covalent to fetch the result from the server. We chose to set <code>wait=True</code> so that the function will block until the result is ready simply for demonstration purposes.</p> </li> </ol> <p>Info</p> <p>For a more detailed tutorial on how to use Parsl, refer to the \"Parsl Tutorial\" and the even more detailed \"Parsl User Guide\".</p> <p>Take a moment to read the Parsl documentation's \"Quick Start\" to get a sense of how Parsl works. Namely, you should understand the concept of a <code>@python_app</code> and <code>@join_app</code>, which describe individual compute tasks and dynamic job tasks, respectively.</p> <p>Important</p> <p>Make sure you run <code>import parsl</code> followed by <code>parsl.load()</code> in Python to load a default Parsl configuration.</p> <p>Also make sure you have specified <code>\"parsl\"</code> as the <code>WORKFLOW_ENGINE</code> in your quacc settings.</p> <pre><code>from parsl import python_app\n@python_app #  (1)!\ndef add(a, b):\nreturn a + b\n@python_app # @python_app\ndef mult(a, b):\nreturn a * b\nfuture1 = add(1, 2)\nfuture2 = mult(future1, 3)\nresult = future2.result()  # 9  (2)!\n</code></pre> <ol> <li> <p>The <code>@python_app</code> decorator tells Parsl to treat the function as a compute job.</p> </li> <li> <p><code>.result()</code> is a method that tells Parsl to wait for the result of the job. If <code>.result()</code> were not called, an <code>AppFuture</code> would be returned instead of the actual result.</p> </li> </ol> <p>Info</p> <p>For a more detailed tutorial on how to use Jobflow, refer to the Jobflow Tutorials and this helpful guide written by Dr. Janine George.</p> <p>Take a moment to read the Jobflow documentation's Quick Start to get a sense of how Jobflow works. Namely, you should understand the <code>Job</code> and <code>Flow</code> definitions, which describe individual compute tasks and workflows, respectively.</p> <p>Important</p> <p>Make sure you have specified <code>\"jobflow\"</code> as the <code>WORKFLOW_ENGINE</code> in your quacc settings.</p> <pre><code>import jobflow as jf\n@jf.job #  (1)!\ndef add(a, b):\nreturn a + b\n@jf.job\ndef mult(a, b):\nreturn a * b\njob1 = add(1, 2)\njob2 = mult(job1.output, 3)\nflow = jf.Flow([job1, job2])  # (2)!\nresponses = jf.run_locally(flow)  # (3)!\nresult = responses[job2.uuid][1].output  # 9\n</code></pre> <ol> <li> <p>The <code>@jf.job</code> decorator tells Jobflow to treat the function as a compute job.</p> </li> <li> <p>The Jobflow <code>Flow</code> object is a class that tells Jobflow to treat the list of jobs as a workflow. We cannot use the quacc <code>@flow</code> decorator with Jobflow.</p> </li> <li> <p><code>run_locally</code> is a function that tells Jobflow to run the workflow locally.</p> </li> </ol>"},{"location":"user/basics/wflow_syntax.html#dynamic-workflow","title":"Dynamic Workflow","text":"<p>Let's do the following:</p> <ol> <li>Add two numbers (e.g. <code>1 + 2</code>)</li> <li>Make a list of copies of the output from Step 1 (e.g. <code>[3, 3, 3]</code>) where the size of the list is not known until runtime</li> <li>Add a third number to each element of the list from Step 2 (e.g. <code>[3 + 3, 3 + 3, 3 + 3]</code>)</li> </ol> <p>We will treat this as a dynamic workflow where the number of elements in the list from Step 2 may not necessarily be known until runtime. In practice, we would want each of the individual addition tasks to be their own compute job.</p> <pre><code>graph LR\n  A[Input] --&gt; B(add) --&gt; C(make_more)\n  C --&gt; D(add) --&gt; G[Output];\n  C --&gt; E(add) --&gt; G[Output];\n  C --&gt; F(add) --&gt; G[Output];</code></pre> CovalentParslJobflow <pre><code>import random\nimport covalent as ct\n@ct.electron\ndef add(a, b):\nreturn a + b\n@ct.electron\ndef make_more(val):\nreturn [val] * random.randint(2, 5)\n@ct.electron #  (1)!\n@ct.lattice\ndef add_distributed(vals, c):\nreturn [add(val, c) for val in vals]\n@ct.lattice\ndef workflow(a, b, c):\nresult1 = add(a, b)\nresult2 = make_more(result1)\nreturn add_distributed(result2, c)\n# Dispatched\ndispatch_id = ct.dispatch(workflow)(1, 2, 3)\nprint(ct.get_result(dispatch_id, wait=True))  # e.g. [6, 6, 6]\n</code></pre> <ol> <li>The <code>@ct.electron(@ct.lattice)</code> pattern is called a sublattice and tells Covalent to treat the function as a dynamic, sub-workflow.</li> </ol> <pre><code>from parsl import join_app, python_app\n@python_app\ndef add(a, b):\nreturn a + b\n@python_app\ndef make_more(val):\nimport random\nreturn [val] * random.randint(2, 5)\n@join_app #  (1)!\ndef add_distributed(vals, c):\nreturn [add(val, c) for val in vals]\nfuture1 = add(1, 2)\nfuture2 = make_more(future1)\nfuture3 = add_distributed(future2, 3)\nresult = future3.result()  # e.g. [6, 6, 6]\n</code></pre> <ol> <li>The <code>@join_app</code> decorator tells Parsl to treat the function as a dynamic, sub-workflow. Calling <code>.result()</code> will wait for all of the jobs to finish before returning the result.</li> </ol> <pre><code>import random\nimport jobflow as jf\nfrom quacc import job\n@jf.job\ndef add(a, b):\nreturn a + b\n@jf.job\ndef make_more(val):\nreturn [val] * random.randint(2, 5)\n@jf.job\ndef add_distributed(vals, c):\njobs = []\nfor val in vals:\njobs.append(add(val, c))\nreturn jf.Response(replace=jf.Flow(jobs))  # (1)\njob1 = add(1, 2)\njob2 = make_more(job1.output)\njob3 = add_distributed(job2.output, 3)\nflow = jf.Flow([job1, job2, job3])\nresponses = jf.run_locally(flow)  # e.g. [6, 6, 6] (job3.output)\n</code></pre> <ol> <li><code>Response(replace=Flow(&lt;jobs&gt;))</code> is a class that tells Jobflow to replace the current job with the specified <code>Flow</code>.</li> </ol>"},{"location":"user/basics/wflow_syntax.html#unified-workflow-syntax","title":"Unified Workflow Syntax","text":"<p>To help enable interoperability between workflow engines, quacc offers a unified set of decorators.</p> Quacc Covalent Parsl Jobflow <code>@job</code> <code>@ct.electron</code> <code>@python_app</code> <code>@job</code> <code>@flow</code> <code>@ct.lattice</code> N/A N/A <code>@subflow</code> <code>@ct.electron(@ct.lattice)</code> <code>@join_app</code> N/A <p>The quacc descriptors are drop-in replacements for the specified workflow engine analogue.</p> <p>Based on the value for the <code>WORKFLOW_ENGINE</code> global variable in your quacc settings, the appropriate decorator will be automatically selected. If the <code>WORKFLOW_ENGINE</code> setting is set to <code>None</code> (or for any entries marked N/A in the above table), the decorators will have no effect on the underlying function.</p>"},{"location":"user/basics/wflow_syntax.html#learn-more","title":"Learn More","text":"CovalentParslJobflow <p>If you want to learn more about Covalent, you can read the Covalent Documentation. Please refer to the Covalent Discussion Board for any Covalent-specific questions.</p> <p>If you want to learn more about Parsl, you can read the Parsl Documentation. Please refer to the Parsl Slack Channel for any Parsl-specific questions.</p> <p>If you want to learn more about Jobflow, you can read the Jobflow Documentation. Please refer to the Jobflow Discussions Board for Jobflow-specific questions.</p>"},{"location":"user/recipes/dftb.html","title":"DFTB+","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p>"},{"location":"user/recipes/emt.html","title":"EMT","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p> <p>Recipes based on the effective medium theory (EMT) calculator in ASE. This is primarily for demonstration purposes.</p>"},{"location":"user/recipes/emt.html#available-recipes","title":"Available Recipes","text":"Recipe Description <code>emt.core.relax_job</code> Relax a structure. <code>emt.core.static_job</code> Static calculation on a structure. <code>emt.slabs.bulk_to_slabs_flow</code> Generate, relax, and static calculations on slabs"},{"location":"user/recipes/emt.html#examples","title":"Examples","text":""},{"location":"user/recipes/emt.html#core-recipes","title":"Core Recipes","text":"<pre><code>graph LR\n  A[Input] --&gt; B(EMT Cell Relax) --&gt; C[Output];</code></pre> No Workflow EngineCovalentParsl <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\natoms = bulk(\"Cu\")\noutput1 = relax_job(atoms, relax_cell=True)\noutput2 = static_job(output1)\n</code></pre> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n@flow\ndef workflow(atoms):\noutput1 = relax_job(atoms, relax_cell=True)\noutput2 = static_job(output1)\nreturn output2\natoms = bulk(\"Cu\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nct.get_result(dispatch_id, wait=True)\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\natoms = bulk(\"Cu\")\nfuture1 = relax_job(atoms, relax_cell=True)\nfuture2 = static_job(future1)\nfuture2.result()\n</code></pre>"},{"location":"user/recipes/emt.html#slab-recipes","title":"Slab Recipes","text":"<pre><code>graph LR\n  A[Input] --&gt; B(Make Slabs) --&gt; C(Relax Slabs) --&gt; D(Static Slabs) --&gt; E[Output];</code></pre> No Workflow EngineCovalentParsl <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\natoms = bulk(\"Ni\")\noutput = bulk_to_slabs_flow(atoms)\n</code></pre> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n@flow\ndef workflow(atoms):\natoms = bulk(\"Ni\")\noutput = bulk_to_slabs_flow(atoms)\nreturn output\ndispatch_id = ct.dispatch(workflow)(atoms)\nct.get_result(dispatch_id, wait=True)\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\natoms = bulk(\"Ni\")\nfuture = bulk_to_slabs_flow(atoms)\nfuture.result()\n</code></pre> <pre><code>graph LR\n  A[Input] --&gt; B(Make Slabs) --&gt; C(Relax Slabs) --&gt; D[Output];</code></pre> No Workflow EngineCovalentParsl <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\natoms = bulk(\"Cu\")\noutput = bulk_to_slabs_flow(\natoms, make_slabs_kwargs={\"max_index\": 2, \"min_slab_size\": 15.0}, slab_static=None\n)\n</code></pre> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n@flow\ndef workflow(atoms):\noutput = bulk_to_slabs_flow(\natoms,\nmake_slabs_kwargs={\"max_index\": 2, \"min_slab_size\": 15.0},\nslab_static=None,\n)\nreturn output\natoms = bulk(\"Cu\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nct.get_result(dispatch_id, wait=True)\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\natoms = bulk(\"Cu\")\nfuture = bulk_to_slabs_flow(\natoms, make_slabs_kwargs={\"max_index\": 2, \"min_slab_size\": 15.0}, slab_static=None\n)\nfuture.result()\n</code></pre>"},{"location":"user/recipes/gaussian.html","title":"Gaussian","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p>"},{"location":"user/recipes/gulp.html","title":"GULP","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p>"},{"location":"user/recipes/lj.html","title":"Lennard-Jones","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p> <p>Recipes for a simple Lennard-Jones calculator. Primarily used for demonstration purposes.</p>"},{"location":"user/recipes/lj.html#available-recipes","title":"Available Recipes","text":"Recipes Description <code>lj.core.static_job</code> Static calculation on a molecule. <code>lj.core.relax_job</code> Relax a molecule. <code>lj.core.freq_job</code> Frequency calculation on a molecule."},{"location":"user/recipes/lj.html#examples","title":"Examples","text":""},{"location":"user/recipes/lj.html#core-recipes","title":"Core Recipes","text":""},{"location":"user/recipes/newtonnet.html","title":"NewtonNet","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p>"},{"location":"user/recipes/orca.html","title":"ORCA","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p>"},{"location":"user/recipes/psi4.html","title":"Psi4","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p> <p>Recipes based on the Psi4 code.</p>"},{"location":"user/recipes/psi4.html#available-recipes","title":"Available Recipes","text":"Recipe Description <code>psi4.core.static_job</code> Static calculation on a molecule."},{"location":"user/recipes/psi4.html#examples","title":"Examples","text":""},{"location":"user/recipes/psi4.html#core-recipes","title":"Core Recipes","text":"<pre><code>graph LR\n  A[Input] --&gt; B(Psi4 Static) --&gt; C[Output];</code></pre> No Workflow EngineCovalentParsl <pre><code>from ase.build import molecule\nfrom quacc.recipes.psi4.core import static_job\natoms = molecule(\"O2\")\noutput = static_job(atoms, charge=0, multiplicity=3, method=\"wb97m-v\", basis=\"def2-svp\")\n</code></pre> <pre><code>import covalent as ct\nfrom ase.build import molecule\nfrom quacc import flow\nfrom quacc.recipes.psi4.core import static_job\nworkflow = flow(static_job)\natoms = molecule(\"O2\")\ndispatch_id = ct.dispatch(workflow)(\natoms, charge=0, multiplicity=3, method=\"wb97m-v\", basis=\"def2-svp\"\n)\nct.get_result(dispatch_id, wait=True)\n</code></pre> <pre><code>from ase.build import molecule\nfrom quacc.recipes.psi4.core import static_job\natoms = molecule(\"O2\")\nfuture = static_job(atoms, charge=0, multiplicity=3, method=\"wb97m-v\", basis=\"def2-svp\")\nfuture.result()\n</code></pre>"},{"location":"user/recipes/qchem.html","title":"Q-Chem","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p>"},{"location":"user/recipes/tblite.html","title":"TBLite","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p> <p>Recipes based on the TBLite code, which has a Python interface to the xtb library for semi-empirical tight-binding calculations.</p>"},{"location":"user/recipes/tblite.html#available-recipes","title":"Available Recipes","text":"Recipe Description <code>tblie.core.relax_job</code> Relax a molecule or crystal. <code>tblite.core.static_job</code> Static calculation on a molecule or crystal. <code>tblite.core.freq_job</code> Frequency calculation on a molecule or crystal."},{"location":"user/recipes/tblite.html#examples","title":"Examples","text":""},{"location":"user/recipes/tblite.html#core-recipes","title":"Core Recipes","text":"<pre><code>graph LR\n  A[Input] --&gt; B(GFN2-xTB Cell Relax) --&gt; C[Output];</code></pre> No Workflow EngineCovalentParsl <pre><code>from ase.build import bulk\nfrom quacc.recipes.tblite.core import relax_job\natoms = bulk(\"C\")\noutput = relax_job(atoms, relax_cell=True)\n</code></pre> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.tblite.core import relax_job\n@flow\ndef workflow(atoms):\noutput = relax_job(atoms, relax_cell=True)\nreturn output\natoms = bulk(\"C\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nct.get_result(dispatch_id, wait=True)\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.tblite.core import relax_job\natoms = bulk(\"C\")\nfuture = relax_job(atoms, relax_cell=True)\nfuture.result()\n</code></pre> <pre><code>graph LR\n  A[Input] --&gt; B(GFN1-xTB Relax) --&gt; C(GFN2-xTB Static) --&gt; D(GFN2-xTB Frequency) --&gt; E[Output];</code></pre> No Workflow EngineCovalentParsl <pre><code>from ase.build import molecule\nfrom ase.optimize import BFGS\nfrom quacc.recipes.tblite.core import freq_job, relax_job, static_job\natoms = molecule(\"CH4\")\noutput1 = relax_job(atoms, method=\"GFN1-xTB\", opt_swaps={\"optimizer\": BFGS})\noutput2 = static_job(output1)\noutput3 = freq_job(\natoms, energy=output2[\"results\"][\"energy\"], temperature=300.0, pressure=2.0\n)\n</code></pre> <pre><code>import covalent as ct\nfrom ase.build import molecule\nfrom ase.optimize import BFGS\nfrom quacc import flow\nfrom quacc.recipes.tblite.core import freq_job, relax_job, static_job\n@flow\ndef workflow(atoms):\noutput1 = relax_job(atoms, method=\"GFN1-xTB\", opt_swaps={\"optimizer\": BFGS})\noutput2 = static_job(output1)\noutput3 = freq_job(\natoms, energy=output2[\"results\"][\"energy\"], temperature=300.0, pressure=2.0\n)\nreturn outpu3\natoms = molecule(\"CH4\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nct.get_result(dispatch_id, wait=True)\n</code></pre> <pre><code>from ase.build import molecule\nfrom ase.optimize import BFGS\nfrom quacc.recipes.tblite.core import freq_job, relax_job, static_job\natoms = molecule(\"CH4\")\nfuture1 = relax_job(atoms, method=\"GFN1-xTB\", opt_swaps={\"optimizer\": BFGS})\nfuture2 = static_job(future1)\nfuture3 = freq_job(\natoms, energy=future2.result()[\"results\"][\"energy\"], temperature=300.0, pressure=2.0\n)\nfuture3.result()\n</code></pre>"},{"location":"user/recipes/vasp.html","title":"VASP","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p>"},{"location":"user/wflow_engine/executors.html","title":"Deploying Calculations","text":"<p>In the previous examples, we have been running calculations on our local machine. However, in practice, you will probably want to run your calculations on one or more HPC machines. This section will describe how to set up your workflows to run on HPC machines using your desired workflow engine to scale up your calculations.</p> CovalentParslJobflow <p>By default, Covalent will run all <code>Electron</code> tasks on your local machine using the Dask backend. This is a parameter that you can control. For instance, Covalent offers many plugin executors that can be installed and used to interface with a wide range of HPC, cloud, and quantum devices.</p> <p>Setting Executors via the Lattice Object</p> <p>If you want to use the same executor for all the <code>Electron</code> objects in a <code>Lattice</code>, you can pass the <code>executor</code> keyword argument to the <code>@ct.lattice</code> decorator (which is what <code>@flow</code> is equivalent to when setting your <code>WORKFLOW_ENGINE</code> quacc config variable to <code>\"covalent\"</code>).</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n@flow(executor=\"local\")  # (1)!\ndef workflow(atoms):\nresult1 = relax_job(atoms)\nresult2 = static_job(result1)\nreturn result2\natoms = bulk(\"Cu\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <ol> <li>This was merely for demonstration purposes. There is never really a need to use the \"local\" executor since the \"dask\" executor runs locally and is faster.</li> </ol> <p>Setting Executors via the Electron Objects</p> <p>The individual <code>Electron</code> executor options can be modified after they are imported as follows:</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n@flow\ndef workflow(atoms):\njob1 = relax_job\njob1.electron_object.executor = \"dask\"  # (1)!\njob2 = static_job\njob2.electron_object.executor = \"local\"  # (2)!\noutput1 = job1(atoms)\noutput2 = job2(output1)\nreturn output2\natoms = bulk(\"Cu\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <ol> <li> <p>If you are defining your own workflow functions to use, you can also set the executor for individual <code>Electron</code> objects by passing the <code>executor</code> keyword argument to the <code>@ct.electron</code> decorator.</p> </li> <li> <p>This was merely for demonstration purposes. There is never really a need to use the \"local\" executor since the \"dask\" executor runs locally and is faster.</p> </li> </ol> <p>Configuring Executors</p> <p>Tip</p> <p>Refer to the executor documentation for instructions on how to install and use the relevant plugins that allow Covalent to submit jobs on your desired machines.</p> <p>Most users of quacc will probably want to use the <code>HPCExecutor</code>, which is a plugin for Covalent that supports Slurm, PBS, LSF, Flux, and more. For submitting jobs to a Slurm-based job scheduler from your local machine, an example <code>HPCExecutor</code> configuration might look like the following, which has been tested on Perlmutter at NERSC:</p> <pre><code>executor = ct.executor.HPCExecutor(\n# SSH credentials\nusername=\"YourUserName\",\naddress=\"perlmutter-p1.nersc.gov\",\nssh_key_file=\"~/.ssh/nersc\",\ncert_file=\"~/.ssh/nersc-cert.pub\",  # (1)!\n# PSI/J parameters\ninstance=\"slurm\",\nresource_spec_kwargs={\n\"nodes\": n_nodes,\n\"processes_per_node\": n_cores_per_node,\n},  # (2)!\njob_attributes_kwargs={\n\"duration\": 10,  # minutes\n\"project_name\": \"YourAccountName\",\n\"custom_attributes\": {\"slurm.constraint\": \"cpu\", \"slurm.qos\": \"debug\"},\n},  # (3)!\nenvironment={\"QUACC_VASP_PARALLEL_CMD\": vasp_parallel_cmd},\n# Pre-/post-launch commands\npre_launch_cmds=[\"module load vasp\"],\n# Remote Python env parameters\nremote_conda_env=\"quacc\",\n# Covalent parameters\nremote_workdir=\"$SCRATCH/quacc\",\ncreate_unique_workdir=True,  # (4)!\n)\n</code></pre> <ol> <li> <p>This a certificate file used to validate your SSH credentials. This is often not needed but is required at NERSC facilities due to the use of <code>sshproxy</code>-based multi-factor authentication.</p> </li> <li> <p>These are the resource specifications for the compute job, which are keyword arguments passed to PSI/J's <code>ResourceSpecV1</code> class.</p> </li> <li> <p>These are the job attributes that the job scheduler needs, which are keyword arguments passed to PSI/J's <code>JobAttributes</code> class.</p> </li> <li> <p>You generally want each quacc job to be run in its own unique working directory to ensure files don't overwrite one another, so  <code>create_unique_workdir</code> should be set to <code>True</code>.</p> </li> </ol> <p>Note</p> <p>If you are using Perlmutter at NERSC, you will need to adjust the Covalent configuration directory because the home directory does not support file locking:</p> ~/.bashrc<pre><code>export COVALENT_CONFIG_DIR=\"$SCRATCH/.config/covalent\"\n</code></pre> <p>Out-of-the-box, Parsl will run on your local machine. However, in practice you will probably want to run your Parsl workflows on HPC machines.</p> <p>Configuring Executors</p> <p>Tip</p> <p>To configure Parsl for the high-performance computing environment of your choice, refer to the executor Configuration page in the Parsl documentation.</p> <p>For Perlmutter at NERSC, example <code>HighThroughputExecutor</code> configurations can be found in the NERSC Documentation. A simple one is reproduced below that allows for job submission from the login node. This example will create a single Slurm job that will run one <code>PythonApp</code> at a time on a single node and is good for testing out some of the examples above.</p> <pre><code>import parsl\nfrom parsl.config import Config\nfrom parsl.executors import HighThroughputExecutor\nfrom parsl.launchers import SimpleLauncher\nfrom parsl.providers import SlurmProvider\nconfig = Config(\nmax_idletime=120,  # (1)!\nexecutors=[\nHighThroughputExecutor(\nlabel=\"quacc_HTEX\",  # (2)!\nmax_workers=1,  # (3)!\nprovider=SlurmProvider(  # (4)!\naccount=\"MyAccountName\",\nnodes_per_block=1,  # (5)!\nscheduler_options=\"#SBATCH -q debug -C cpu\",  # (6)!\nworker_init=\"source ~/.bashrc &amp;&amp; conda activate quacc\",\nwalltime=\"00:10:00\",\ncmd_timeout=120,  # (7)!\nlauncher=SimpleLauncher(),  # (8)!\n),\n)\n],\n)\nparsl.load(config)\n</code></pre> <ol> <li> <p>The maximum amount of time (in seconds) to allow the executor to be idle before the Slurm job is cancelled.</p> </li> <li> <p>A label for the executor instance, used during file I/O.</p> </li> <li> <p>Maximum number of workers to allow on a node.</p> </li> <li> <p>The provider to use for job submission. This can be changed to <code>LocalProvider()</code> if you wish to have the Parsl process run on a login node rather than a compute node.</p> </li> <li> <p>The number of nodes to request per job. By default, all cores on the node will be requested (setting <code>cores_per_node</code> will override this).</p> </li> <li> <p>Any additional <code>#SBATCH</code> options not captured elsewhere can be included here.</p> </li> <li> <p>The maximum time to wait (in seconds) for the job scheduler info to be retrieved/sent.</p> </li> <li> <p>The type of Launcher to use. Note that <code>SimpleLauncher()</code> must be used instead of the commonly used <code>SrunLauncher()</code> to allow quacc subprocesses to launch their own <code>srun</code> commands.</p> </li> </ol> <p>Unlike some other workflow engines, Parsl is built for the pilot job model where the allocated nodes continually pull in new workers (until the walltime is reached or the parent Python process is killed). This makes it possible to avoid submitting a large number of small jobs to the scheduler, which can be inefficient. As a result, don't be surprised if the Slurm job continues to run even when your submitted task has completed, particularly if you are using a Jupyter Notebook or IPython kernel.</p> <p>Scaling Up</p> <p>Now let's consider a more realistic scenario. Suppose we want to have a single Slurm job that reserves 8 nodes, and each <code>PythonApp</code> (e.g. VASP calculation) will run on 2 nodes (let's assume each node has 48 cores total, so that's a total of 96 cores for each calculation). Parsl will act as an orchestrator in the background of one of the nodes. Our config will now look like the following.</p> <pre><code>import parsl\nfrom parsl.config import Config\nfrom parsl.executors import HighThroughputExecutor\nfrom parsl.launchers import SimpleLauncher\nfrom parsl.providers import SlurmProvider\nn_parallel_calcs = 4  # Number of quacc calculations to run in parallel\nn_nodes_per_calc = 2  # Number of nodes to reserve for each calculation\nn_cores_per_node = 48  # Number of CPU cores per node\nvasp_parallel_cmd = (\nf\"srun -N {n_nodes} --ntasks-per-node={n_cores_per_node} --cpu_bind=cores'\"\n)\nconfig = Config(\nmax_idletime=300,\nexecutors=[\nHighThroughputExecutor(\nlabel=\"quacc_HTEX\",\nmax_workers=n_parallel_calcs,\ncores_per_worker=1e-6,  # (1)!\nprovider=SlurmProvider(\naccount=\"MyAccountName\",\nnodes_per_block=n_nodes_per_calc * n_parallel_calcs,\nscheduler_options=\"#SBATCH -q debug -C cpu\",\nworker_init=f\"source ~/.bashrc &amp;&amp; conda activate quacc &amp;&amp; module load vasp &amp;&amp; export QUACC_VASP_PARALLEL_CMD={vasp_parallel_cmd}\",\nwalltime=\"00:10:00\",\nlauncher=SimpleLauncher(),\ncmd_timeout=120,\ninit_blocks=0,  # (2)!\nmin_blocks=1,  # (3)!\nmax_blocks=1,  # (4)!\n),\n)\n],\n)\nparsl.load(config)\n</code></pre> <ol> <li> <p>We set this to a small value so that the pilot job (e.g. the Parsl orchestrator) is allowed to be oversubscribed with scheduling processes.</p> </li> <li> <p>Sets the number of blocks (e.g. Slurm jobs) to provision during initialization of the workflow. We set this to 0 so that we only begin queuing once a workflow is submitted.</p> </li> <li> <p>Sets the minimum number of blocks (e.g. Slurm jobs) to maintain during elastic resource management. We set this to 1 so that the pilot job is always running.</p> </li> <li> <p>Sets the maximum number of active blocks (e.g. Slurm jobs) during elastic resource management. We set this to 1 here for demonstration purposes, but it can be increased to have multiple Slurm jobpacks running simultaneously.</p> </li> </ol> <p>Multiple Executors</p> <p>Parsl supports tying specific executors to a given <code>PythonApp</code> by specifying it within the <code>@python_app</code> decorator, as discussed in the Multi-Executor section of the Parsl documentation. In quacc, this means that you can specify <code>@job(executors=[\"MyExecutor\"])</code>. Alternatively, after importing a <code>@job</code>-decorated function (e.g. <code>my_job</code>), you can do <code>my_job.executors=[\"MyExecutor\"]</code>.</p> <p>Out-of-the-box, Jobflow can be used to run on your local machine. You will, however, need a \"manager\" to run your workflows on HPC machines. The currently recommended manager for Jobflow is FireWorks, which is described here.</p> <p>Converting Between Jobflow and FireWorks</p> <p>The <code>jobflow.managers.fireworks</code> module has all the tools you need to convert your Jobflow workflows to a format that is suitable for FireWorks.</p> <p>Converting a Job to a Firework</p> <p>To convert a <code>Job</code> to a <code>firework</code> and add it to your launch pad:</p> <pre><code>from fireworks import LaunchPad\nfrom jobflow.managers.fireworks import job_to_firework\nfw = job_to_firework(job)\nlpad = LaunchPad.auto_load()\nlpad.add_wf(fw)\n</code></pre> <p>Converting a Flow to a Workflow</p> <p>To convert a <code>Flow</code> to a <code>workflow</code> and add it to your launch pad:</p> <pre><code>from fireworks import LaunchPad\nfrom jobflow.managers.fireworks import flow_to_workflow\nwf = flow_to_workflow(flow)\nlpad = LaunchPad.auto_load()\nlpad.add_wf(wf)\n</code></pre> <p>Setting Where Jobs are Dispatched</p> <p>The <code>my_qadapter.yaml</code> file you made in the installation instructions specifies how FireWorks will submit jobs added to your launch pad. Additional details can be found in the Jobflow Documentation for how to dynamically set where and how Jobflow <code>Job</code> and <code>Flow</code> objects can be dispatched.</p> <p>Dispatching Calculations</p> <p>With a workflow added to your launch pad, on the desired machine of choice, you can run <code>qlaunch rapidfire --nlaunches &lt;N&gt;</code> (where <code>&lt;N&gt;</code> is the number of jobs to submit) in the command line to submit your workflows to the job scheduler. Running <code>qlaunch rapidfire -m &lt;N&gt;</code> will ensure that <code>&lt;N&gt;</code> jobs are always in the queue or running. To modify the order in which jobs are run, a priority can be set via <code>lpad set_priority &lt;priority&gt; -i &lt;FWID&gt;</code> where <code>&lt;priority&gt;</code> is a number.</p> <p>By default, <code>qlaunch</code> will launch compute jobs that each poll for a single FireWork to run. This means that more Slurm jobs may be submitted than there are jobs to run. To modify the behavior of <code>qlaunch</code> to only submit a Slurm job for each \"READY\" FireWork in the launchpad, use the <code>-r</code> (\"reserved\") flag.</p> <p>Monitoring the Launchpad</p> <p>The easiest way to monitor the state of your launched FireWorks and workflows is through the GUI, which can be viewed with <code>lpad webgui</code>. To get the status of running fireworks from the command line, you can run <code>lpad get_fws -s RUNNING</code>. Other statuses can also be provided as well as individual FireWorks IDs.</p> <p>To rerun a specific FireWork, one can use the <code>rerun_fws</code> command like so: <code>lpad rerun_fws -i &lt;FWID&gt;</code> where <code>&lt;FWID&gt;</code> is the FireWork ID. Similarly, one can rerun all fizzled jobs via <code>lpad rerun_fws -s FIZZLED</code>. More complicated Mongo-style queries can also be carried out. Cancelling a workflow can be done with <code>lpad delete_wflows -i &lt;FWID&gt;</code>.</p> <p>Refer to the <code>lpad -h</code> help menu for more details.</p> <p>Continuous Job Submission</p> <p>To ensure that jobs are continually submitted to the queue you can use <code>tmux</code> to preserve the job submission process even when the SSH session is terminated. For example, running <code>tmux new -s launcher</code> will create a new <code>tmux</code> session named <code>launcher</code>. To exit the <code>tmux</code> session while still preserving any running tasks on the login node, press <code>ctrl+b</code> followed by <code>d</code>. To re-enter the tmux session, run <code>tmux attach -t launcher</code>. Additional <code>tmux</code> commands can be found on the tmux cheatsheet.</p>"},{"location":"user/wflow_engine/wflow_engines1.html","title":"Pre-Defined Recipes","text":"<p>Here, we will show how to use quacc with one of a variety of workflow engines to construct, dispatch, and monitor your calculations.</p> <p>In quacc, there are two types of recipes:</p> <ol> <li>Individual compute jobs with the suffix <code>_job</code> that have been pre-defined with a <code>@job</code> decorator.</li> <li>Multi-step workflows with the suffix <code>_flow</code> that have been pre-defined with a <code>@flow</code> decorator.</li> </ol> <p>Tip</p> <p>As a friendly reminder from the Workflow Syntax section:</p> Quacc Covalent Parsl Jobflow <code>@job</code> <code>@ct.electron</code> <code>@python_app</code> <code>@job</code> <code>@flow</code> <code>@ct.lattice</code> N/A N/A <code>@subflow</code> <code>@ct.electron(@ct.lattice)</code> <code>@join_app</code> N/A"},{"location":"user/wflow_engine/wflow_engines1.html#running-a-pre-defined-job","title":"Running a Pre-Defined Job","text":"<p>We will now try running a pre-defined job where we relax a bulk Cu structure using EMT, which is pre-defined in quacc as <code>quacc.recipes.emt.core.relax_job</code>.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; C[Output];</code></pre> CovalentParslJobflow <p>Important</p> <p>If you haven't done so yet, make sure you started the Covalent server with <code>covalent start</code> in the command-line.</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\n# Define the workflow\nworkflow = flow(relax_job)  # (1)!\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Dispatch the workflow to the Covalent server\n# with the bulk Cu Atoms object as the input\ndispatch_id = ct.dispatch(workflow)(atoms)  # (2)!\n# Fetch the result from the server\nresult = ct.get_result(dispatch_id, wait=True)  # (3)!\nprint(result)\n</code></pre> <ol> <li> <p>This is shorthand for the following:</p> <pre><code>@flow\ndef workflow(atoms):\nreturn relax_job(atoms)\n</code></pre> <p>Also note that the <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why did not need to include it here.</p> </li> <li> <p>Because the workflow is only sent to the server with <code>ct.dispatch</code>, calling <code>workflow(atoms)</code> would run the workflow as a normal function without Covalent having any role.</p> </li> <li> <p>You don't need to set <code>wait=True</code> in practice. Once you call <code>ct.dispatch</code>, the workflow will begin running. The <code>ct.get_result</code> function is used to fetch the workflow status and results from the server.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you have loaded a Parsl configuration in your Python script. An example for running on your local machine is included below.</p> <pre><code>import parsl\nparsl.load()\n</code></pre> <p>Also make sure you have specified <code>\"parsl\"</code> as the <code>WORKFLOW_ENGINE</code> in your quacc settings.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Call the PythonApp\nfuture = relax_job(atoms)  # (1)!\n# Print result\nprint(future.result())  # (2)!\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why did not need to include it here. We also did not need to use a <code>@flow</code> decorator because Parsl does not have an analogous decorator.</p> </li> <li> <p>The use of <code>.result()</code> serves to block any further calculations from running until it is resolved. Calling <code>.result()</code> also returns the function output as opposed to the <code>AppFuture</code> object.</p> </li> </ol> <p>Important</p> <p>Make sure you have specified <code>\"jobflow\"</code> as the <code>WORKFLOW_ENGINE</code> in your quacc settings.</p> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Define the Job\njob = relax_job(atoms)  # (1)!\n# Run the job locally\nresponses = jf.run_locally(job, create_folders=True)  # (2)!\n# Get the result\nresult = responses[job.uuid][1].output\nprint(result)\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why did not need to include it here.</p> </li> <li> <p>We chose to run the job locally, but other workflow managers supported by Jobflow can be imported and used.</p> </li> </ol>"},{"location":"user/wflow_engine/wflow_engines1.html#running-a-pre-defined-workflow","title":"Running a Pre-Defined Workflow","text":"<p>We will now try running a pre-defined workflow where we carve all possible slabs from a given structure, run a new relaxation calculation on each slab, and then a static calculation for each relaxed slab. This is implemented in <code>quacc.recipes.emt.slabs.bulk_to_slabs_flow</code>.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Make Slabs)\n  B --&gt; C(Slab Relax) --&gt; G(Slab Static) --&gt; K[Output]\n  B --&gt; D(Slab Relax) --&gt; H(Slab Static) --&gt; K[Output]\n  B --&gt; E(Slab Relax) --&gt; I(Slab Static) --&gt; K[Output]\n  B --&gt; F(Slab Relax) --&gt; J(Slab Static) --&gt; K[Output];</code></pre> CovalentParslJobflow <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n# Define the Atoms object\natoms = bulk(\"Cu\")\n# Dispatch the workflow\ndispatch_id = ct.dispatch(bulk_to_slabs_flow)(atoms)  # (1)!\n# Print the results\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <ol> <li>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a decorator because it is already pre-decorated with a <code>@flow</code> decorator.</li> </ol> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n# Define the Atoms object\natoms = bulk(\"Cu\")\n# Define the workflow\nfuture = bulk_to_slabs_flow(atoms)  # (1)!\n# Print the results\nprint(future.result())\n</code></pre> <ol> <li>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a decorator because it is already pre-decorated with a <code>@flow</code> decorator.</li> </ol> <p>Due to the difference in how Jobflow handles dynamic workflows compared to Covalent and Parsl, any quacc recipes that have been pre-defined with a <code>@flow</code> decorator (i.e. those with <code>_flow</code> in the name) cannot be used with Jobflow directly.</p> <p>That said, quacc fully supports custom Jobflow-based workflows to resolve this limitation. For example, instead of using <code>.emt.slabs.bulk_to_slabs_flow</code>, this workflow can be equivalently run as follows using the Jobflow-specific <code>.emt._jobflow.slabs.bulk_to_slabs_flow</code> function.</p> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom quacc.recipes.emt._jobflow.slabs import bulk_to_slabs_flow\n# Define the Atoms object\natoms = bulk(\"Cu\")\n# Construct the Flow\nflow = bulk_to_slabs_flow(atoms)\n# Run the workflow locally\njf.run_locally(flow, create_folders=True)\n</code></pre> <p>In the case of the Jobflow-specific <code>bulk_to_slabs_flow</code>, it returns a <code>Response(replace)</code> object that dynamically replaces the <code>Flow</code> with several downstream jobs.</p>"},{"location":"user/wflow_engine/wflow_engines2.html","title":"Combining Recipes","text":"<p>Here, we will show how to use combine quacc jobs and workflows into your own custom workflows that can be run with your chosen workflow engine.</p>"},{"location":"user/wflow_engine/wflow_engines2.html#running-a-user-constructed-serial-workflow","title":"Running a User-Constructed Serial Workflow","text":"<p>We will now try running a simple workflow where we relax a bulk Cu structure using EMT and take the output of that calculation as the input to a follow-up static calculation with EMT.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; C(Static) --&gt; D[Output];</code></pre> CovalentParslJobflow <p>Important</p> <p>If you haven't done so yet, make sure you started the Covalent server with <code>covalent start</code> in the command-line.</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n# Define the workflow\n@flow  # (1)!\ndef workflow(atoms):\n# Define Job 1\nresult1 = relax_job(atoms)  # (2)!\n# Define Job 2, which takes the output of Job 1 as input\nresult2 = static_job(result1)\nreturn result2\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Dispatch the workflow to the Covalent server\n# with the bulk Cu Atoms object as the input\ndispatch_id = ct.dispatch(workflow)(atoms)  # (3)!\n# Fetch the result from the server\nresult = ct.get_result(dispatch_id, wait=True)  # (4)!\nprint(result)\n</code></pre> <ol> <li> <p>The <code>@flow</code> decorator defines the workflow that will be executed.</p> </li> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why did not need to include it here.</p> </li> <li> <p>Because the workflow is only sent to the server with <code>ct.dispatch</code>, calling <code>workflow(atoms)</code> would run the workflow as if Covalent were not being used at all.</p> </li> <li> <p>You don't need to set <code>wait=True</code> in practice. Once you call <code>ct.dispatch</code>, the workflow will begin running. The <code>ct.get_result</code> function is used to fetch the workflow status and results from the server.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you have loaded a Parsl configuration in your Python script. An example for running on your local machine is included below.</p> <pre><code>import parsl\nparsl.load()\n</code></pre> <p>Also make sure you have specified <code>\"parsl\"</code> as the <code>WORKFLOW_ENGINE</code> in your quacc settings.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Call App 1\nfuture1 = relax_job(atoms)  # (1)!\n# Call App 2, which takes the output of App 1 as input\nfuture2 = static_job(future1)\n# Print result\nprint(future2.result())  # (2)!\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why did not need to include it here.</p> </li> <li> <p>The use of <code>.result()</code> serves to block any further calculations from running until it is resolved. Calling <code>.result()</code> also returns the function output as opposed to the <code>AppFuture</code> object.</p> </li> </ol> <p>Note</p> <p>Parsl <code>PythonApp</code>/<code>JoinApp</code> objects will implicitly know to call <code>.result()</code> on any <code>AppFuture</code> it receives. As such, you should avoid calling <code>.result()</code> within a <code>PythonApp</code>/<code>JoinApp</code> definition or between <code>PythonApp</code>/<code>JoinApp</code> objects if possible.</p> <p>Important</p> <p>Make sure you have specified <code>\"jobflow\"</code> as the <code>WORKFLOW_ENGINE</code> in your quacc settings.</p> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Define Job 1\njob1 = relax_job(atoms)  # (1)!\n# Define Job 2, which takes the output of Job 1 as input\njob2 = static_job(job1.output)  # (2)!\n# Define the workflow\nworkflow = jf.Flow([job1, job2])  # (3)!\n# Run the workflow locally\nresponses = jf.run_locally(workflow, create_folders=True)  # (4)!\n# Get the result\nresult = responses[job2.uuid][1].output\nprint(result)\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why did not need to include it here.</p> </li> <li> <p>In Jobflow, each <code>Job</code> is only a reference and so the <code>.output</code> must be explicitly passed between jobs.</p> </li> <li> <p>We must stitch the individual <code>Job</code> objects together into a <code>jf.Flow</code>, which can be easily achieved by passing them as a list to the <code>jf.Flow()</code> constructor.</p> </li> <li> <p>We chose to run the job locally, but other workflow managers supported by Jobflow can be imported and used.</p> </li> </ol>"},{"location":"user/wflow_engine/wflow_engines2.html#running-a-user-constructed-parallel-workflow","title":"Running a User-Constructed Parallel Workflow","text":"<p>Now let's consider a similar but nonetheless distinct example. Here, we will define a workflow where we will carry out two EMT structure relaxations, but the two jobs are not dependent on one another. In this example, Covalent will know that it can run the two jobs separately, and even if Job 1 were to fail, Job 2 would still progress.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; D[Output]\n  A[Input] --&gt; C(Relax) --&gt; D[Output];</code></pre> CovalentParslJobflow <pre><code>from ase.build import bulk, molecule\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\n# Define workflow\n@flow\ndef workflow(atoms1, atoms2):\n# Define two independent relaxation jobs\nresult1 = relax_job(atoms1)\nresult2 = relax_job(atoms2)\nreturn {\"result1\": result1, \"result2\": result2}\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n# Dispatch the workflow to the Covalent server\ndispatch_id = ct.dispatch(workflow)(atoms1, atoms2)\n# Fetch the results from the server\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <pre><code>from ase.build import bulk, molecule\nfrom quacc.recipes.emt.core import relax_job\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n# Define two independent relaxation jobs\nfuture1 = relax_job(atoms1)\nfuture2 = relax_job(atoms2)\n# Print the results\nprint(future1.result(), future2.result())\n</code></pre> <pre><code>import jobflow as jf\nfrom ase.build import bulk, molecule\nfrom quacc.recipes.emt.core import relax_job\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n# Define two independent relaxation jobs\njob1 = relax_job(atoms1)\njob2 = relax_job(atoms2)\n# Define the workflow\nworkflow = jf.Flow([job1, job2])\n# Run the workflow locally\nresponses = jf.run_locally(workflow, create_folders=True)\n# Get the result\nresult = responses[job2.uuid][1].output\nprint(result)\n</code></pre>"},{"location":"user/wflow_engine/wflow_engines2.html#running-a-user-constructed-dynamic-workflow","title":"Running a User-Constructed Dynamic Workflow","text":"<p>For this example, let's consider a toy scenario where we wish to relax a bulk Cu structure, carve all possible slabs, and then run a new relaxation calculation on each slab (with no static calculation at the end).</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; C(Make Slabs)\n  C(Make Slabs) --&gt; D(Slab Relax) --&gt; H[Output]\n  C(Make Slabs) --&gt; E(Slab Relax) --&gt; H[Output]\n  C(Make Slabs) --&gt; F(Slab Relax) --&gt; H[Output]\n  C(Make Slabs) --&gt; G(Slab Relax) --&gt; H[Output];</code></pre> CovalentParslJobflow <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n@flow\ndef workflow(atoms):\nrelaxed_bulk = relax_job(atoms)\nrelaxed_slabs = bulk_to_slabs_flow(relaxed_bulk, slab_static=None)  # (1)!\nreturn relaxed_slabs\natoms = bulk(\"Cu\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <ol> <li>We didn't need to wrap bulk_to_slabs_flow with a decorator because it is already pre-decorated with a <code>@flow</code> decorator. We also chose to set <code>slab_static=None</code> here to disable the static calculation that is normally carried out in this workflow.</li> </ol> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n# Define the Atoms object\natoms = bulk(\"Cu\")\n# Define the workflow\nfuture1 = relax_job(atoms)\nfuture2 = bulk_to_slabs_flow(future1, slab_static=None)  # (1)!\n# Print the results\nprint(future2.result())\n</code></pre> <ol> <li>We didn't need to wrap bulk_to_slabs_flow with a decorator because it is already pre-decorated with a <code>@flow</code> decorator. We also chose to set <code>slab_static=None</code> here to disable the static calculation that is normally carried out in this workflow.</li> </ol> <p>Due to the difference in how Jobflow handles dynamic workflows compared to Covalent and Parsl, any quacc recipes with <code>@subflow</code> decorators cannot be used with Jobflow directly.</p> <p>That said, quacc fully supports custom Jobflow-based workflows to resolve this limitation. For example, instead of using <code>.emt.slabs.bulk_to_slabs_flow</code>, this workflow can be equivalently run as follows using the Jobflow-specific <code>.emt._jobflow.slabs.bulk_to_slabs_flow</code> function:</p> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt._jobflow.slabs import bulk_to_slabs_flow\n# Define the Atoms object\natoms = bulk(\"Cu\")\n# Construct the Flow\njob1 = relax_job(atoms)\njob2 = bulk_to_slabs_flow(job1.output, slab_static=None)\nworkflow = jf.Flow([job1, job2])\n# Run the workflow locally\njf.run_locally(workflow, create_folders=True)\n</code></pre> <p>In the case of the Jobflow-specific <code>bulk_to_slabs_flow</code>, it returns a <code>Response(replace)</code> object that dynamically replaces the <code>Flow</code> with several downstream jobs.</p>"}]}